#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sat Nov  7 01:43:53 2020 by generateDS.py version 2.36.6.
# Python 3.9.0 (default, Oct 27 2020, 00:11:08)  [GCC 9.3.0]
#
# Command line options:
#   ('-o', '../py/cda_parser.py')
#
# Command line arguments:
#   CDA_Fi.xsd
#
# Command line:
#   /home/ville/opt/python-3.9.0/bin/generateDS.py -o "../py/cda_parser.py" CDA_Fi.xsd
#
# Current working directory (os.getcwd()):
#   Schemas
#

from six.moves import zip_longest
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = str
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print(("Warning: {}".format(msg)))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in list(mapping.items())))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, str):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                list(filter(excl_select_objs_, list(self.__dict__.items()))),
                list(filter(excl_select_objs_, list(other.__dict__.items())))))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ActClassComposition(str, Enum):
    """specDomain: V19442 (C-0-D11527-V13856-V19445-V19442-cpt)"""
    COMPOSITION='COMPOSITION'


class ActClassCondition(str, Enum):
    """specDomain: V19580 (C-0-D11527-V13856-V11529-V19580-cpt)"""
    COND='COND'


class ActClassContract(str, Enum):
    """specDomain: V14002 (C-0-D11527-V13856-V14002-cpt)"""
    CNTRCT='CNTRCT'


class ActClassControlAct(str, Enum):
    """specDomain: V11534 (C-0-D11527-V13856-V11534-cpt)"""
    CACT='CACT'
    ACTN='ACTN'
    INFO='INFO'
    STC='STC'


class ActClassDocument(str, Enum):
    """specDomain: V18938 (C-0-D11527-V13856-V19445-V19442-V18938-cpt)"""
    DOC='DOC'


class ActClassEntry(str, Enum):
    """specDomain: V19444 (C-0-D11527-V13856-V19445-V19444-cpt)"""
    ENTRY='ENTRY'
    BATTERY='BATTERY'
    CLUSTER='CLUSTER'


class ActClassExtract(str, Enum):
    """specDomain: V19441 (C-0-D11527-V13856-V19445-V19441-cpt)"""
    EXTRACT='EXTRACT'
    EHR='EHR'


class ActClassFinancialContract(str, Enum):
    """specDomain: V14003 (C-0-D11527-V13856-V14002-V14003-cpt)"""
    FCNTRCT='FCNTRCT'
    COV='COV'


class ActClassObservation(str, Enum):
    """specDomain: V11529 (C-0-D11527-V13856-V11529-cpt)"""
    OBS='OBS'
    ALRT='ALRT'
    CLNTRL='CLNTRL'
    CNOD='CNOD'
    DGIMG='DGIMG'
    INVSTG='INVSTG'
    SPCOBS='SPCOBS'


class ActClassObservationSeries(str, Enum):
    """specDomain: V18875 (C-0-D11527-V13856-V11529-V18875-cpt)"""
    OBSSER='OBSSER'
    OBSCOR='OBSCOR'


class ActClassOrganizer(str, Enum):
    """specDomain: V19443 (C-0-D11527-V13856-V19445-V19443-cpt)"""
    ORGANIZER='ORGANIZER'
    CATEGORY='CATEGORY'
    DOCBODY='DOCBODY'
    DOCSECT='DOCSECT'
    TOPIC='TOPIC'


class ActClassPublicHealthCase(str, Enum):
    """specDomain: V11530 (C-0-D11527-V13856-V11529-V19580-V11530-cpt)"""
    CASE='CASE'
    OUTB='OUTB'


class ActClassROI(str, Enum):
    """abstDomain: V17893 (C-0-D11527-V13856-V11529-V17893-cpt)"""
    ROIBND='ROIBND'
    ROIOVL='ROIOVL'


class ActClassRoot(str, Enum):
    """specDomain: V13856 (C-0-D11527-V13856-cpt)"""
    ACT='ACT'
    ACCM='ACCM'
    ACCT='ACCT'
    ACSN='ACSN'
    ADJUD='ADJUD'
    CONS='CONS'
    CONTREG='CONTREG'
    CTTEVENT='CTTEVENT'
    DISPACT='DISPACT'
    ENC='ENC'
    INC='INC'
    INFRM='INFRM'
    INVE='INVE'
    LIST='LIST'
    MPROT='MPROT'
    PCPR='PCPR'
    PROC='PROC'
    REG='REG'
    REV='REV'
    SBADM='SBADM'
    SPCTRT='SPCTRT'
    SUBST='SUBST'
    TRNS='TRNS'
    VERIF='VERIF'
    XACT='XACT'


class ActClassSupply(str, Enum):
    """specDomain: V11535 (C-0-D11527-V13856-V11535-cpt)"""
    SPLY='SPLY'
    DIET='DIET'


class ActClinicalDocument(str, Enum):
    """specDomain: V13948
    (C-0-D11527-V13856-V19445-V19442-V18938-V13948-cpt)"""
    DOCCLIN='DOCCLIN'
    CDALVLONE='CDALVLONE'


class ActContainer(str, Enum):
    """abstDomain: V19445 (C-0-D11527-V13856-V19445-cpt)"""
    FOLDER='FOLDER'


class ActMoodCompletionTrack(str, Enum):
    """abstDomain: V10197 (C-0-D10196-V10197-cpt)"""
    DEF='DEF'
    EVN='EVN'


class ActMoodIntent(str, Enum):
    """specDomain: V10199 (C-0-D10196-V16742-V10199-cpt)"""
    INT='INT'
    APT='APT'
    ARQ='ARQ'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'
    SLOT='SLOT'


class ActMoodPredicate(str, Enum):
    """abstDomain: V10202 (C-0-D10196-V10202-cpt)"""
    EVNCRT='EVN.CRT'
    GOL='GOL'
    OPT='OPT'
    PERM='PERM'
    PERMRQ='PERMRQ'


class ActRelationshipConditional(str, Enum):
    """abstDomain: V18977 (C-0-D10317-V18977-cpt)"""
    CIND='CIND'
    PRCN='PRCN'
    TRIG='TRIG'


class ActRelationshipCostTracking(str, Enum):
    """abstDomain: V19618 (C-0-D10317-V10329-V14900-V19618-cpt)"""
    CHRG='CHRG'
    COST='COST'


class ActRelationshipExcerpt(str, Enum):
    """specDomain: V18660 (C-0-D10317-V10337-V18660-cpt)"""
    XCRPT='XCRPT'
    VRXCRPT='VRXCRPT'


class ActRelationshipFulfills(str, Enum):
    """specDomain: V10342 (C-0-D10317-V10337-V10342-cpt)"""
    FLFS='FLFS'
    OCCR='OCCR'
    OREF='OREF'
    SCH='SCH'


class ActRelationshipHasComponent(str, Enum):
    """specDomain: V10318 (C-0-D10317-V10318-cpt)"""
    COMP='COMP'
    ARR='ARR'
    CTRLV='CTRLV'
    DEP='DEP'


class ActRelationshipObjective(str, Enum):
    """abstDomain: V19625 (C-0-D10317-V10324-V19625-cpt)"""
    OBJC='OBJC'
    OBJF='OBJF'


class ActRelationshipOutcome(str, Enum):
    """specDomain: V10324 (C-0-D10317-V10324-cpt)"""
    OUTC='OUTC'
    GOAL='GOAL'
    RISK='RISK'


class ActRelationshipPertains(str, Enum):
    """specDomain: V10329 (C-0-D10317-V10329-cpt)"""
    PERT='PERT'
    AUTH='AUTH'
    CAUS='CAUS'
    COVBY='COVBY'
    DRIV='DRIV'
    EXPL='EXPL'
    ITEMSLOC='ITEMSLOC'
    LIMIT='LIMIT'
    MFST='MFST'
    NAME='NAME'
    PREV='PREV'
    REFR='REFR'
    REFV='REFV'
    SUBJ='SUBJ'
    SUMM='SUMM'


class ActRelationshipPosting(str, Enum):
    """abstDomain: V19617 (C-0-D10317-V10329-V14900-V19617-cpt)"""
    CREDIT='CREDIT'
    DEBIT='DEBIT'


class ActRelationshipReason(str, Enum):
    """specDomain: V19376 (C-0-D10317-V18977-V19376-cpt)"""
    RSON='RSON'
    MITGT='MITGT'


class ActRelationshipReplacement(str, Enum):
    """specDomain: V10338 (C-0-D10317-V10337-V10338-cpt)"""
    RPLC='RPLC'
    SUCC='SUCC'


class ActRelationshipSequel(str, Enum):
    """specDomain: V10337 (C-0-D10317-V10337-cpt)"""
    SEQL='SEQL'
    APND='APND'
    DOC='DOC'
    ELNK='ELNK'
    GEN='GEN'
    GEVL='GEVL'
    INST='INST'
    MTCH='MTCH'
    OPTN='OPTN'
    REV='REV'
    UPDT='UPDT'
    XFRM='XFRM'


class AdditionalLocator(str, Enum):
    """specDomain: V10651 (C-0-D10642-V10651-cpt)"""
    ADL='ADL'
    UNID='UNID'
    UNIT='UNIT'


class AddressPartType(str, Enum):
    """vocSet: D10642 (C-0-D10642-cpt)"""
    CAR='CAR'
    CEN='CEN'
    CNT='CNT'
    CPA='CPA'
    CTY='CTY'
    DEL='DEL'
    POB='POB'
    PRE='PRE'
    STA='STA'
    ZIP='ZIP'


class AddressUse(str, Enum):
    """abstDomain: V190 (C-0-D201-V190-cpt)"""
    BAD='BAD'
    TMP='TMP'


class ApplicationMediaType(str, Enum):
    """abstDomain: V14832 (C-0-D14824-V14832-cpt)"""
    APPLICATIONDICOM='application/dicom'
    APPLICATIONMSWORD='application/msword'
    APPLICATIONPDF='application/pdf'


class AskedButUnknown(str, Enum):
    """specDomain: V10614 (C-0-D10609-V10610-V10612-V10614-cpt)"""
    ASKU='ASKU'
    NAV='NAV'


class AudioMediaType(str, Enum):
    """abstDomain: V14835 (C-0-D14824-V14835-cpt)"""
    AUDIOBASIC='audio/basic'
    AUDIOK_32_ADPCM='audio/k32adpcm'
    AUDIOMPEG='audio/mpeg'


class BinaryDataEncoding(str, Enum):
    B_64='B64'
    TXT='TXT'


class BuildingNumber(str, Enum):
    """specDomain: V10649 (C-0-D10642-V14822-V10649-cpt)"""
    BNR='BNR'
    BNN='BNN'
    BNS='BNS'


class CalendarCycleOneLetter(str, Enum):
    """abstDomain: V10701 (C-0-D10684-V10701-cpt)"""
    D='D'
    H='H'
    J='J'
    M='M'
    N='N'
    S='S'
    W='W'
    Y='Y'


class CalendarCycleTwoLetter(str, Enum):
    """abstDomain: V10685 (C-0-D10684-V10685-cpt)"""
    CD='CD'
    CH='CH'
    CM='CM'
    CN='CN'
    CS='CS'
    CW='CW'
    CY='CY'
    DM='DM'
    DW='DW'
    DY='DY'
    HD='HD'
    MY='MY'
    NH='NH'
    SN='SN'
    WY='WY'


class CommunicationFunctionType(str, Enum):
    """vocSet: D16031 (C-0-D16031-cpt)"""
    RCV='RCV'
    RSP='RSP'
    SND='SND'


class CompressionAlgorithm(str, Enum):
    """vocSet: D10620 (C-0-D10620-cpt)"""
    DF='DF'
    GZ='GZ'
    Z='Z'
    ZL='ZL'


class ContextControlAdditive(str, Enum):
    """abstDomain: V18934 (C-0-D16478-V18934-cpt)"""
    AN='AN'
    AP='AP'


class ContextControlNonPropagating(str, Enum):
    """abstDomain: V18937 (C-0-D16478-V18937-cpt)"""
    AN='AN'
    ON='ON'


class ContextControlOverriding(str, Enum):
    """abstDomain: V18935 (C-0-D16478-V18935-cpt)"""
    ON='ON'
    OP='OP'


class ContextControlPropagating(str, Enum):
    """abstDomain: V18936 (C-0-D16478-V18936-cpt)"""
    AP='AP'
    OP='OP'


class Currency(str, Enum):
    """vocSet: D17388 (C-0-D17388-cpt)"""
    ARS='ARS'
    AUD='AUD'
    BRL='BRL'
    CAD='CAD'
    CHF='CHF'
    CLF='CLF'
    CNY='CNY'
    DEM='DEM'
    ESP='ESP'
    EUR='EUR'
    FIM='FIM'
    FRF='FRF'
    GBP='GBP'
    ILS='ILS'
    INR='INR'
    JPY='JPY'
    KRW='KRW'
    MXN='MXN'
    NLG='NLG'
    NZD='NZD'
    PHP='PHP'
    RUR='RUR'
    THB='THB'
    TRL='TRL'
    TWD='TWD'
    USD='USD'
    ZAR='ZAR'


class DeliveryAddressLine(str, Enum):
    """specDomain: V17887 (C-0-D10642-V17887-cpt)"""
    DAL='DAL'
    DINST='DINST'
    DINSTA='DINSTA'
    DINSTQ='DINSTQ'
    DMOD='DMOD'
    DMODID='DMODID'


class EntityClassContainer(str, Enum):
    """specDomain: V11622 (C-0-D10882-V13922-V10883-V13934-V11622-cpt)"""
    CONT='CONT'
    HOLD='HOLD'


class EntityClassDevice(str, Enum):
    """specDomain: V11623 (C-0-D10882-V13922-V10883-V13934-V11623-cpt)"""
    DEV='DEV'
    CER='CER'
    MODDV='MODDV'


class EntityClassLivingSubject(str, Enum):
    """specDomain: V10884 (C-0-D10882-V13922-V10884-cpt)"""
    LIV='LIV'
    PSN='PSN'


class EntityClassManufacturedMaterial(str, Enum):
    """specDomain: V13934 (C-0-D10882-V13922-V10883-V13934-cpt)"""
    MMAT='MMAT'


class EntityClassMaterial(str, Enum):
    """specDomain: V10883 (C-0-D10882-V13922-V10883-cpt)"""
    MAT='MAT'
    CHEM='CHEM'
    FOOD='FOOD'


class EntityClassNonPersonLivingSubject(str, Enum):
    """specDomain: V11621 (C-0-D10882-V13922-V10884-V11621-cpt)"""
    NLIV='NLIV'
    ANM='ANM'
    MIC='MIC'
    PLNT='PLNT'


class EntityClassOrganization(str, Enum):
    """specDomain: V10889 (C-0-D10882-V19463-V10889-cpt)"""
    ORG='ORG'
    PUB='PUB'


class EntityClassPlace(str, Enum):
    """specDomain: V10892 (C-0-D10882-V13922-V10892-cpt)"""
    PLC='PLC'
    CITY='CITY'
    COUNTRY='COUNTRY'
    COUNTY='COUNTY'
    PROVINCE='PROVINCE'


class EntityClassRoot(str, Enum):
    """specDomain: V13922 (C-0-D10882-V13922-cpt)"""
    ENT='ENT'
    HCE='HCE'
    RGRP='RGRP'


class EntityDeterminer(str, Enum):
    """vocSet: D10878 (C-0-D10878-cpt)"""
    INSTANCE='INSTANCE'


class EntityDeterminerDetermined(str, Enum):
    """specDomain: V10879 (C-0-D10878-V10879-cpt)"""
    KIND='KIND'
    QUANTIFIED_KIND='QUANTIFIED_KIND'


class EntityNamePartType(str, Enum):
    """vocSet: D15880 (C-0-D15880-cpt)"""
    DEL='DEL'
    FAM='FAM'
    GIV='GIV'
    PFX='PFX'
    SFX='SFX'


class EntityNameSearchUse(str, Enum):
    """specDomain: V19619 (C-0-D15913-V200-V19619-cpt)"""
    SRCH='SRCH'
    PHON='PHON'
    SNDX='SNDX'


class EntityNameUse(str, Enum):
    """vocSet: D15913 (C-0-D15913-cpt)"""
    C='C'


class HomeAddressUse(str, Enum):
    """specDomain: V10628 (C-0-D201-V190-V10628-cpt)"""
    H='H'
    HP='HP'
    HV='HV'


class ImageMediaType(str, Enum):
    """abstDomain: V14839 (C-0-D14824-V14839-cpt)"""
    IMAGEG_3_FAX='image/g3fax'
    IMAGEGIF='image/gif'
    IMAGEJPEG='image/jpeg'
    IMAGEPNG='image/png'
    IMAGETIFF='image/tiff'


class IntegrityCheckAlgorithm(str, Enum):
    """vocSet: D17385 (C-0-D17385-cpt)"""
    SHA_1='SHA-1'
    SHA_256='SHA-256'


class LicensedEntityRole(str, Enum):
    """specDomain: V16773 (C-0-D11555-V13940-V16930-V16773-cpt)"""
    LIC='LIC'
    NOT='NOT'
    PROV='PROV'


class ModelMediaType(str, Enum):
    """abstDomain: V14848 (C-0-D14824-V14848-cpt)"""
    MODELVRML='model/vrml'


class MultipartMediaType(str, Enum):
    """abstDomain: V14850 (C-0-D14824-V14850-cpt)"""
    MULTIPARTXHL_7CDALEVEL_1='multipart/x-hl7-cda-level1'


class NamePseudonymUse(str, Enum):
    """specDomain: V19591 (C-0-D15913-V200-V19591-cpt)"""
    P='P'
    A='A'


class NameRepresentationUse(str, Enum):
    """abstDomain: V17860 (C-0-D10637-V17860-cpt)"""
    ABC='ABC'
    IDE='IDE'
    SYL='SYL'


class NoInformation(str, Enum):
    """specDomain: V10610 (C-0-D10609-V10610-cpt)"""
    NI='NI'
    MSK='MSK'
    NA='NA'


class NullFlavor(str, Enum):
    """vocSet: D10609 (C-0-D10609-cpt)"""
    NP='NP'


class OrganizationNamePartQualifier(str, Enum):
    """abstDomain: V15889 (C-0-D15888-V15889-cpt)"""
    LS='LS'


class OrganizationNameUse(str, Enum):
    """abstDomain: V15914 (C-0-D15913-V15914-cpt)"""
    C='C'
    L='L'


class Other(str, Enum):
    """specDomain: V10616 (C-0-D10609-V10610-V10616-cpt)"""
    OTH='OTH'
    NINF='NINF'
    PINF='PINF'


class ParticipationAncillary(str, Enum):
    """abstDomain: V10247 (C-0-D10901-V10247-cpt)"""
    ADM='ADM'
    ATND='ATND'
    CALLBCK='CALLBCK'
    CON='CON'
    DIS='DIS'
    ESC='ESC'
    REF='REF'


class ParticipationIndirectTarget(str, Enum):
    """specDomain: V19032 (C-0-D10901-V19032-cpt)"""
    IND='IND'
    BEN='BEN'
    COV='COV'
    HLD='HLD'
    RCT='RCT'
    RCV='RCV'


class ParticipationInformationGenerator(str, Enum):
    """abstDomain: V10251 (C-0-D10901-V10251-cpt)"""
    AUT='AUT'
    ENT='ENT'
    INF='INF'
    WIT='WIT'


class ParticipationInformationRecipient(str, Enum):
    """specDomain: V10263 (C-0-D10901-V10263-cpt)"""
    IRCP='IRCP'
    NOT='NOT'
    PRCP='PRCP'
    REFB='REFB'
    REFT='REFT'
    TRC='TRC'


class ParticipationPhysicalPerformer(str, Enum):
    """specDomain: V10248 (C-0-D10901-V10248-cpt)"""
    PRF='PRF'
    DIST='DIST'
    PPRF='PPRF'
    SPRF='SPRF'


class ParticipationTargetDevice(str, Enum):
    """specDomain: V10298 (C-0-D10901-V10286-V10298-cpt)"""
    DEV='DEV'
    NRD='NRD'
    RDV='RDV'


class ParticipationTargetDirect(str, Enum):
    """specDomain: V10286 (C-0-D10901-V10286-cpt)"""
    DIR='DIR'
    BBY='BBY'
    CSM='CSM'
    DON='DON'
    PRD='PRD'


class ParticipationTargetLocation(str, Enum):
    """specDomain: V10302 (C-0-D10901-V10302-cpt)"""
    LOC='LOC'
    DST='DST'
    ELOC='ELOC'
    ORG='ORG'
    RML='RML'
    VIA='VIA'


class ParticipationTargetSubject(str, Enum):
    """specDomain: V19584 (C-0-D10901-V10286-V19584-cpt)"""
    SBJ='SBJ'
    SPC='SPC'


class ParticipationType(str, Enum):
    """vocSet: D10901 (C-0-D10901-cpt)"""
    CST='CST'
    RESP='RESP'


class ParticipationVerifier(str, Enum):
    """specDomain: V10259 (C-0-D10901-V10259-cpt)"""
    VRF='VRF'
    AUTHEN='AUTHEN'
    LA='LA'


class PersonNamePartAffixTypes(str, Enum):
    """abstDomain: V10666 (C-0-D15888-V10659-V10666-cpt)"""
    AC='AC'
    NB='NB'
    PR='PR'
    VV='VV'


class PersonNamePartChangeQualifier(str, Enum):
    """abstDomain: V10660 (C-0-D15888-V10659-V10660-cpt)"""
    AD='AD'
    BR='BR'
    SP='SP'


class PersonNamePartMiscQualifier(str, Enum):
    """abstDomain: V10671 (C-0-D15888-V10659-V10671-cpt)"""
    CL='CL'


class PersonNamePartQualifier(str, Enum):
    """abstDomain: V10659 (C-0-D15888-V10659-cpt)"""
    IN='IN'
    TITLE='TITLE'


class PersonNameUse(str, Enum):
    """abstDomain: V200 (C-0-D15913-V200-cpt)"""
    A='A'
    ASGN='ASGN'
    C='C'
    I='I'
    L='L'
    R='R'


class PostalAddressUse(str, Enum):
    """vocSet: D10637 (C-0-D10637-cpt)"""
    PHYS='PHYS'
    PST='PST'


class ProbabilityDistributionType(str, Enum):
    """vocSet: D10747 (C-0-D10747-cpt)"""
    B='B'
    E='E'
    F='F'
    G='G'
    LN='LN'
    N='N'
    T='T'
    U='U'
    X_2='X2'


class RelatedLinkType(str, Enum):
    """specDomain: V19615 (C-0-D11603-V19615-cpt)"""
    REL='REL'
    BACKUP='BACKUP'
    DIRAUTH='DIRAUTH'
    INDAUTH='INDAUTH'
    PART='PART'
    REPL='REPL'


class RoleClassAgent(str, Enum):
    """specDomain: V14006
    (C-0-D11555-V13940-V19313-V19316-V10416-V14006-cpt)"""
    AGNT='AGNT'
    GUARD='GUARD'


class RoleClassAssignedEntity(str, Enum):
    """specDomain: V11595
    (C-0-D11555-V13940-V19313-V19316-V10416-V14006-V11595-cpt)"""
    ASSIGNED='ASSIGNED'
    COMPAR='COMPAR'
    SGNOFF='SGNOFF'


class RoleClassContact(str, Enum):
    """specDomain: V12205
    (C-0-D11555-V13940-V19313-V19316-V10416-V14006-V11595-V12205-cpt)"""
    CON='CON'
    ECON='ECON'
    NOK='NOK'


class RoleClassDistributedMaterial(str, Enum):
    """specDomain: V10418 (C-0-D11555-V13940-V19313-V19105-V10418-cpt)"""
    DST='DST'
    RET='RET'


class RoleClassEmployee(str, Enum):
    """specDomain: V11569
    (C-0-D11555-V13940-V19313-V19316-V10416-V11569-cpt)"""
    EMP='EMP'
    MIL='MIL'


class RoleClassInactiveIngredient(str, Enum):
    """specDomain: V19089 (C-0-D11555-V13940-V10429-V10430-V19089-cpt)"""
    IACT='IACT'
    COLR='COLR'
    FLVR='FLVR'
    PRSV='PRSV'
    STBL='STBL'


class RoleClassIngredientEntity(str, Enum):
    """specDomain: V10430 (C-0-D11555-V13940-V10429-V10430-cpt)"""
    INGR='INGR'
    ACTI='ACTI'
    ACTM='ACTM'
    ADTV='ADTV'
    BASE='BASE'


class RoleClassInvestigationSubject(str, Enum):
    """specDomain: V19587
    (C-0-D11555-V13940-V19313-V19316-V10416-V19587-cpt)"""
    INVSBJ='INVSBJ'
    CASESBJ='CASESBJ'
    RESBJ='RESBJ'


class RoleClassIsSpeciesEntity(str, Enum):
    """specDomain: V10441 (C-0-D11555-V13940-V10428-V10441-cpt)"""
    GEN='GEN'
    GRIC='GRIC'


class RoleClassLocatedEntity(str, Enum):
    """specDomain: V16815 (C-0-D11555-V13940-V10429-V16815-cpt)"""
    LOCE='LOCE'
    STOR='STOR'


class RoleClassManufacturedProduct(str, Enum):
    """specDomain: V11580 (C-0-D11555-V13940-V19313-V19105-V11580-cpt)"""
    MANU='MANU'
    THER='THER'


class RoleClassMutualRelationship(str, Enum):
    """abstDomain: V19316 (C-0-D11555-V13940-V19313-V19316-cpt)"""
    CAREGIVER='CAREGIVER'
    PRS='PRS'


class RoleClassOntological(str, Enum):
    """abstDomain: V10428 (C-0-D11555-V13940-V10428-cpt)"""
    INST='INST'
    SUBS='SUBS'
    SUBY='SUBY'


class RoleClassPartitive(str, Enum):
    """abstDomain: V10429 (C-0-D11555-V13940-V10429-cpt)"""
    CONT='CONT'
    MBR='MBR'
    PART='PART'


class RoleClassPassive(str, Enum):
    """abstDomain: V19105 (C-0-D11555-V13940-V19313-V19105-cpt)"""
    ACCESS='ACCESS'
    BIRTHPL='BIRTHPL'
    EXPR='EXPR'
    HLD='HLD'
    HLTHCHRT='HLTHCHRT'
    IDENT='IDENT'
    MNT='MNT'
    OWN='OWN'
    RGPR='RGPR'
    TERR='TERR'
    WRTE='WRTE'


class RoleClassRelationshipFormal(str, Enum):
    """abstDomain: V10416 (C-0-D11555-V13940-V19313-V19316-V10416-cpt)"""
    CIT='CIT'
    COVPTY='COVPTY'
    CRINV='CRINV'
    CRSPNSR='CRSPNSR'
    GUAR='GUAR'
    PAT='PAT'
    PAYEE='PAYEE'
    PAYOR='PAYOR'
    POLHOLD='POLHOLD'
    QUAL='QUAL'
    SPNSR='SPNSR'
    STD='STD'
    UNDWRT='UNDWRT'


class RoleClassRoot(str, Enum):
    """specDomain: V13940 (C-0-D11555-V13940-cpt)"""
    ROL='ROL'


class RoleClassServiceDeliveryLocation(str, Enum):
    """specDomain: V16927 (C-0-D11555-V13940-V19313-V19105-V16927-cpt)"""
    SDLOC='SDLOC'
    DSDLOC='DSDLOC'
    ISDLOC='ISDLOC'


class RoleClassSpecimen(str, Enum):
    """specDomain: V11591 (C-0-D11555-V13940-V10429-V11591-cpt)"""
    SPEC='SPEC'
    ALQT='ALQT'
    ISLT='ISLT'


class SetOperator(str, Enum):
    """vocSet: D17416 (C-0-D17416-cpt)"""
    A='A'
    E='E'
    H='H'
    I='I'
    P='P'


class State(str, Enum):
    """specDomain: V19455 (C-0-D10882-V19463-V10889-V19455-cpt)"""
    STATE='STATE'
    NAT='NAT'


class StreetAddressLine(str, Enum):
    """specDomain: V14822 (C-0-D10642-V14822-cpt)"""
    SAL='SAL'
    DIR='DIR'


class StreetName(str, Enum):
    """specDomain: V10648 (C-0-D10642-V14822-V10648-cpt)"""
    STR='STR'
    STB='STB'
    STTYP='STTYP'


class TelecommunicationAddressUse(str, Enum):
    """vocSet: D201 (C-0-D201-cpt)"""
    AS='AS'
    EC='EC'
    MC='MC'
    PG='PG'


class TemporallyPertains(str, Enum):
    """abstDomain: V19590 (C-0-D10317-V10329-V19590-cpt)"""
    SAS='SAS'


class TextMediaType(str, Enum):
    """abstDomain: V14825 (C-0-D14824-V14825-cpt)"""
    TEXTHTML='text/html'
    TEXTPLAIN='text/plain'
    TEXTRTF='text/rtf'
    TEXTSGML='text/sgml'
    TEXTXHL_7FT='text/x-hl7-ft'
    TEXTXML='text/xml'


class TimingEvent(str, Enum):
    """vocSet: D10706 (C-0-D10706-cpt)"""
    AC='AC'
    ACD='ACD'
    ACM='ACM'
    ACV='ACV'
    HS='HS'
    IC='IC'
    ICD='ICD'
    ICM='ICM'
    ICV='ICV'
    PC='PC'
    PCD='PCD'
    PCM='PCM'
    PCV='PCV'


class URLScheme(str, Enum):
    """vocSet: D14866 (C-0-D14866-cpt)"""
    FAX='fax'
    FILE='file'
    FTP='ftp'
    HTTP='http'
    MAILTO='mailto'
    MLLP='mllp'
    MODEM='modem'
    NFS='nfs'
    TEL='tel'
    TELNET='telnet'


class Unknown(str, Enum):
    """specDomain: V10612 (C-0-D10609-V10610-V10612-cpt)"""
    UNK='UNK'
    NASK='NASK'
    TRC='TRC'


class VideoMediaType(str, Enum):
    """abstDomain: V14845 (C-0-D14824-V14845-cpt)"""
    VIDEOMPEG='video/mpeg'
    VIDEOXAVI='video/x-avi'


class WorkPlaceAddressUse(str, Enum):
    """specDomain: V19613 (C-0-D201-V190-V19613-cpt)"""
    WP='WP'
    DIR='DIR'
    PUB='PUB'


class alignType(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType1(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType10(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType12(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType14(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType3(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType5(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class alignType7(str, Enum):
    LEFT='left'
    CENTER='center'
    RIGHT='right'
    JUSTIFY='justify'
    CHAR='char'


class frameType(str, Enum):
    VOID='void'
    ABOVE='above'
    BELOW='below'
    HSIDES='hsides'
    LHS='lhs'
    RHS='rhs'
    VSIDES='vsides'
    BOX='box'
    BORDER='border'


class hasSupport(str, Enum):
    """specDomain: V10330 (C-0-D10317-V10329-V10330-cpt)"""
    SPRT='SPRT'
    SPRTBND='SPRTBND'


class listTypeType(str, Enum):
    ORDERED='ordered'
    UNORDERED='unordered'


class revisedType(str, Enum):
    INSERT='insert'
    DELETE='delete'


class rulesType(str, Enum):
    NONE='none'
    GROUPS='groups'
    ROWS='rows'
    COLS='cols'
    ALL='all'


class scopeType(str, Enum):
    ROW='row'
    COL='col'
    ROWGROUP='rowgroup'
    COLGROUP='colgroup'


class scopeType9(str, Enum):
    ROW='row'
    COL='col'
    ROWGROUP='rowgroup'
    COLGROUP='colgroup'


class valignType(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType11(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType13(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType15(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType2(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType4(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType6(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class valignType8(str, Enum):
    TOP='top'
    MIDDLE='middle'
    BOTTOM='bottom'
    BASELINE='baseline'


class x_ActClassDocumentEntryAct(str, Enum):
    """abstDomain: V19604 (C-0-D11527-V13856-V19604-cpt)"""
    ACT='ACT'
    ACCM='ACCM'
    CONS='CONS'
    CTTEVENT='CTTEVENT'
    INC='INC'
    INFRM='INFRM'
    PCPR='PCPR'
    REG='REG'
    SPCTRT='SPCTRT'


class x_ActClassDocumentEntryOrganizer(str, Enum):
    """abstDomain: V19603 (C-0-D11527-V13856-V19603-cpt)"""
    BATTERY='BATTERY'
    CLUSTER='CLUSTER'


class x_ActMoodDefEvn(str, Enum):
    """abstDomain: V19375 (C-0-D10196-V19375-cpt)"""
    DEF='DEF'
    EVN='EVN'


class x_ActMoodDefEvnRqoPrmsPrp(str, Enum):
    """abstDomain: V19371 (C-0-D10196-V19371-cpt)"""
    DEF='DEF'
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_ActMoodDocumentObservation(str, Enum):
    """abstDomain: V18943 (C-0-D10196-V18943-cpt)"""
    INT='INT'
    DEF='DEF'
    EVN='EVN'
    GOL='GOL'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_ActMoodEvnOrdPrmsPrp(str, Enum):
    """abstDomain: V18965 (C-0-D10196-V18965-cpt)"""
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_ActMoodIntentEvent(str, Enum):
    """abstDomain: V16742 (C-0-D10196-V16742-cpt)"""
    EVN='EVN'


class x_ActMoodOrdPrms(str, Enum):
    """abstDomain: V16735 (C-0-D10196-V16735-cpt)"""
    PRMS='PRMS'
    RQO='RQO'


class x_ActMoodOrdPrmsEvn(str, Enum):
    """abstDomain: V16730 (C-0-D10196-V16730-cpt)"""
    EVN='EVN'
    PRMS='PRMS'
    RQO='RQO'


class x_ActMoodRqoPrpAptArq(str, Enum):
    """abstDomain: V19372 (C-0-D10196-V19372-cpt)"""
    APT='APT'
    ARQ='ARQ'
    PRP='PRP'
    RQO='RQO'


class x_ActRelationshipDocument(str, Enum):
    """abstDomain: V11610 (C-0-D10317-V11610-cpt)"""
    RPLC='RPLC'
    APND='APND'
    XFRM='XFRM'


class x_ActRelationshipEntry(str, Enum):
    """abstDomain: V19446 (C-0-D10317-V19446-cpt)"""
    COMP='COMP'
    DRIV='DRIV'


class x_ActRelationshipEntryRelationship(str, Enum):
    """abstDomain: V19447 (C-0-D10317-V19447-cpt)"""
    XCRPT='XCRPT'
    COMP='COMP'
    RSON='RSON'
    SPRT='SPRT'
    CAUS='CAUS'
    GEVL='GEVL'
    MFST='MFST'
    REFR='REFR'
    SAS='SAS'
    SUBJ='SUBJ'


class x_ActRelationshipExternalReference(str, Enum):
    """abstDomain: V19000 (C-0-D10317-V19000-cpt)"""
    XCRPT='XCRPT'
    RPLC='RPLC'
    SPRT='SPRT'
    ELNK='ELNK'
    REFR='REFR'
    SUBJ='SUBJ'


class x_ActRelationshipPatientTransport(str, Enum):
    """abstDomain: V19005 (C-0-D10317-V19005-cpt)"""
    ARR='ARR'
    DEP='DEP'


class x_ActRelationshipPertinentInfo(str, Enum):
    """abstDomain: V19562 (C-0-D10317-V19562-cpt)"""
    SPRT='SPRT'
    CAUS='CAUS'
    MFST='MFST'
    REFR='REFR'
    SUBJ='SUBJ'


class x_DeterminerInstanceKind(str, Enum):
    """abstDomain: V19647 (C-0-D10878-V19647-cpt)"""
    KIND='KIND'
    INSTANCE='INSTANCE'


class x_DocumentActMood(str, Enum):
    """abstDomain: V19458 (C-0-D10196-V19458-cpt)"""
    INT='INT'
    APT='APT'
    ARQ='ARQ'
    DEF='DEF'
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_DocumentEncounterMood(str, Enum):
    """abstDomain: V19459 (C-0-D10196-V19459-cpt)"""
    INT='INT'
    APT='APT'
    ARQ='ARQ'
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_DocumentEntrySubject(str, Enum):
    """abstDomain: V19367 (C-0-D11555-V13940-V19367-cpt)"""
    SPEC='SPEC'
    PAT='PAT'
    PRS='PRS'


class x_DocumentProcedureMood(str, Enum):
    """abstDomain: V19460 (C-0-D10196-V19460-cpt)"""
    INT='INT'
    APT='APT'
    ARQ='ARQ'
    DEF='DEF'
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_DocumentSubject(str, Enum):
    """abstDomain: V19368 (C-0-D11555-V13940-V19368-cpt)"""
    PAT='PAT'
    PRS='PRS'


class x_DocumentSubstanceMood(str, Enum):
    """abstDomain: V19461 (C-0-D10196-V19461-cpt)"""
    INT='INT'
    EVN='EVN'
    PRMS='PRMS'
    PRP='PRP'
    RQO='RQO'


class x_EncounterParticipant(str, Enum):
    """abstDomain: V19605 (C-0-D10901-V19605-cpt)"""
    ADM='ADM'
    ATND='ATND'
    CON='CON'
    DIS='DIS'
    REF='REF'


class x_EncounterPerformerParticipation(str, Enum):
    """abstDomain: V16764 (C-0-D10901-V16764-cpt)"""
    PRF='PRF'
    CON='CON'
    SPRF='SPRF'


class x_EntityClassDocumentReceiving(str, Enum):
    """abstDomain: V19462 (C-0-D10882-V19462-cpt)"""
    HCE='HCE'
    PSN='PSN'


class x_EntityClassPersonOrOrgReceiving(str, Enum):
    """abstDomain: V19463 (C-0-D10882-V19463-cpt)"""
    PSN='PSN'


class x_InformationRecipient(str, Enum):
    """abstDomain: V19366 (C-0-D10901-V19366-cpt)"""
    PRCP='PRCP'
    TRC='TRC'


class x_InformationRecipientRole(str, Enum):
    """abstDomain: V16772 (C-0-D11555-V13940-V16772-cpt)"""
    ASSIGNED='ASSIGNED'
    HLTHCHRT='HLTHCHRT'


class x_OrganizationNamePartType(str, Enum):
    """abstDomain: V15881 (C-0-D15880-V15881-cpt)"""
    DEL='DEL'
    PFX='PFX'
    SFX='SFX'


class x_ParticipationAuthorPerformer(str, Enum):
    """abstDomain: V19080 (C-0-D10901-V19080-cpt)"""
    PRF='PRF'
    AUT='AUT'


class x_ParticipationEntVrf(str, Enum):
    """abstDomain: V19600 (C-0-D10901-V19600-cpt)"""
    VRF='VRF'
    ENT='ENT'


class x_ParticipationPrfEntVrf(str, Enum):
    """abstDomain: V19601 (C-0-D10901-V19601-cpt)"""
    PRF='PRF'
    VRF='VRF'
    ENT='ENT'


class x_ParticipationVrfRespSprfWit(str, Enum):
    """abstDomain: V19083 (C-0-D10901-V19083-cpt)"""
    VRF='VRF'
    RESP='RESP'
    SPRF='SPRF'
    WIT='WIT'


class x_PersonNamePartType(str, Enum):
    """abstDomain: V10653 (C-0-D15880-V10653-cpt)"""
    DEL='DEL'
    FAM='FAM'
    GIV='GIV'
    PFX='PFX'
    SFX='SFX'


class x_RoleClassAccommodationRequestor(str, Enum):
    """abstDomain: V19382 (C-0-D11555-V13940-V19382-cpt)"""
    AGNT='AGNT'
    PAT='PAT'
    PROV='PROV'
    PRS='PRS'


class x_RoleClassCoverage(str, Enum):
    """abstDomain: V14008 (C-0-D11555-V13940-V14008-cpt)"""
    COVPTY='COVPTY'
    POLHOLD='POLHOLD'
    SPNSR='SPNSR'
    UNDWRT='UNDWRT'


class x_RoleClassCoverageInvoice(str, Enum):
    """abstDomain: V14013 (C-0-D11555-V13940-V14013-cpt)"""
    PAYEE='PAYEE'
    PAYOR='PAYOR'


class x_RoleClassCredentialedEntity(str, Enum):
    """abstDomain: V16930 (C-0-D11555-V13940-V16930-cpt)"""
    ASSIGNED='ASSIGNED'
    QUAL='QUAL'


class x_RoleClassPayeePolicyRelationship(str, Enum):
    """abstDomain: V19395 (C-0-D11555-V13940-V19395-cpt)"""
    COVPTY='COVPTY'
    GUAR='GUAR'
    POLHOLD='POLHOLD'
    PROV='PROV'
    PRS='PRS'


class x_ServiceEventPerformer(str, Enum):
    """abstDomain: V19606 (C-0-D10901-V19606-cpt)"""
    PRF='PRF'
    PPRF='PPRF'
    SPRF='SPRF'


class POCD_MT000040_Act(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode=None, moodCode=None, negationInd=None, realmCode=None, typeId=None, templateId=None, id=None, code=None, text=None, statusCode=None, effectiveTime=None, priorityCode=None, languageCode=None, subject=None, specimen=None, performer=None, author=None, informant=None, participant=None, entryRelationship=None, reference=None, precondition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Act)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Act.subclass:
            return POCD_MT000040_Act.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Act(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ActClassDocumentEntryAct(self, value):
        # Validate type x_ActClassDocumentEntryAct, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ACT', 'ACCM', 'CONS', 'CTTEVENT', 'INC', 'INFRM', 'PCPR', 'REG', 'SPCTRT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActClassDocumentEntryAct' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActClassDocumentEntryAct_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActClassDocumentEntryAct_patterns_, ))
    validate_x_ActClassDocumentEntryAct_patterns_ = [['^([^\\s]+)$']]
    def validate_x_DocumentActMood(self, value):
        # Validate type x_DocumentActMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INT', 'APT', 'ARQ', 'DEF', 'EVN', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentActMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentActMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentActMood_patterns_, ))
    validate_x_DocumentActMood_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.priorityCode is not None or
            self.languageCode is not None or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Act', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Act')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Act':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Act')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Act', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Act'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Act', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_x_ActClassDocumentEntryAct(self.classCode)    # validate type x_ActClassDocumentEntryAct
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentActMood(self.moodCode)    # validate type x_DocumentActMood
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040_Act


class POCD_MT000040_AssignedAuthor(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='ASSIGNED', realmCode=None, typeId=None, templateId=None, id=None, code=None, addr=None, telecom=None, assignedPerson=None, assignedAuthoringDevice=None, representedOrganization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.assignedPerson = assignedPerson
        self.assignedPerson_nsprefix_ = None
        self.assignedAuthoringDevice = assignedAuthoringDevice
        self.assignedAuthoringDevice_nsprefix_ = None
        self.representedOrganization = representedOrganization
        self.representedOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_AssignedAuthor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_AssignedAuthor.subclass:
            return POCD_MT000040_AssignedAuthor.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_AssignedAuthor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_assignedPerson(self):
        return self.assignedPerson
    def set_assignedPerson(self, assignedPerson):
        self.assignedPerson = assignedPerson
    def get_assignedAuthoringDevice(self):
        return self.assignedAuthoringDevice
    def set_assignedAuthoringDevice(self, assignedAuthoringDevice):
        self.assignedAuthoringDevice = assignedAuthoringDevice
    def get_representedOrganization(self):
        return self.representedOrganization
    def set_representedOrganization(self, representedOrganization):
        self.representedOrganization = representedOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassAssignedEntity(self, value):
        # Validate type RoleClassAssignedEntity, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.assignedPerson is not None or
            self.assignedAuthoringDevice is not None or
            self.representedOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssignedAuthor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.AssignedAuthor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.AssignedAuthor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.AssignedAuthor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.AssignedAuthor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.AssignedAuthor'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ASSIGNED" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssignedAuthor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.assignedPerson is not None:
            namespaceprefix_ = self.assignedPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedPerson_nsprefix_) else ''
            self.assignedPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedPerson', pretty_print=pretty_print)
        if self.assignedAuthoringDevice is not None:
            namespaceprefix_ = self.assignedAuthoringDevice_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedAuthoringDevice_nsprefix_) else ''
            self.assignedAuthoringDevice.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedAuthoringDevice', pretty_print=pretty_print)
        if self.representedOrganization is not None:
            namespaceprefix_ = self.representedOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.representedOrganization_nsprefix_) else ''
            self.representedOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='representedOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassAssignedEntity(self.classCode)    # validate type RoleClassAssignedEntity
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'assignedPerson':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedPerson = obj_
            obj_.original_tagname_ = 'assignedPerson'
        elif nodeName_ == 'assignedAuthoringDevice':
            obj_ = POCD_MT000040_AuthoringDevice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedAuthoringDevice = obj_
            obj_.original_tagname_ = 'assignedAuthoringDevice'
        elif nodeName_ == 'representedOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.representedOrganization = obj_
            obj_.original_tagname_ = 'representedOrganization'
# end class POCD_MT000040_AssignedAuthor


class POCD_MT000040_AssignedCustodian(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='ASSIGNED', realmCode=None, typeId=None, templateId=None, representedCustodianOrganization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.representedCustodianOrganization = representedCustodianOrganization
        self.representedCustodianOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_AssignedCustodian)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_AssignedCustodian.subclass:
            return POCD_MT000040_AssignedCustodian.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_AssignedCustodian(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_representedCustodianOrganization(self):
        return self.representedCustodianOrganization
    def set_representedCustodianOrganization(self, representedCustodianOrganization):
        self.representedCustodianOrganization = representedCustodianOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassAssignedEntity(self, value):
        # Validate type RoleClassAssignedEntity, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.representedCustodianOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssignedCustodian', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.AssignedCustodian')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.AssignedCustodian':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.AssignedCustodian')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.AssignedCustodian', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.AssignedCustodian'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ASSIGNED" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssignedCustodian', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.representedCustodianOrganization is not None:
            namespaceprefix_ = self.representedCustodianOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.representedCustodianOrganization_nsprefix_) else ''
            self.representedCustodianOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='representedCustodianOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassAssignedEntity(self.classCode)    # validate type RoleClassAssignedEntity
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'representedCustodianOrganization':
            obj_ = POCD_MT000040_CustodianOrganization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.representedCustodianOrganization = obj_
            obj_.original_tagname_ = 'representedCustodianOrganization'
# end class POCD_MT000040_AssignedCustodian


class POCD_MT000040_AssignedEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='ASSIGNED', realmCode=None, typeId=None, templateId=None, id=None, code=None, addr=None, telecom=None, assignedPerson=None, representedOrganization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.assignedPerson = assignedPerson
        self.assignedPerson_nsprefix_ = None
        self.representedOrganization = representedOrganization
        self.representedOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_AssignedEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_AssignedEntity.subclass:
            return POCD_MT000040_AssignedEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_AssignedEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_assignedPerson(self):
        return self.assignedPerson
    def set_assignedPerson(self, assignedPerson):
        self.assignedPerson = assignedPerson
    def get_representedOrganization(self):
        return self.representedOrganization
    def set_representedOrganization(self, representedOrganization):
        self.representedOrganization = representedOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassAssignedEntity(self, value):
        # Validate type RoleClassAssignedEntity, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.assignedPerson is not None or
            self.representedOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssignedEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.AssignedEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.AssignedEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.AssignedEntity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.AssignedEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.AssignedEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ASSIGNED" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssignedEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.assignedPerson is not None:
            namespaceprefix_ = self.assignedPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedPerson_nsprefix_) else ''
            self.assignedPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedPerson', pretty_print=pretty_print)
        if self.representedOrganization is not None:
            namespaceprefix_ = self.representedOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.representedOrganization_nsprefix_) else ''
            self.representedOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='representedOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassAssignedEntity(self.classCode)    # validate type RoleClassAssignedEntity
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'assignedPerson':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedPerson = obj_
            obj_.original_tagname_ = 'assignedPerson'
        elif nodeName_ == 'representedOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.representedOrganization = obj_
            obj_.original_tagname_ = 'representedOrganization'
# end class POCD_MT000040_AssignedEntity


class POCD_MT000040_AssociatedEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode=None, realmCode=None, typeId=None, templateId=None, id=None, code=None, addr=None, telecom=None, associatedPerson=None, scopingOrganization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.associatedPerson = associatedPerson
        self.associatedPerson_nsprefix_ = None
        self.scopingOrganization = scopingOrganization
        self.scopingOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_AssociatedEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_AssociatedEntity.subclass:
            return POCD_MT000040_AssociatedEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_AssociatedEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_associatedPerson(self):
        return self.associatedPerson
    def set_associatedPerson(self, associatedPerson):
        self.associatedPerson = associatedPerson
    def get_scopingOrganization(self):
        return self.scopingOrganization
    def set_scopingOrganization(self, scopingOrganization):
        self.scopingOrganization = scopingOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassAssociative(self, value):
        # Validate type RoleClassAssociative, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.associatedPerson is not None or
            self.scopingOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssociatedEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.AssociatedEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.AssociatedEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.AssociatedEntity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.AssociatedEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.AssociatedEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AssociatedEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.associatedPerson is not None:
            namespaceprefix_ = self.associatedPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.associatedPerson_nsprefix_) else ''
            self.associatedPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='associatedPerson', pretty_print=pretty_print)
        if self.scopingOrganization is not None:
            namespaceprefix_ = self.scopingOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.scopingOrganization_nsprefix_) else ''
            self.scopingOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scopingOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassAssociative(self.classCode)    # validate type RoleClassAssociative
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'associatedPerson':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.associatedPerson = obj_
            obj_.original_tagname_ = 'associatedPerson'
        elif nodeName_ == 'scopingOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scopingOrganization = obj_
            obj_.original_tagname_ = 'scopingOrganization'
# end class POCD_MT000040_AssociatedEntity


class POCD_MT000040_Authenticator(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='AUTHEN', realmCode=None, typeId=None, templateId=None, time=None, signatureCode=None, assignedEntity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.signatureCode = signatureCode
        self.signatureCode_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Authenticator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Authenticator.subclass:
            return POCD_MT000040_Authenticator.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Authenticator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_signatureCode(self):
        return self.signatureCode
    def set_signatureCode(self, signatureCode):
        self.signatureCode = signatureCode
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.signatureCode is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Authenticator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Authenticator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Authenticator':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Authenticator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Authenticator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Authenticator'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "AUTHEN" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Authenticator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.signatureCode is not None:
            namespaceprefix_ = self.signatureCode_nsprefix_ + ':' if (UseCapturedNS_ and self.signatureCode_nsprefix_) else ''
            self.signatureCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signatureCode', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'signatureCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signatureCode = obj_
            obj_.original_tagname_ = 'signatureCode'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_Authenticator


class POCD_MT000040_Author(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='AUT', contextControlCode='OP', realmCode=None, typeId=None, templateId=None, functionCode=None, time=None, assignedAuthor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.assignedAuthor = assignedAuthor
        self.assignedAuthor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Author)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Author.subclass:
            return POCD_MT000040_Author.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Author(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_assignedAuthor(self):
        return self.assignedAuthor
    def set_assignedAuthor(self, assignedAuthor):
        self.assignedAuthor = assignedAuthor
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.functionCode is not None or
            self.time is not None or
            self.assignedAuthor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Author', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Author')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Author':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Author')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Author', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Author'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "AUT" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Author', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.assignedAuthor is not None:
            namespaceprefix_ = self.assignedAuthor_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedAuthor_nsprefix_) else ''
            self.assignedAuthor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedAuthor', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'time':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'assignedAuthor':
            obj_ = POCD_MT000040_AssignedAuthor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedAuthor = obj_
            obj_.original_tagname_ = 'assignedAuthor'
# end class POCD_MT000040_Author


class POCD_MT000040_AuthoringDevice(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='DEV', determinerCode='INSTANCE', realmCode=None, typeId=None, templateId=None, code=None, manufacturerModelName=None, softwareName=None, asMaintainedEntity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.manufacturerModelName = manufacturerModelName
        self.manufacturerModelName_nsprefix_ = None
        self.softwareName = softwareName
        self.softwareName_nsprefix_ = None
        if asMaintainedEntity is None:
            self.asMaintainedEntity = []
        else:
            self.asMaintainedEntity = asMaintainedEntity
        self.asMaintainedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_AuthoringDevice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_AuthoringDevice.subclass:
            return POCD_MT000040_AuthoringDevice.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_AuthoringDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_manufacturerModelName(self):
        return self.manufacturerModelName
    def set_manufacturerModelName(self, manufacturerModelName):
        self.manufacturerModelName = manufacturerModelName
    def get_softwareName(self):
        return self.softwareName
    def set_softwareName(self, softwareName):
        self.softwareName = softwareName
    def get_asMaintainedEntity(self):
        return self.asMaintainedEntity
    def set_asMaintainedEntity(self, asMaintainedEntity):
        self.asMaintainedEntity = asMaintainedEntity
    def add_asMaintainedEntity(self, value):
        self.asMaintainedEntity.append(value)
    def insert_asMaintainedEntity_at(self, index, value):
        self.asMaintainedEntity.insert(index, value)
    def replace_asMaintainedEntity_at(self, index, value):
        self.asMaintainedEntity[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassDevice(self, value):
        # Validate type EntityClassDevice, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEV', 'CER', 'MODDV']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClassDevice' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClassDevice_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClassDevice_patterns_, ))
    validate_EntityClassDevice_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.manufacturerModelName is not None or
            self.softwareName is not None or
            self.asMaintainedEntity
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AuthoringDevice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.AuthoringDevice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.AuthoringDevice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.AuthoringDevice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.AuthoringDevice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.AuthoringDevice'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DEV" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.AuthoringDevice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.manufacturerModelName is not None:
            namespaceprefix_ = self.manufacturerModelName_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturerModelName_nsprefix_) else ''
            self.manufacturerModelName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturerModelName', pretty_print=pretty_print)
        if self.softwareName is not None:
            namespaceprefix_ = self.softwareName_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareName_nsprefix_) else ''
            self.softwareName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='softwareName', pretty_print=pretty_print)
        for asMaintainedEntity_ in self.asMaintainedEntity:
            namespaceprefix_ = self.asMaintainedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.asMaintainedEntity_nsprefix_) else ''
            asMaintainedEntity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asMaintainedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassDevice(self.classCode)    # validate type EntityClassDevice
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'manufacturerModelName':
            obj_ = SC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturerModelName = obj_
            obj_.original_tagname_ = 'manufacturerModelName'
        elif nodeName_ == 'softwareName':
            obj_ = SC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.softwareName = obj_
            obj_.original_tagname_ = 'softwareName'
        elif nodeName_ == 'asMaintainedEntity':
            obj_ = POCD_MT000040_MaintainedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asMaintainedEntity.append(obj_)
            obj_.original_tagname_ = 'asMaintainedEntity'
# end class POCD_MT000040_AuthoringDevice


class POCD_MT000040_Authorization(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='AUTH', realmCode=None, typeId=None, templateId=None, consent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.consent = consent
        self.consent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Authorization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Authorization.subclass:
            return POCD_MT000040_Authorization.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Authorization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_consent(self):
        return self.consent
    def set_consent(self, consent):
        self.consent = consent
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.consent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Authorization', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Authorization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Authorization':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Authorization')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Authorization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Authorization'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "AUTH" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Authorization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.consent is not None:
            namespaceprefix_ = self.consent_nsprefix_ + ':' if (UseCapturedNS_ and self.consent_nsprefix_) else ''
            self.consent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='consent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'consent':
            obj_ = POCD_MT000040_Consent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.consent = obj_
            obj_.original_tagname_ = 'consent'
# end class POCD_MT000040_Authorization


class POCD_MT000040_Birthplace(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='BIRTHPL', realmCode=None, typeId=None, templateId=None, place=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.place = place
        self.place_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Birthplace)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Birthplace.subclass:
            return POCD_MT000040_Birthplace.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Birthplace(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_place(self):
        return self.place
    def set_place(self, place):
        self.place = place
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.place is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Birthplace', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Birthplace')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Birthplace':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Birthplace')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Birthplace', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Birthplace'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "BIRTHPL" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Birthplace', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.place is not None:
            namespaceprefix_ = self.place_nsprefix_ + ':' if (UseCapturedNS_ and self.place_nsprefix_) else ''
            self.place.export(outfile, level, namespaceprefix_, namespacedef_='', name_='place', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'place':
            obj_ = POCD_MT000040_Place.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.place = obj_
            obj_.original_tagname_ = 'place'
# end class POCD_MT000040_Birthplace


class POCD_MT000040_ClinicalDocument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='DOCCLIN', moodCode='EVN', realmCode=None, typeId=None, templateId=None, id=None, code=None, title=None, effectiveTime=None, confidentialityCode=None, languageCode=None, setId=None, versionNumber=None, copyTime=None, recordTarget=None, author=None, dataEnterer=None, informant=None, custodian=None, informationRecipient=None, legalAuthenticator=None, authenticator=None, participant=None, inFulfillmentOf=None, documentationOf=None, relatedDocument=None, authorization=None, componentOf=None, localHeader=None, component=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.setId = setId
        self.setId_nsprefix_ = None
        self.versionNumber = versionNumber
        self.versionNumber_nsprefix_ = None
        self.copyTime = copyTime
        self.copyTime_nsprefix_ = None
        if recordTarget is None:
            self.recordTarget = []
        else:
            self.recordTarget = recordTarget
        self.recordTarget_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        self.dataEnterer = dataEnterer
        self.dataEnterer_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        self.custodian = custodian
        self.custodian_nsprefix_ = None
        if informationRecipient is None:
            self.informationRecipient = []
        else:
            self.informationRecipient = informationRecipient
        self.informationRecipient_nsprefix_ = None
        self.legalAuthenticator = legalAuthenticator
        self.legalAuthenticator_nsprefix_ = None
        if authenticator is None:
            self.authenticator = []
        else:
            self.authenticator = authenticator
        self.authenticator_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if inFulfillmentOf is None:
            self.inFulfillmentOf = []
        else:
            self.inFulfillmentOf = inFulfillmentOf
        self.inFulfillmentOf_nsprefix_ = None
        if documentationOf is None:
            self.documentationOf = []
        else:
            self.documentationOf = documentationOf
        self.documentationOf_nsprefix_ = None
        if relatedDocument is None:
            self.relatedDocument = []
        else:
            self.relatedDocument = relatedDocument
        self.relatedDocument_nsprefix_ = None
        if authorization is None:
            self.authorization = []
        else:
            self.authorization = authorization
        self.authorization_nsprefix_ = None
        self.componentOf = componentOf
        self.componentOf_nsprefix_ = None
        self.localHeader = localHeader
        self.localHeader_nsprefix_ = None
        self.component = component
        self.component_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ClinicalDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ClinicalDocument.subclass:
            return POCD_MT000040_ClinicalDocument.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ClinicalDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_setId(self):
        return self.setId
    def set_setId(self, setId):
        self.setId = setId
    def get_versionNumber(self):
        return self.versionNumber
    def set_versionNumber(self, versionNumber):
        self.versionNumber = versionNumber
    def get_copyTime(self):
        return self.copyTime
    def set_copyTime(self, copyTime):
        self.copyTime = copyTime
    def get_recordTarget(self):
        return self.recordTarget
    def set_recordTarget(self, recordTarget):
        self.recordTarget = recordTarget
    def add_recordTarget(self, value):
        self.recordTarget.append(value)
    def insert_recordTarget_at(self, index, value):
        self.recordTarget.insert(index, value)
    def replace_recordTarget_at(self, index, value):
        self.recordTarget[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_dataEnterer(self):
        return self.dataEnterer
    def set_dataEnterer(self, dataEnterer):
        self.dataEnterer = dataEnterer
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_custodian(self):
        return self.custodian
    def set_custodian(self, custodian):
        self.custodian = custodian
    def get_informationRecipient(self):
        return self.informationRecipient
    def set_informationRecipient(self, informationRecipient):
        self.informationRecipient = informationRecipient
    def add_informationRecipient(self, value):
        self.informationRecipient.append(value)
    def insert_informationRecipient_at(self, index, value):
        self.informationRecipient.insert(index, value)
    def replace_informationRecipient_at(self, index, value):
        self.informationRecipient[index] = value
    def get_legalAuthenticator(self):
        return self.legalAuthenticator
    def set_legalAuthenticator(self, legalAuthenticator):
        self.legalAuthenticator = legalAuthenticator
    def get_authenticator(self):
        return self.authenticator
    def set_authenticator(self, authenticator):
        self.authenticator = authenticator
    def add_authenticator(self, value):
        self.authenticator.append(value)
    def insert_authenticator_at(self, index, value):
        self.authenticator.insert(index, value)
    def replace_authenticator_at(self, index, value):
        self.authenticator[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_inFulfillmentOf(self):
        return self.inFulfillmentOf
    def set_inFulfillmentOf(self, inFulfillmentOf):
        self.inFulfillmentOf = inFulfillmentOf
    def add_inFulfillmentOf(self, value):
        self.inFulfillmentOf.append(value)
    def insert_inFulfillmentOf_at(self, index, value):
        self.inFulfillmentOf.insert(index, value)
    def replace_inFulfillmentOf_at(self, index, value):
        self.inFulfillmentOf[index] = value
    def get_documentationOf(self):
        return self.documentationOf
    def set_documentationOf(self, documentationOf):
        self.documentationOf = documentationOf
    def add_documentationOf(self, value):
        self.documentationOf.append(value)
    def insert_documentationOf_at(self, index, value):
        self.documentationOf.insert(index, value)
    def replace_documentationOf_at(self, index, value):
        self.documentationOf[index] = value
    def get_relatedDocument(self):
        return self.relatedDocument
    def set_relatedDocument(self, relatedDocument):
        self.relatedDocument = relatedDocument
    def add_relatedDocument(self, value):
        self.relatedDocument.append(value)
    def insert_relatedDocument_at(self, index, value):
        self.relatedDocument.insert(index, value)
    def replace_relatedDocument_at(self, index, value):
        self.relatedDocument[index] = value
    def get_authorization(self):
        return self.authorization
    def set_authorization(self, authorization):
        self.authorization = authorization
    def add_authorization(self, value):
        self.authorization.append(value)
    def insert_authorization_at(self, index, value):
        self.authorization.insert(index, value)
    def replace_authorization_at(self, index, value):
        self.authorization[index] = value
    def get_componentOf(self):
        return self.componentOf
    def set_componentOf(self, componentOf):
        self.componentOf = componentOf
    def get_localHeader(self):
        return self.localHeader
    def set_localHeader(self, localHeader):
        self.localHeader = localHeader
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClinicalDocument(self, value):
        # Validate type ActClinicalDocument, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DOCCLIN', 'CDALVLONE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClinicalDocument' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClinicalDocument_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClinicalDocument_patterns_, ))
    validate_ActClinicalDocument_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.code is not None or
            self.title is not None or
            self.effectiveTime is not None or
            self.confidentialityCode is not None or
            self.languageCode is not None or
            self.setId is not None or
            self.versionNumber is not None or
            self.copyTime is not None or
            self.recordTarget or
            self.author or
            self.dataEnterer is not None or
            self.informant or
            self.custodian is not None or
            self.informationRecipient or
            self.legalAuthenticator is not None or
            self.authenticator or
            self.participant or
            self.inFulfillmentOf or
            self.documentationOf or
            self.relatedDocument or
            self.authorization or
            self.componentOf is not None or
            self.localHeader is not None or
            self.component is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:hl7fi="urn:hl7finland" ', name_='POCD_MT000040.ClinicalDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ClinicalDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ClinicalDocument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ClinicalDocument')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ClinicalDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ClinicalDocument'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DOCCLIN" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3"  xmlns:hl7fi="urn:hl7finland" ', name_='POCD_MT000040.ClinicalDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.setId is not None:
            namespaceprefix_ = self.setId_nsprefix_ + ':' if (UseCapturedNS_ and self.setId_nsprefix_) else ''
            self.setId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setId', pretty_print=pretty_print)
        if self.versionNumber is not None:
            namespaceprefix_ = self.versionNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.versionNumber_nsprefix_) else ''
            self.versionNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='versionNumber', pretty_print=pretty_print)
        if self.copyTime is not None:
            namespaceprefix_ = self.copyTime_nsprefix_ + ':' if (UseCapturedNS_ and self.copyTime_nsprefix_) else ''
            self.copyTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='copyTime', pretty_print=pretty_print)
        for recordTarget_ in self.recordTarget:
            namespaceprefix_ = self.recordTarget_nsprefix_ + ':' if (UseCapturedNS_ and self.recordTarget_nsprefix_) else ''
            recordTarget_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recordTarget', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        if self.dataEnterer is not None:
            namespaceprefix_ = self.dataEnterer_nsprefix_ + ':' if (UseCapturedNS_ and self.dataEnterer_nsprefix_) else ''
            self.dataEnterer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataEnterer', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        if self.custodian is not None:
            namespaceprefix_ = self.custodian_nsprefix_ + ':' if (UseCapturedNS_ and self.custodian_nsprefix_) else ''
            self.custodian.export(outfile, level, namespaceprefix_, namespacedef_='', name_='custodian', pretty_print=pretty_print)
        for informationRecipient_ in self.informationRecipient:
            namespaceprefix_ = self.informationRecipient_nsprefix_ + ':' if (UseCapturedNS_ and self.informationRecipient_nsprefix_) else ''
            informationRecipient_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informationRecipient', pretty_print=pretty_print)
        if self.legalAuthenticator is not None:
            namespaceprefix_ = self.legalAuthenticator_nsprefix_ + ':' if (UseCapturedNS_ and self.legalAuthenticator_nsprefix_) else ''
            self.legalAuthenticator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='legalAuthenticator', pretty_print=pretty_print)
        for authenticator_ in self.authenticator:
            namespaceprefix_ = self.authenticator_nsprefix_ + ':' if (UseCapturedNS_ and self.authenticator_nsprefix_) else ''
            authenticator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='authenticator', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for inFulfillmentOf_ in self.inFulfillmentOf:
            namespaceprefix_ = self.inFulfillmentOf_nsprefix_ + ':' if (UseCapturedNS_ and self.inFulfillmentOf_nsprefix_) else ''
            inFulfillmentOf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inFulfillmentOf', pretty_print=pretty_print)
        for documentationOf_ in self.documentationOf:
            namespaceprefix_ = self.documentationOf_nsprefix_ + ':' if (UseCapturedNS_ and self.documentationOf_nsprefix_) else ''
            documentationOf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='documentationOf', pretty_print=pretty_print)
        for relatedDocument_ in self.relatedDocument:
            namespaceprefix_ = self.relatedDocument_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedDocument_nsprefix_) else ''
            relatedDocument_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedDocument', pretty_print=pretty_print)
        for authorization_ in self.authorization:
            namespaceprefix_ = self.authorization_nsprefix_ + ':' if (UseCapturedNS_ and self.authorization_nsprefix_) else ''
            authorization_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='authorization', pretty_print=pretty_print)
        if self.componentOf is not None:
            namespaceprefix_ = self.componentOf_nsprefix_ + ':' if (UseCapturedNS_ and self.componentOf_nsprefix_) else ''
            self.componentOf.export(outfile, level, namespaceprefix_, namespacedef_='', name_='componentOf', pretty_print=pretty_print)
        if self.localHeader is not None:
            namespaceprefix_ = self.localHeader_nsprefix_ + ':' if (UseCapturedNS_ and self.localHeader_nsprefix_) else ''
            self.localHeader.export(outfile, level, namespaceprefix_='hl7fi:', namespacedef_='', name_='localHeader', pretty_print=pretty_print)
        if self.component is not None:
            namespaceprefix_ = self.component_nsprefix_ + ':' if (UseCapturedNS_ and self.component_nsprefix_) else ''
            self.component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='component', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClinicalDocument(self.classCode)    # validate type ActClinicalDocument
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'effectiveTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'setId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setId = obj_
            obj_.original_tagname_ = 'setId'
        elif nodeName_ == 'versionNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.versionNumber = obj_
            obj_.original_tagname_ = 'versionNumber'
        elif nodeName_ == 'copyTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.copyTime = obj_
            obj_.original_tagname_ = 'copyTime'
        elif nodeName_ == 'recordTarget':
            obj_ = POCD_MT000040_RecordTarget.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recordTarget.append(obj_)
            obj_.original_tagname_ = 'recordTarget'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'dataEnterer':
            obj_ = POCD_MT000040_DataEnterer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataEnterer = obj_
            obj_.original_tagname_ = 'dataEnterer'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'custodian':
            obj_ = POCD_MT000040_Custodian.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.custodian = obj_
            obj_.original_tagname_ = 'custodian'
        elif nodeName_ == 'informationRecipient':
            obj_ = POCD_MT000040_InformationRecipient.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informationRecipient.append(obj_)
            obj_.original_tagname_ = 'informationRecipient'
        elif nodeName_ == 'legalAuthenticator':
            obj_ = POCD_MT000040_LegalAuthenticator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.legalAuthenticator = obj_
            obj_.original_tagname_ = 'legalAuthenticator'
        elif nodeName_ == 'authenticator':
            obj_ = POCD_MT000040_Authenticator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.authenticator.append(obj_)
            obj_.original_tagname_ = 'authenticator'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'inFulfillmentOf':
            obj_ = POCD_MT000040_InFulfillmentOf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inFulfillmentOf.append(obj_)
            obj_.original_tagname_ = 'inFulfillmentOf'
        elif nodeName_ == 'documentationOf':
            obj_ = POCD_MT000040_DocumentationOf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.documentationOf.append(obj_)
            obj_.original_tagname_ = 'documentationOf'
        elif nodeName_ == 'relatedDocument':
            obj_ = POCD_MT000040_RelatedDocument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedDocument.append(obj_)
            obj_.original_tagname_ = 'relatedDocument'
        elif nodeName_ == 'authorization':
            obj_ = POCD_MT000040_Authorization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.authorization.append(obj_)
            obj_.original_tagname_ = 'authorization'
        elif nodeName_ == 'componentOf':
            obj_ = POCD_MT000040_Component1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.componentOf = obj_
            obj_.original_tagname_ = 'componentOf'
        elif nodeName_ == 'localHeader':
            obj_ = localHeader.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.localHeader = obj_
            obj_.original_tagname_ = 'localHeader'
        elif nodeName_ == 'component':
            obj_ = POCD_MT000040_Component2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component = obj_
            obj_.original_tagname_ = 'component'
# end class POCD_MT000040_ClinicalDocument


class POCD_MT000040_Component1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='COMP', realmCode=None, typeId=None, templateId=None, encompassingEncounter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.encompassingEncounter = encompassingEncounter
        self.encompassingEncounter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Component1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Component1.subclass:
            return POCD_MT000040_Component1.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Component1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_encompassingEncounter(self):
        return self.encompassingEncounter
    def set_encompassingEncounter(self, encompassingEncounter):
        self.encompassingEncounter = encompassingEncounter
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipHasComponent(self, value):
        # Validate type ActRelationshipHasComponent, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMP', 'ARR', 'CTRLV', 'DEP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipHasComponent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipHasComponent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipHasComponent_patterns_, ))
    validate_ActRelationshipHasComponent_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.encompassingEncounter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Component1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Component1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Component1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Component1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Component1'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "COMP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.encompassingEncounter is not None:
            namespaceprefix_ = self.encompassingEncounter_nsprefix_ + ':' if (UseCapturedNS_ and self.encompassingEncounter_nsprefix_) else ''
            self.encompassingEncounter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encompassingEncounter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipHasComponent(self.typeCode)    # validate type ActRelationshipHasComponent
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'encompassingEncounter':
            obj_ = POCD_MT000040_EncompassingEncounter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encompassingEncounter = obj_
            obj_.original_tagname_ = 'encompassingEncounter'
# end class POCD_MT000040_Component1


class POCD_MT000040_Component2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='COMP', contextConductionInd='true', realmCode=None, typeId=None, templateId=None, nonXMLBody=None, structuredBody=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.nonXMLBody = nonXMLBody
        self.nonXMLBody_nsprefix_ = None
        self.structuredBody = structuredBody
        self.structuredBody_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Component2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Component2.subclass:
            return POCD_MT000040_Component2.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Component2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_nonXMLBody(self):
        return self.nonXMLBody
    def set_nonXMLBody(self, nonXMLBody):
        self.nonXMLBody = nonXMLBody
    def get_structuredBody(self):
        return self.structuredBody
    def set_structuredBody(self, structuredBody):
        self.structuredBody = structuredBody
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def set_contextConductionInd(self, contextConductionInd):
        self.contextConductionInd = contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipHasComponent(self, value):
        # Validate type ActRelationshipHasComponent, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMP', 'ARR', 'CTRLV', 'DEP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipHasComponent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipHasComponent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipHasComponent_patterns_, ))
    validate_ActRelationshipHasComponent_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.nonXMLBody is not None or
            self.structuredBody is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Component2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Component2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Component2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Component2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Component2'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "COMP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if not self.contextConductionInd and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.nonXMLBody is not None:
            namespaceprefix_ = self.nonXMLBody_nsprefix_ + ':' if (UseCapturedNS_ and self.nonXMLBody_nsprefix_) else ''
            self.nonXMLBody.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nonXMLBody', pretty_print=pretty_print)
        if self.structuredBody is not None:
            namespaceprefix_ = self.structuredBody_nsprefix_ + ':' if (UseCapturedNS_ and self.structuredBody_nsprefix_) else ''
            self.structuredBody.export(outfile, level, namespaceprefix_, namespacedef_='', name_='structuredBody', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipHasComponent(self.typeCode)    # validate type ActRelationshipHasComponent
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'nonXMLBody':
            obj_ = POCD_MT000040_NonXMLBody.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nonXMLBody = obj_
            obj_.original_tagname_ = 'nonXMLBody'
        elif nodeName_ == 'structuredBody':
            obj_ = POCD_MT000040_StructuredBody.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.structuredBody = obj_
            obj_.original_tagname_ = 'structuredBody'
# end class POCD_MT000040_Component2


class POCD_MT000040_Component3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='COMP', contextConductionInd='true', realmCode=None, typeId=None, templateId=None, section=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.section = section
        self.section_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Component3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Component3.subclass:
            return POCD_MT000040_Component3.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Component3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_section(self):
        return self.section
    def set_section(self, section):
        self.section = section
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def set_contextConductionInd(self, contextConductionInd):
        self.contextConductionInd = contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipHasComponent(self, value):
        # Validate type ActRelationshipHasComponent, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMP', 'ARR', 'CTRLV', 'DEP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipHasComponent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipHasComponent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipHasComponent_patterns_, ))
    validate_ActRelationshipHasComponent_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.section is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Component3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Component3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Component3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Component3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Component3'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "COMP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if not self.contextConductionInd and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.section is not None:
            namespaceprefix_ = self.section_nsprefix_ + ':' if (UseCapturedNS_ and self.section_nsprefix_) else ''
            self.section.export(outfile, level, namespaceprefix_, namespacedef_='', name_='section', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipHasComponent(self.typeCode)    # validate type ActRelationshipHasComponent
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'section':
            obj_ = POCD_MT000040_Section.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.section = obj_
            obj_.original_tagname_ = 'section'
# end class POCD_MT000040_Component3


class POCD_MT000040_Component4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='COMP', contextConductionInd='true', realmCode=None, typeId=None, templateId=None, sequenceNumber=None, seperatableInd=None, act=None, encounter=None, observation=None, observationMedia=None, organizer=None, procedure=None, regionOfInterest=None, substanceAdministration=None, supply=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.sequenceNumber = sequenceNumber
        self.sequenceNumber_nsprefix_ = None
        self.seperatableInd = seperatableInd
        self.seperatableInd_nsprefix_ = None
        self.act = act
        self.act_nsprefix_ = None
        self.encounter = encounter
        self.encounter_nsprefix_ = None
        self.observation = observation
        self.observation_nsprefix_ = None
        self.observationMedia = observationMedia
        self.observationMedia_nsprefix_ = None
        self.organizer = organizer
        self.organizer_nsprefix_ = None
        self.procedure = procedure
        self.procedure_nsprefix_ = None
        self.regionOfInterest = regionOfInterest
        self.regionOfInterest_nsprefix_ = None
        self.substanceAdministration = substanceAdministration
        self.substanceAdministration_nsprefix_ = None
        self.supply = supply
        self.supply_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Component4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Component4.subclass:
            return POCD_MT000040_Component4.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Component4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_sequenceNumber(self):
        return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber):
        self.sequenceNumber = sequenceNumber
    def get_seperatableInd(self):
        return self.seperatableInd
    def set_seperatableInd(self, seperatableInd):
        self.seperatableInd = seperatableInd
    def get_act(self):
        return self.act
    def set_act(self, act):
        self.act = act
    def get_encounter(self):
        return self.encounter
    def set_encounter(self, encounter):
        self.encounter = encounter
    def get_observation(self):
        return self.observation
    def set_observation(self, observation):
        self.observation = observation
    def get_observationMedia(self):
        return self.observationMedia
    def set_observationMedia(self, observationMedia):
        self.observationMedia = observationMedia
    def get_organizer(self):
        return self.organizer
    def set_organizer(self, organizer):
        self.organizer = organizer
    def get_procedure(self):
        return self.procedure
    def set_procedure(self, procedure):
        self.procedure = procedure
    def get_regionOfInterest(self):
        return self.regionOfInterest
    def set_regionOfInterest(self, regionOfInterest):
        self.regionOfInterest = regionOfInterest
    def get_substanceAdministration(self):
        return self.substanceAdministration
    def set_substanceAdministration(self, substanceAdministration):
        self.substanceAdministration = substanceAdministration
    def get_supply(self):
        return self.supply
    def set_supply(self, supply):
        self.supply = supply
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def set_contextConductionInd(self, contextConductionInd):
        self.contextConductionInd = contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipHasComponent(self, value):
        # Validate type ActRelationshipHasComponent, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMP', 'ARR', 'CTRLV', 'DEP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipHasComponent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipHasComponent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipHasComponent_patterns_, ))
    validate_ActRelationshipHasComponent_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.sequenceNumber is not None or
            self.seperatableInd is not None or
            self.act is not None or
            self.encounter is not None or
            self.observation is not None or
            self.observationMedia is not None or
            self.organizer is not None or
            self.procedure is not None or
            self.regionOfInterest is not None or
            self.substanceAdministration is not None or
            self.supply is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Component4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Component4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Component4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Component4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Component4'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "COMP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if not self.contextConductionInd and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.sequenceNumber is not None:
            namespaceprefix_ = self.sequenceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.sequenceNumber_nsprefix_) else ''
            self.sequenceNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sequenceNumber', pretty_print=pretty_print)
        if self.seperatableInd is not None:
            namespaceprefix_ = self.seperatableInd_nsprefix_ + ':' if (UseCapturedNS_ and self.seperatableInd_nsprefix_) else ''
            self.seperatableInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='seperatableInd', pretty_print=pretty_print)
        if self.act is not None:
            namespaceprefix_ = self.act_nsprefix_ + ':' if (UseCapturedNS_ and self.act_nsprefix_) else ''
            self.act.export(outfile, level, namespaceprefix_, namespacedef_='', name_='act', pretty_print=pretty_print)
        if self.encounter is not None:
            namespaceprefix_ = self.encounter_nsprefix_ + ':' if (UseCapturedNS_ and self.encounter_nsprefix_) else ''
            self.encounter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encounter', pretty_print=pretty_print)
        if self.observation is not None:
            namespaceprefix_ = self.observation_nsprefix_ + ':' if (UseCapturedNS_ and self.observation_nsprefix_) else ''
            self.observation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observation', pretty_print=pretty_print)
        if self.observationMedia is not None:
            namespaceprefix_ = self.observationMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.observationMedia_nsprefix_) else ''
            self.observationMedia.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observationMedia', pretty_print=pretty_print)
        if self.organizer is not None:
            namespaceprefix_ = self.organizer_nsprefix_ + ':' if (UseCapturedNS_ and self.organizer_nsprefix_) else ''
            self.organizer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='organizer', pretty_print=pretty_print)
        if self.procedure is not None:
            namespaceprefix_ = self.procedure_nsprefix_ + ':' if (UseCapturedNS_ and self.procedure_nsprefix_) else ''
            self.procedure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='procedure', pretty_print=pretty_print)
        if self.regionOfInterest is not None:
            namespaceprefix_ = self.regionOfInterest_nsprefix_ + ':' if (UseCapturedNS_ and self.regionOfInterest_nsprefix_) else ''
            self.regionOfInterest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regionOfInterest', pretty_print=pretty_print)
        if self.substanceAdministration is not None:
            namespaceprefix_ = self.substanceAdministration_nsprefix_ + ':' if (UseCapturedNS_ and self.substanceAdministration_nsprefix_) else ''
            self.substanceAdministration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substanceAdministration', pretty_print=pretty_print)
        if self.supply is not None:
            namespaceprefix_ = self.supply_nsprefix_ + ':' if (UseCapturedNS_ and self.supply_nsprefix_) else ''
            self.supply.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supply', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipHasComponent(self.typeCode)    # validate type ActRelationshipHasComponent
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'sequenceNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sequenceNumber = obj_
            obj_.original_tagname_ = 'sequenceNumber'
        elif nodeName_ == 'seperatableInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.seperatableInd = obj_
            obj_.original_tagname_ = 'seperatableInd'
        elif nodeName_ == 'act':
            obj_ = POCD_MT000040_Act.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.act = obj_
            obj_.original_tagname_ = 'act'
        elif nodeName_ == 'encounter':
            obj_ = POCD_MT000040_Encounter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encounter = obj_
            obj_.original_tagname_ = 'encounter'
        elif nodeName_ == 'observation':
            obj_ = POCD_MT000040_Observation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observation = obj_
            obj_.original_tagname_ = 'observation'
        elif nodeName_ == 'observationMedia':
            obj_ = POCD_MT000040_ObservationMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observationMedia = obj_
            obj_.original_tagname_ = 'observationMedia'
        elif nodeName_ == 'organizer':
            obj_ = POCD_MT000040_Organizer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organizer = obj_
            obj_.original_tagname_ = 'organizer'
        elif nodeName_ == 'procedure':
            obj_ = POCD_MT000040_Procedure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.procedure = obj_
            obj_.original_tagname_ = 'procedure'
        elif nodeName_ == 'regionOfInterest':
            obj_ = POCD_MT000040_RegionOfInterest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regionOfInterest = obj_
            obj_.original_tagname_ = 'regionOfInterest'
        elif nodeName_ == 'substanceAdministration':
            obj_ = POCD_MT000040_SubstanceAdministration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substanceAdministration = obj_
            obj_.original_tagname_ = 'substanceAdministration'
        elif nodeName_ == 'supply':
            obj_ = POCD_MT000040_Supply.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supply = obj_
            obj_.original_tagname_ = 'supply'
# end class POCD_MT000040_Component4


class POCD_MT000040_Component5(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='COMP', contextConductionInd='true', realmCode=None, typeId=None, templateId=None, section=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.section = section
        self.section_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Component5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Component5.subclass:
            return POCD_MT000040_Component5.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Component5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_section(self):
        return self.section
    def set_section(self, section):
        self.section = section
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def set_contextConductionInd(self, contextConductionInd):
        self.contextConductionInd = contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipHasComponent(self, value):
        # Validate type ActRelationshipHasComponent, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMP', 'ARR', 'CTRLV', 'DEP']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipHasComponent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipHasComponent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipHasComponent_patterns_, ))
    validate_ActRelationshipHasComponent_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.section is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Component5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Component5':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Component5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Component5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Component5'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "COMP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if not self.contextConductionInd and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Component5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.section is not None:
            namespaceprefix_ = self.section_nsprefix_ + ':' if (UseCapturedNS_ and self.section_nsprefix_) else ''
            self.section.export(outfile, level, namespaceprefix_, namespacedef_='', name_='section', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipHasComponent(self.typeCode)    # validate type ActRelationshipHasComponent
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'section':
            obj_ = POCD_MT000040_Section.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.section = obj_
            obj_.original_tagname_ = 'section'
# end class POCD_MT000040_Component5


class POCD_MT000040_Consent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='CONS', moodCode='EVN', realmCode=None, typeId=None, templateId=None, id=None, code=None, statusCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Consent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Consent.subclass:
            return POCD_MT000040_Consent.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Consent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.statusCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Consent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Consent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Consent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Consent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Consent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Consent'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "CONS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Consent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
# end class POCD_MT000040_Consent


class POCD_MT000040_Consumable(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='CSM', realmCode=None, typeId=None, templateId=None, manufacturedProduct=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.manufacturedProduct = manufacturedProduct
        self.manufacturedProduct_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Consumable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Consumable.subclass:
            return POCD_MT000040_Consumable.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Consumable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_manufacturedProduct(self):
        return self.manufacturedProduct
    def set_manufacturedProduct(self, manufacturedProduct):
        self.manufacturedProduct = manufacturedProduct
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.manufacturedProduct is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Consumable', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Consumable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Consumable':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Consumable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Consumable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Consumable'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "CSM" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Consumable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.manufacturedProduct is not None:
            namespaceprefix_ = self.manufacturedProduct_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturedProduct_nsprefix_) else ''
            self.manufacturedProduct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturedProduct', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'manufacturedProduct':
            obj_ = POCD_MT000040_ManufacturedProduct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturedProduct = obj_
            obj_.original_tagname_ = 'manufacturedProduct'
# end class POCD_MT000040_Consumable


class POCD_MT000040_Criterion(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='OBS', moodCode='EVN.CRT', realmCode=None, typeId=None, templateId=None, code=None, text=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Criterion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Criterion.subclass:
            return POCD_MT000040_Criterion.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Criterion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def set_value_with_type(self, value):
        self.value = value
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.text is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Criterion', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Criterion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Criterion':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Criterion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Criterion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Criterion'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "OBS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN.CRT" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Criterion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'value':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <value> element')
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class POCD_MT000040_Criterion


class POCD_MT000040_Custodian(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='CST', realmCode=None, typeId=None, templateId=None, assignedCustodian=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.assignedCustodian = assignedCustodian
        self.assignedCustodian_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Custodian)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Custodian.subclass:
            return POCD_MT000040_Custodian.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Custodian(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_assignedCustodian(self):
        return self.assignedCustodian
    def set_assignedCustodian(self, assignedCustodian):
        self.assignedCustodian = assignedCustodian
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.assignedCustodian is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Custodian', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Custodian')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Custodian':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Custodian')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Custodian', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Custodian'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "CST" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Custodian', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.assignedCustodian is not None:
            namespaceprefix_ = self.assignedCustodian_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedCustodian_nsprefix_) else ''
            self.assignedCustodian.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedCustodian', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'assignedCustodian':
            obj_ = POCD_MT000040_AssignedCustodian.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedCustodian = obj_
            obj_.original_tagname_ = 'assignedCustodian'
# end class POCD_MT000040_Custodian


class POCD_MT000040_CustodianOrganization(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='ORG', determinerCode='INSTANCE', realmCode=None, typeId=None, templateId=None, id=None, name=None, telecom=None, addr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.addr = addr
        self.addr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_CustodianOrganization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_CustodianOrganization.subclass:
            return POCD_MT000040_CustodianOrganization.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_CustodianOrganization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassOrganization(self, value):
        # Validate type EntityClassOrganization, a restriction on cs.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.name is not None or
            self.telecom is not None or
            self.addr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.CustodianOrganization', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.CustodianOrganization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.CustodianOrganization':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.CustodianOrganization')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.CustodianOrganization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.CustodianOrganization'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ORG" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.CustodianOrganization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.telecom is not None:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            self.telecom.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.addr is not None:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            self.addr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassOrganization(self.classCode)    # validate type EntityClassOrganization
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = ON.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom = obj_
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr = obj_
            obj_.original_tagname_ = 'addr'
# end class POCD_MT000040_CustodianOrganization


class POCD_MT000040_DataEnterer(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='ENT', contextControlCode='OP', realmCode=None, typeId=None, templateId=None, time=None, assignedEntity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_DataEnterer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_DataEnterer.subclass:
            return POCD_MT000040_DataEnterer.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_DataEnterer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.DataEnterer', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.DataEnterer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.DataEnterer':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.DataEnterer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.DataEnterer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.DataEnterer'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "ENT" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.DataEnterer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_DataEnterer


class POCD_MT000040_Device(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='DEV', determinerCode='INSTANCE', realmCode=None, typeId=None, templateId=None, code=None, manufacturerModelName=None, softwareName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.manufacturerModelName = manufacturerModelName
        self.manufacturerModelName_nsprefix_ = None
        self.softwareName = softwareName
        self.softwareName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Device)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Device.subclass:
            return POCD_MT000040_Device.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Device(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_manufacturerModelName(self):
        return self.manufacturerModelName
    def set_manufacturerModelName(self, manufacturerModelName):
        self.manufacturerModelName = manufacturerModelName
    def get_softwareName(self):
        return self.softwareName
    def set_softwareName(self, softwareName):
        self.softwareName = softwareName
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassDevice(self, value):
        # Validate type EntityClassDevice, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DEV', 'CER', 'MODDV']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClassDevice' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClassDevice_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClassDevice_patterns_, ))
    validate_EntityClassDevice_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.manufacturerModelName is not None or
            self.softwareName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Device', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Device')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Device':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Device')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Device', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Device'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DEV" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Device', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.manufacturerModelName is not None:
            namespaceprefix_ = self.manufacturerModelName_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturerModelName_nsprefix_) else ''
            self.manufacturerModelName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturerModelName', pretty_print=pretty_print)
        if self.softwareName is not None:
            namespaceprefix_ = self.softwareName_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareName_nsprefix_) else ''
            self.softwareName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='softwareName', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassDevice(self.classCode)    # validate type EntityClassDevice
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'manufacturerModelName':
            obj_ = SC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturerModelName = obj_
            obj_.original_tagname_ = 'manufacturerModelName'
        elif nodeName_ == 'softwareName':
            obj_ = SC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.softwareName = obj_
            obj_.original_tagname_ = 'softwareName'
# end class POCD_MT000040_Device


class POCD_MT000040_DocumentationOf(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='DOC', realmCode=None, typeId=None, templateId=None, serviceEvent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.serviceEvent = serviceEvent
        self.serviceEvent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_DocumentationOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_DocumentationOf.subclass:
            return POCD_MT000040_DocumentationOf.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_DocumentationOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_serviceEvent(self):
        return self.serviceEvent
    def set_serviceEvent(self, serviceEvent):
        self.serviceEvent = serviceEvent
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.serviceEvent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.DocumentationOf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.DocumentationOf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.DocumentationOf':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.DocumentationOf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.DocumentationOf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.DocumentationOf'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "DOC" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.DocumentationOf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.serviceEvent is not None:
            namespaceprefix_ = self.serviceEvent_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceEvent_nsprefix_) else ''
            self.serviceEvent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceEvent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'serviceEvent':
            obj_ = POCD_MT000040_ServiceEvent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceEvent = obj_
            obj_.original_tagname_ = 'serviceEvent'
# end class POCD_MT000040_DocumentationOf


class POCD_MT000040_EncompassingEncounter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='ENC', moodCode='EVN', realmCode=None, typeId=None, templateId=None, id=None, code=None, effectiveTime=None, dischargeDispositionCode=None, responsibleParty=None, encounterParticipant=None, location=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.dischargeDispositionCode = dischargeDispositionCode
        self.dischargeDispositionCode_nsprefix_ = None
        self.responsibleParty = responsibleParty
        self.responsibleParty_nsprefix_ = None
        if encounterParticipant is None:
            self.encounterParticipant = []
        else:
            self.encounterParticipant = encounterParticipant
        self.encounterParticipant_nsprefix_ = None
        self.location = location
        self.location_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_EncompassingEncounter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_EncompassingEncounter.subclass:
            return POCD_MT000040_EncompassingEncounter.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_EncompassingEncounter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_dischargeDispositionCode(self):
        return self.dischargeDispositionCode
    def set_dischargeDispositionCode(self, dischargeDispositionCode):
        self.dischargeDispositionCode = dischargeDispositionCode
    def get_responsibleParty(self):
        return self.responsibleParty
    def set_responsibleParty(self, responsibleParty):
        self.responsibleParty = responsibleParty
    def get_encounterParticipant(self):
        return self.encounterParticipant
    def set_encounterParticipant(self, encounterParticipant):
        self.encounterParticipant = encounterParticipant
    def add_encounterParticipant(self, value):
        self.encounterParticipant.append(value)
    def insert_encounterParticipant_at(self, index, value):
        self.encounterParticipant.insert(index, value)
    def replace_encounterParticipant_at(self, index, value):
        self.encounterParticipant[index] = value
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.effectiveTime is not None or
            self.dischargeDispositionCode is not None or
            self.responsibleParty is not None or
            self.encounterParticipant or
            self.location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.EncompassingEncounter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.EncompassingEncounter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.EncompassingEncounter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.EncompassingEncounter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.EncompassingEncounter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.EncompassingEncounter'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ENC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.EncompassingEncounter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.dischargeDispositionCode is not None:
            namespaceprefix_ = self.dischargeDispositionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.dischargeDispositionCode_nsprefix_) else ''
            self.dischargeDispositionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dischargeDispositionCode', pretty_print=pretty_print)
        if self.responsibleParty is not None:
            namespaceprefix_ = self.responsibleParty_nsprefix_ + ':' if (UseCapturedNS_ and self.responsibleParty_nsprefix_) else ''
            self.responsibleParty.export(outfile, level, namespaceprefix_, namespacedef_='', name_='responsibleParty', pretty_print=pretty_print)
        for encounterParticipant_ in self.encounterParticipant:
            namespaceprefix_ = self.encounterParticipant_nsprefix_ + ':' if (UseCapturedNS_ and self.encounterParticipant_nsprefix_) else ''
            encounterParticipant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encounterParticipant', pretty_print=pretty_print)
        if self.location is not None:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            self.location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'dischargeDispositionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dischargeDispositionCode = obj_
            obj_.original_tagname_ = 'dischargeDispositionCode'
        elif nodeName_ == 'responsibleParty':
            obj_ = POCD_MT000040_ResponsibleParty.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.responsibleParty = obj_
            obj_.original_tagname_ = 'responsibleParty'
        elif nodeName_ == 'encounterParticipant':
            obj_ = POCD_MT000040_EncounterParticipant.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encounterParticipant.append(obj_)
            obj_.original_tagname_ = 'encounterParticipant'
        elif nodeName_ == 'location':
            obj_ = POCD_MT000040_Location.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
# end class POCD_MT000040_EncompassingEncounter


class POCD_MT000040_Encounter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode=None, moodCode=None, realmCode=None, typeId=None, templateId=None, id=None, code=None, text=None, statusCode=None, effectiveTime=None, priorityCode=None, subject=None, specimen=None, performer=None, author=None, informant=None, participant=None, entryRelationship=None, reference=None, precondition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Encounter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Encounter.subclass:
            return POCD_MT000040_Encounter.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Encounter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_x_DocumentEncounterMood(self, value):
        # Validate type x_DocumentEncounterMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INT', 'APT', 'ARQ', 'EVN', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentEncounterMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentEncounterMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentEncounterMood_patterns_, ))
    validate_x_DocumentEncounterMood_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.priorityCode is not None or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Encounter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Encounter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Encounter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Encounter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Encounter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Encounter'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Encounter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentEncounterMood(self.moodCode)    # validate type x_DocumentEncounterMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040_Encounter


class POCD_MT000040_EncounterParticipant(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode=None, realmCode=None, typeId=None, templateId=None, time=None, assignedEntity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_EncounterParticipant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_EncounterParticipant.subclass:
            return POCD_MT000040_EncounterParticipant.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_EncounterParticipant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_EncounterParticipant(self, value):
        # Validate type x_EncounterParticipant, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADM', 'ATND', 'CON', 'DIS', 'REF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_EncounterParticipant' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_EncounterParticipant_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_EncounterParticipant_patterns_, ))
    validate_x_EncounterParticipant_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.EncounterParticipant', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.EncounterParticipant')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.EncounterParticipant':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.EncounterParticipant')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.EncounterParticipant', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.EncounterParticipant'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.EncounterParticipant', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_EncounterParticipant(self.typeCode)    # validate type x_EncounterParticipant
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_EncounterParticipant


class POCD_MT000040_Entity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='ENT', determinerCode='INSTANCE', realmCode=None, typeId=None, templateId=None, id=None, code=None, desc=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.desc = desc
        self.desc_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Entity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Entity.subclass:
            return POCD_MT000040_Entity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Entity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassRoot(self, value):
        # Validate type EntityClassRoot, a restriction on cs.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.desc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Entity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Entity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Entity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Entity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Entity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Entity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ENT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Entity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='desc', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassRoot(self.classCode)    # validate type EntityClassRoot
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
# end class POCD_MT000040_Entity


class POCD_MT000040_Entry(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='COMP', contextConductionInd='true', realmCode=None, typeId=None, templateId=None, act=None, encounter=None, observation=None, observationMedia=None, organizer=None, procedure=None, regionOfInterest=None, substanceAdministration=None, supply=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.act = act
        self.act_nsprefix_ = None
        self.encounter = encounter
        self.encounter_nsprefix_ = None
        self.observation = observation
        self.observation_nsprefix_ = None
        self.observationMedia = observationMedia
        self.observationMedia_nsprefix_ = None
        self.organizer = organizer
        self.organizer_nsprefix_ = None
        self.procedure = procedure
        self.procedure_nsprefix_ = None
        self.regionOfInterest = regionOfInterest
        self.regionOfInterest_nsprefix_ = None
        self.substanceAdministration = substanceAdministration
        self.substanceAdministration_nsprefix_ = None
        self.supply = supply
        self.supply_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Entry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Entry.subclass:
            return POCD_MT000040_Entry.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Entry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_act(self):
        return self.act
    def set_act(self, act):
        self.act = act
    def get_encounter(self):
        return self.encounter
    def set_encounter(self, encounter):
        self.encounter = encounter
    def get_observation(self):
        return self.observation
    def set_observation(self, observation):
        self.observation = observation
    def get_observationMedia(self):
        return self.observationMedia
    def set_observationMedia(self, observationMedia):
        self.observationMedia = observationMedia
    def get_organizer(self):
        return self.organizer
    def set_organizer(self, organizer):
        self.organizer = organizer
    def get_procedure(self):
        return self.procedure
    def set_procedure(self, procedure):
        self.procedure = procedure
    def get_regionOfInterest(self):
        return self.regionOfInterest
    def set_regionOfInterest(self, regionOfInterest):
        self.regionOfInterest = regionOfInterest
    def get_substanceAdministration(self):
        return self.substanceAdministration
    def set_substanceAdministration(self, substanceAdministration):
        self.substanceAdministration = substanceAdministration
    def get_supply(self):
        return self.supply
    def set_supply(self, supply):
        self.supply = supply
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def set_contextConductionInd(self, contextConductionInd):
        self.contextConductionInd = contextConductionInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ActRelationshipEntry(self, value):
        # Validate type x_ActRelationshipEntry, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['COMP', 'DRIV']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActRelationshipEntry' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActRelationshipEntry_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActRelationshipEntry_patterns_, ))
    validate_x_ActRelationshipEntry_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.act is not None or
            self.encounter is not None or
            self.observation is not None or
            self.observationMedia is not None or
            self.organizer is not None or
            self.procedure is not None or
            self.regionOfInterest is not None or
            self.substanceAdministration is not None or
            self.supply is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Entry', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Entry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Entry':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Entry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Entry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Entry'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "COMP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if not self.contextConductionInd and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Entry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.act is not None:
            namespaceprefix_ = self.act_nsprefix_ + ':' if (UseCapturedNS_ and self.act_nsprefix_) else ''
            self.act.export(outfile, level, namespaceprefix_, namespacedef_='', name_='act', pretty_print=pretty_print)
        if self.encounter is not None:
            namespaceprefix_ = self.encounter_nsprefix_ + ':' if (UseCapturedNS_ and self.encounter_nsprefix_) else ''
            self.encounter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encounter', pretty_print=pretty_print)
        if self.observation is not None:
            namespaceprefix_ = self.observation_nsprefix_ + ':' if (UseCapturedNS_ and self.observation_nsprefix_) else ''
            self.observation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observation', pretty_print=pretty_print)
        if self.observationMedia is not None:
            namespaceprefix_ = self.observationMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.observationMedia_nsprefix_) else ''
            self.observationMedia.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observationMedia', pretty_print=pretty_print)
        if self.organizer is not None:
            namespaceprefix_ = self.organizer_nsprefix_ + ':' if (UseCapturedNS_ and self.organizer_nsprefix_) else ''
            self.organizer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='organizer', pretty_print=pretty_print)
        if self.procedure is not None:
            namespaceprefix_ = self.procedure_nsprefix_ + ':' if (UseCapturedNS_ and self.procedure_nsprefix_) else ''
            self.procedure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='procedure', pretty_print=pretty_print)
        if self.regionOfInterest is not None:
            namespaceprefix_ = self.regionOfInterest_nsprefix_ + ':' if (UseCapturedNS_ and self.regionOfInterest_nsprefix_) else ''
            self.regionOfInterest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regionOfInterest', pretty_print=pretty_print)
        if self.substanceAdministration is not None:
            namespaceprefix_ = self.substanceAdministration_nsprefix_ + ':' if (UseCapturedNS_ and self.substanceAdministration_nsprefix_) else ''
            self.substanceAdministration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substanceAdministration', pretty_print=pretty_print)
        if self.supply is not None:
            namespaceprefix_ = self.supply_nsprefix_ + ':' if (UseCapturedNS_ and self.supply_nsprefix_) else ''
            self.supply.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supply', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ActRelationshipEntry(self.typeCode)    # validate type x_ActRelationshipEntry
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'act':
            obj_ = POCD_MT000040_Act.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.act = obj_
            obj_.original_tagname_ = 'act'
        elif nodeName_ == 'encounter':
            obj_ = POCD_MT000040_Encounter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encounter = obj_
            obj_.original_tagname_ = 'encounter'
        elif nodeName_ == 'observation':
            obj_ = POCD_MT000040_Observation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observation = obj_
            obj_.original_tagname_ = 'observation'
        elif nodeName_ == 'observationMedia':
            obj_ = POCD_MT000040_ObservationMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observationMedia = obj_
            obj_.original_tagname_ = 'observationMedia'
        elif nodeName_ == 'organizer':
            obj_ = POCD_MT000040_Organizer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organizer = obj_
            obj_.original_tagname_ = 'organizer'
        elif nodeName_ == 'procedure':
            obj_ = POCD_MT000040_Procedure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.procedure = obj_
            obj_.original_tagname_ = 'procedure'
        elif nodeName_ == 'regionOfInterest':
            obj_ = POCD_MT000040_RegionOfInterest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regionOfInterest = obj_
            obj_.original_tagname_ = 'regionOfInterest'
        elif nodeName_ == 'substanceAdministration':
            obj_ = POCD_MT000040_SubstanceAdministration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substanceAdministration = obj_
            obj_.original_tagname_ = 'substanceAdministration'
        elif nodeName_ == 'supply':
            obj_ = POCD_MT000040_Supply.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supply = obj_
            obj_.original_tagname_ = 'supply'
# end class POCD_MT000040_Entry


class POCD_MT000040_EntryRelationship(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode=None, inversionInd=None, contextConductionInd='true', negationInd=None, realmCode=None, typeId=None, templateId=None, sequenceNumber=None, seperatableInd=None, act=None, encounter=None, observation=None, observationMedia=None, organizer=None, procedure=None, regionOfInterest=None, substanceAdministration=None, supply=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.inversionInd = _cast(bool, inversionInd)
        self.inversionInd_nsprefix_ = None
        self.contextConductionInd = _cast(bool, contextConductionInd)
        self.contextConductionInd_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.sequenceNumber = sequenceNumber
        self.sequenceNumber_nsprefix_ = None
        self.seperatableInd = seperatableInd
        self.seperatableInd_nsprefix_ = None
        self.act = act
        self.act_nsprefix_ = None
        self.encounter = encounter
        self.encounter_nsprefix_ = None
        self.observation = observation
        self.observation_nsprefix_ = None
        self.observationMedia = observationMedia
        self.observationMedia_nsprefix_ = None
        self.organizer = organizer
        self.organizer_nsprefix_ = None
        self.procedure = procedure
        self.procedure_nsprefix_ = None
        self.regionOfInterest = regionOfInterest
        self.regionOfInterest_nsprefix_ = None
        self.substanceAdministration = substanceAdministration
        self.substanceAdministration_nsprefix_ = None
        self.supply = supply
        self.supply_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_EntryRelationship)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_EntryRelationship.subclass:
            return POCD_MT000040_EntryRelationship.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_EntryRelationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_sequenceNumber(self):
        return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber):
        self.sequenceNumber = sequenceNumber
    def get_seperatableInd(self):
        return self.seperatableInd
    def set_seperatableInd(self, seperatableInd):
        self.seperatableInd = seperatableInd
    def get_act(self):
        return self.act
    def set_act(self, act):
        self.act = act
    def get_encounter(self):
        return self.encounter
    def set_encounter(self, encounter):
        self.encounter = encounter
    def get_observation(self):
        return self.observation
    def set_observation(self, observation):
        self.observation = observation
    def get_observationMedia(self):
        return self.observationMedia
    def set_observationMedia(self, observationMedia):
        self.observationMedia = observationMedia
    def get_organizer(self):
        return self.organizer
    def set_organizer(self, organizer):
        self.organizer = organizer
    def get_procedure(self):
        return self.procedure
    def set_procedure(self, procedure):
        self.procedure = procedure
    def get_regionOfInterest(self):
        return self.regionOfInterest
    def set_regionOfInterest(self, regionOfInterest):
        self.regionOfInterest = regionOfInterest
    def get_substanceAdministration(self):
        return self.substanceAdministration
    def set_substanceAdministration(self, substanceAdministration):
        self.substanceAdministration = substanceAdministration
    def get_supply(self):
        return self.supply
    def set_supply(self, supply):
        self.supply = supply
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_inversionInd(self):
        return self.inversionInd
    def set_inversionInd(self, inversionInd):
        self.inversionInd = inversionInd
    def get_contextConductionInd(self):
        return self.contextConductionInd
    def set_contextConductionInd(self, contextConductionInd):
        self.contextConductionInd = contextConductionInd
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ActRelationshipEntryRelationship(self, value):
        # Validate type x_ActRelationshipEntryRelationship, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['XCRPT', 'COMP', 'RSON', 'SPRT', 'CAUS', 'GEVL', 'MFST', 'REFR', 'SAS', 'SUBJ']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActRelationshipEntryRelationship' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActRelationshipEntryRelationship_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActRelationshipEntryRelationship_patterns_, ))
    validate_x_ActRelationshipEntryRelationship_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.sequenceNumber is not None or
            self.seperatableInd is not None or
            self.act is not None or
            self.encounter is not None or
            self.observation is not None or
            self.observationMedia is not None or
            self.organizer is not None or
            self.procedure is not None or
            self.regionOfInterest is not None or
            self.substanceAdministration is not None or
            self.supply is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.EntryRelationship', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.EntryRelationship')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.EntryRelationship':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.EntryRelationship')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.EntryRelationship', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.EntryRelationship'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.inversionInd is not None and 'inversionInd' not in already_processed:
            already_processed.add('inversionInd')
            outfile.write(' inversionInd="%s"' % self.gds_format_boolean(self.inversionInd, input_name='inversionInd'))
        if not self.contextConductionInd and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            outfile.write(' contextConductionInd="%s"' % self.gds_format_boolean(self.contextConductionInd, input_name='contextConductionInd'))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.EntryRelationship', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.sequenceNumber is not None:
            namespaceprefix_ = self.sequenceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.sequenceNumber_nsprefix_) else ''
            self.sequenceNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sequenceNumber', pretty_print=pretty_print)
        if self.seperatableInd is not None:
            namespaceprefix_ = self.seperatableInd_nsprefix_ + ':' if (UseCapturedNS_ and self.seperatableInd_nsprefix_) else ''
            self.seperatableInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='seperatableInd', pretty_print=pretty_print)
        if self.act is not None:
            namespaceprefix_ = self.act_nsprefix_ + ':' if (UseCapturedNS_ and self.act_nsprefix_) else ''
            self.act.export(outfile, level, namespaceprefix_, namespacedef_='', name_='act', pretty_print=pretty_print)
        if self.encounter is not None:
            namespaceprefix_ = self.encounter_nsprefix_ + ':' if (UseCapturedNS_ and self.encounter_nsprefix_) else ''
            self.encounter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encounter', pretty_print=pretty_print)
        if self.observation is not None:
            namespaceprefix_ = self.observation_nsprefix_ + ':' if (UseCapturedNS_ and self.observation_nsprefix_) else ''
            self.observation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observation', pretty_print=pretty_print)
        if self.observationMedia is not None:
            namespaceprefix_ = self.observationMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.observationMedia_nsprefix_) else ''
            self.observationMedia.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observationMedia', pretty_print=pretty_print)
        if self.organizer is not None:
            namespaceprefix_ = self.organizer_nsprefix_ + ':' if (UseCapturedNS_ and self.organizer_nsprefix_) else ''
            self.organizer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='organizer', pretty_print=pretty_print)
        if self.procedure is not None:
            namespaceprefix_ = self.procedure_nsprefix_ + ':' if (UseCapturedNS_ and self.procedure_nsprefix_) else ''
            self.procedure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='procedure', pretty_print=pretty_print)
        if self.regionOfInterest is not None:
            namespaceprefix_ = self.regionOfInterest_nsprefix_ + ':' if (UseCapturedNS_ and self.regionOfInterest_nsprefix_) else ''
            self.regionOfInterest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regionOfInterest', pretty_print=pretty_print)
        if self.substanceAdministration is not None:
            namespaceprefix_ = self.substanceAdministration_nsprefix_ + ':' if (UseCapturedNS_ and self.substanceAdministration_nsprefix_) else ''
            self.substanceAdministration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substanceAdministration', pretty_print=pretty_print)
        if self.supply is not None:
            namespaceprefix_ = self.supply_nsprefix_ + ':' if (UseCapturedNS_ and self.supply_nsprefix_) else ''
            self.supply.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supply', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ActRelationshipEntryRelationship(self.typeCode)    # validate type x_ActRelationshipEntryRelationship
        value = find_attr_value_('inversionInd', node)
        if value is not None and 'inversionInd' not in already_processed:
            already_processed.add('inversionInd')
            if value in ('true', '1'):
                self.inversionInd = True
            elif value in ('false', '0'):
                self.inversionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inversionInd)    # validate type bl
        value = find_attr_value_('contextConductionInd', node)
        if value is not None and 'contextConductionInd' not in already_processed:
            already_processed.add('contextConductionInd')
            if value in ('true', '1'):
                self.contextConductionInd = True
            elif value in ('false', '0'):
                self.contextConductionInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.contextConductionInd)    # validate type bl
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'sequenceNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sequenceNumber = obj_
            obj_.original_tagname_ = 'sequenceNumber'
        elif nodeName_ == 'seperatableInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.seperatableInd = obj_
            obj_.original_tagname_ = 'seperatableInd'
        elif nodeName_ == 'act':
            obj_ = POCD_MT000040_Act.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.act = obj_
            obj_.original_tagname_ = 'act'
        elif nodeName_ == 'encounter':
            obj_ = POCD_MT000040_Encounter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encounter = obj_
            obj_.original_tagname_ = 'encounter'
        elif nodeName_ == 'observation':
            obj_ = POCD_MT000040_Observation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observation = obj_
            obj_.original_tagname_ = 'observation'
        elif nodeName_ == 'observationMedia':
            obj_ = POCD_MT000040_ObservationMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observationMedia = obj_
            obj_.original_tagname_ = 'observationMedia'
        elif nodeName_ == 'organizer':
            obj_ = POCD_MT000040_Organizer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.organizer = obj_
            obj_.original_tagname_ = 'organizer'
        elif nodeName_ == 'procedure':
            obj_ = POCD_MT000040_Procedure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.procedure = obj_
            obj_.original_tagname_ = 'procedure'
        elif nodeName_ == 'regionOfInterest':
            obj_ = POCD_MT000040_RegionOfInterest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regionOfInterest = obj_
            obj_.original_tagname_ = 'regionOfInterest'
        elif nodeName_ == 'substanceAdministration':
            obj_ = POCD_MT000040_SubstanceAdministration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substanceAdministration = obj_
            obj_.original_tagname_ = 'substanceAdministration'
        elif nodeName_ == 'supply':
            obj_ = POCD_MT000040_Supply.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supply = obj_
            obj_.original_tagname_ = 'supply'
# end class POCD_MT000040_EntryRelationship


class POCD_MT000040_ExternalAct(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='ACT', moodCode='EVN', realmCode=None, typeId=None, templateId=None, id=None, code=None, text=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ExternalAct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ExternalAct.subclass:
            return POCD_MT000040_ExternalAct.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ExternalAct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassRoot(self, value):
        # Validate type ActClassRoot, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalAct', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ExternalAct')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ExternalAct':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ExternalAct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ExternalAct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ExternalAct'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ACT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalAct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassRoot(self.classCode)    # validate type ActClassRoot
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
# end class POCD_MT000040_ExternalAct


class POCD_MT000040_ExternalDocument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='DOC', moodCode='EVN', realmCode=None, typeId=None, templateId=None, id=None, code=None, text=None, setId=None, versionNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.setId = setId
        self.setId_nsprefix_ = None
        self.versionNumber = versionNumber
        self.versionNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ExternalDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ExternalDocument.subclass:
            return POCD_MT000040_ExternalDocument.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ExternalDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_setId(self):
        return self.setId
    def set_setId(self, setId):
        self.setId = setId
    def get_versionNumber(self):
        return self.versionNumber
    def set_versionNumber(self, versionNumber):
        self.versionNumber = versionNumber
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassDocument(self, value):
        # Validate type ActClassDocument, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.setId is not None or
            self.versionNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ExternalDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ExternalDocument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ExternalDocument')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ExternalDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ExternalDocument'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DOC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.setId is not None:
            namespaceprefix_ = self.setId_nsprefix_ + ':' if (UseCapturedNS_ and self.setId_nsprefix_) else ''
            self.setId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setId', pretty_print=pretty_print)
        if self.versionNumber is not None:
            namespaceprefix_ = self.versionNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.versionNumber_nsprefix_) else ''
            self.versionNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='versionNumber', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassDocument(self.classCode)    # validate type ActClassDocument
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'setId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setId = obj_
            obj_.original_tagname_ = 'setId'
        elif nodeName_ == 'versionNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.versionNumber = obj_
            obj_.original_tagname_ = 'versionNumber'
# end class POCD_MT000040_ExternalDocument


class POCD_MT000040_ExternalObservation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='OBS', moodCode='EVN', realmCode=None, typeId=None, templateId=None, id=None, code=None, text=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ExternalObservation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ExternalObservation.subclass:
            return POCD_MT000040_ExternalObservation.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ExternalObservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalObservation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ExternalObservation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ExternalObservation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ExternalObservation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ExternalObservation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ExternalObservation'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "OBS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalObservation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
# end class POCD_MT000040_ExternalObservation


class POCD_MT000040_ExternalProcedure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='PROC', moodCode='EVN', realmCode=None, typeId=None, templateId=None, id=None, code=None, text=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ExternalProcedure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ExternalProcedure.subclass:
            return POCD_MT000040_ExternalProcedure.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ExternalProcedure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalProcedure', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ExternalProcedure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ExternalProcedure':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ExternalProcedure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ExternalProcedure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ExternalProcedure'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PROC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ExternalProcedure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
# end class POCD_MT000040_ExternalProcedure


class POCD_MT000040_Guardian(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='GUARD', realmCode=None, typeId=None, templateId=None, id=None, code=None, addr=None, telecom=None, guardianPerson=None, guardianOrganization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.guardianPerson = guardianPerson
        self.guardianPerson_nsprefix_ = None
        self.guardianOrganization = guardianOrganization
        self.guardianOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Guardian)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Guardian.subclass:
            return POCD_MT000040_Guardian.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Guardian(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_guardianPerson(self):
        return self.guardianPerson
    def set_guardianPerson(self, guardianPerson):
        self.guardianPerson = guardianPerson
    def get_guardianOrganization(self):
        return self.guardianOrganization
    def set_guardianOrganization(self, guardianOrganization):
        self.guardianOrganization = guardianOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.guardianPerson is not None or
            self.guardianOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Guardian', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Guardian')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Guardian':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Guardian')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Guardian', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Guardian'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "GUARD" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Guardian', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.guardianPerson is not None:
            namespaceprefix_ = self.guardianPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.guardianPerson_nsprefix_) else ''
            self.guardianPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='guardianPerson', pretty_print=pretty_print)
        if self.guardianOrganization is not None:
            namespaceprefix_ = self.guardianOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.guardianOrganization_nsprefix_) else ''
            self.guardianOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='guardianOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'guardianPerson':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.guardianPerson = obj_
            obj_.original_tagname_ = 'guardianPerson'
        elif nodeName_ == 'guardianOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.guardianOrganization = obj_
            obj_.original_tagname_ = 'guardianOrganization'
# end class POCD_MT000040_Guardian


class POCD_MT000040_HealthCareFacility(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='SDLOC', realmCode=None, typeId=None, templateId=None, id=None, code=None, location=None, serviceProviderOrganization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.location = location
        self.location_nsprefix_ = None
        self.serviceProviderOrganization = serviceProviderOrganization
        self.serviceProviderOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_HealthCareFacility)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_HealthCareFacility.subclass:
            return POCD_MT000040_HealthCareFacility.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_HealthCareFacility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_serviceProviderOrganization(self):
        return self.serviceProviderOrganization
    def set_serviceProviderOrganization(self, serviceProviderOrganization):
        self.serviceProviderOrganization = serviceProviderOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassServiceDeliveryLocation(self, value):
        # Validate type RoleClassServiceDeliveryLocation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SDLOC', 'DSDLOC', 'ISDLOC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassServiceDeliveryLocation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassServiceDeliveryLocation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassServiceDeliveryLocation_patterns_, ))
    validate_RoleClassServiceDeliveryLocation_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.location is not None or
            self.serviceProviderOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.HealthCareFacility', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.HealthCareFacility')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.HealthCareFacility':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.HealthCareFacility')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.HealthCareFacility', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.HealthCareFacility'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "SDLOC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.HealthCareFacility', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.location is not None:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            self.location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
        if self.serviceProviderOrganization is not None:
            namespaceprefix_ = self.serviceProviderOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceProviderOrganization_nsprefix_) else ''
            self.serviceProviderOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceProviderOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassServiceDeliveryLocation(self.classCode)    # validate type RoleClassServiceDeliveryLocation
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'location':
            obj_ = POCD_MT000040_Place.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'serviceProviderOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceProviderOrganization = obj_
            obj_.original_tagname_ = 'serviceProviderOrganization'
# end class POCD_MT000040_HealthCareFacility


class POCD_MT000040_Informant12(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='INF', contextControlCode='OP', realmCode=None, typeId=None, templateId=None, assignedEntity=None, relatedEntity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
        self.relatedEntity = relatedEntity
        self.relatedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Informant12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Informant12.subclass:
            return POCD_MT000040_Informant12.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Informant12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_relatedEntity(self):
        return self.relatedEntity
    def set_relatedEntity(self, relatedEntity):
        self.relatedEntity = relatedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.assignedEntity is not None or
            self.relatedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Informant12', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Informant12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Informant12':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Informant12')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Informant12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Informant12'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "INF" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Informant12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
        if self.relatedEntity is not None:
            namespaceprefix_ = self.relatedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedEntity_nsprefix_) else ''
            self.relatedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
        elif nodeName_ == 'relatedEntity':
            obj_ = POCD_MT000040_RelatedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedEntity = obj_
            obj_.original_tagname_ = 'relatedEntity'
# end class POCD_MT000040_Informant12


class POCD_MT000040_InformationRecipient(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='PRCP', realmCode=None, typeId=None, templateId=None, intendedRecipient=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.intendedRecipient = intendedRecipient
        self.intendedRecipient_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_InformationRecipient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_InformationRecipient.subclass:
            return POCD_MT000040_InformationRecipient.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_InformationRecipient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_intendedRecipient(self):
        return self.intendedRecipient
    def set_intendedRecipient(self, intendedRecipient):
        self.intendedRecipient = intendedRecipient
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_InformationRecipient(self, value):
        # Validate type x_InformationRecipient, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PRCP', 'TRC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_InformationRecipient' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_InformationRecipient_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_InformationRecipient_patterns_, ))
    validate_x_InformationRecipient_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.intendedRecipient is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.InformationRecipient', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.InformationRecipient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.InformationRecipient':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.InformationRecipient')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.InformationRecipient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.InformationRecipient'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "PRCP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.InformationRecipient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.intendedRecipient is not None:
            namespaceprefix_ = self.intendedRecipient_nsprefix_ + ':' if (UseCapturedNS_ and self.intendedRecipient_nsprefix_) else ''
            self.intendedRecipient.export(outfile, level, namespaceprefix_, namespacedef_='', name_='intendedRecipient', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_InformationRecipient(self.typeCode)    # validate type x_InformationRecipient
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'intendedRecipient':
            obj_ = POCD_MT000040_IntendedRecipient.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intendedRecipient = obj_
            obj_.original_tagname_ = 'intendedRecipient'
# end class POCD_MT000040_InformationRecipient


class POCD_MT000040_InFulfillmentOf(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='FLFS', realmCode=None, typeId=None, templateId=None, order=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.order = order
        self.order_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_InFulfillmentOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_InFulfillmentOf.subclass:
            return POCD_MT000040_InFulfillmentOf.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_InFulfillmentOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_order(self):
        return self.order
    def set_order(self, order):
        self.order = order
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipFulfills(self, value):
        # Validate type ActRelationshipFulfills, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['FLFS', 'OCCR', 'OREF', 'SCH']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActRelationshipFulfills' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActRelationshipFulfills_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActRelationshipFulfills_patterns_, ))
    validate_ActRelationshipFulfills_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.order is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.InFulfillmentOf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.InFulfillmentOf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.InFulfillmentOf':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.InFulfillmentOf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.InFulfillmentOf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.InFulfillmentOf'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "FLFS" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.InFulfillmentOf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.order is not None:
            namespaceprefix_ = self.order_nsprefix_ + ':' if (UseCapturedNS_ and self.order_nsprefix_) else ''
            self.order.export(outfile, level, namespaceprefix_, namespacedef_='', name_='order', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ActRelationshipFulfills(self.typeCode)    # validate type ActRelationshipFulfills
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'order':
            obj_ = POCD_MT000040_Order.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.order = obj_
            obj_.original_tagname_ = 'order'
# end class POCD_MT000040_InFulfillmentOf


class POCD_MT000040_IntendedRecipient(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='ASSIGNED', realmCode=None, typeId=None, templateId=None, id=None, addr=None, telecom=None, informationRecipient=None, receivedOrganization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.informationRecipient = informationRecipient
        self.informationRecipient_nsprefix_ = None
        self.receivedOrganization = receivedOrganization
        self.receivedOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_IntendedRecipient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_IntendedRecipient.subclass:
            return POCD_MT000040_IntendedRecipient.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_IntendedRecipient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_informationRecipient(self):
        return self.informationRecipient
    def set_informationRecipient(self, informationRecipient):
        self.informationRecipient = informationRecipient
    def get_receivedOrganization(self):
        return self.receivedOrganization
    def set_receivedOrganization(self, receivedOrganization):
        self.receivedOrganization = receivedOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_InformationRecipientRole(self, value):
        # Validate type x_InformationRecipientRole, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ASSIGNED', 'HLTHCHRT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_InformationRecipientRole' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_InformationRecipientRole_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_InformationRecipientRole_patterns_, ))
    validate_x_InformationRecipientRole_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.addr or
            self.telecom or
            self.informationRecipient is not None or
            self.receivedOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.IntendedRecipient', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.IntendedRecipient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.IntendedRecipient':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.IntendedRecipient')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.IntendedRecipient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.IntendedRecipient'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ASSIGNED" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.IntendedRecipient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.informationRecipient is not None:
            namespaceprefix_ = self.informationRecipient_nsprefix_ + ':' if (UseCapturedNS_ and self.informationRecipient_nsprefix_) else ''
            self.informationRecipient.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informationRecipient', pretty_print=pretty_print)
        if self.receivedOrganization is not None:
            namespaceprefix_ = self.receivedOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.receivedOrganization_nsprefix_) else ''
            self.receivedOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='receivedOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_x_InformationRecipientRole(self.classCode)    # validate type x_InformationRecipientRole
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'informationRecipient':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informationRecipient = obj_
            obj_.original_tagname_ = 'informationRecipient'
        elif nodeName_ == 'receivedOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.receivedOrganization = obj_
            obj_.original_tagname_ = 'receivedOrganization'
# end class POCD_MT000040_IntendedRecipient


class POCD_MT000040_LabeledDrug(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='MMAT', determinerCode='KIND', realmCode=None, typeId=None, templateId=None, code=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_LabeledDrug)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_LabeledDrug.subclass:
            return POCD_MT000040_LabeledDrug.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_LabeledDrug(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassManufacturedMaterial(self, value):
        # Validate type EntityClassManufacturedMaterial, a restriction on cs.
        pass
    def validate_EntityDeterminerDetermined(self, value):
        # Validate type EntityDeterminerDetermined, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminerDetermined' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminerDetermined_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminerDetermined_patterns_, ))
    validate_EntityDeterminerDetermined_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.LabeledDrug', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.LabeledDrug')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.LabeledDrug':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.LabeledDrug')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.LabeledDrug', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.LabeledDrug'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "MMAT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "KIND" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.LabeledDrug', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassManufacturedMaterial(self.classCode)    # validate type EntityClassManufacturedMaterial
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminerDetermined(self.determinerCode)    # validate type EntityDeterminerDetermined
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, EN)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
# end class POCD_MT000040_LabeledDrug


class POCD_MT000040_LanguageCommunication(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, realmCode=None, typeId=None, templateId=None, languageCode=None, modeCode=None, proficiencyLevelCode=None, preferenceInd=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.modeCode = modeCode
        self.modeCode_nsprefix_ = None
        self.proficiencyLevelCode = proficiencyLevelCode
        self.proficiencyLevelCode_nsprefix_ = None
        self.preferenceInd = preferenceInd
        self.preferenceInd_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_LanguageCommunication)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_LanguageCommunication.subclass:
            return POCD_MT000040_LanguageCommunication.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_LanguageCommunication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_modeCode(self):
        return self.modeCode
    def set_modeCode(self, modeCode):
        self.modeCode = modeCode
    def get_proficiencyLevelCode(self):
        return self.proficiencyLevelCode
    def set_proficiencyLevelCode(self, proficiencyLevelCode):
        self.proficiencyLevelCode = proficiencyLevelCode
    def get_preferenceInd(self):
        return self.preferenceInd
    def set_preferenceInd(self, preferenceInd):
        self.preferenceInd = preferenceInd
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.languageCode is not None or
            self.modeCode is not None or
            self.proficiencyLevelCode is not None or
            self.preferenceInd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.LanguageCommunication', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.LanguageCommunication')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.LanguageCommunication':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.LanguageCommunication')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.LanguageCommunication', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.LanguageCommunication'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.LanguageCommunication', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.modeCode is not None:
            namespaceprefix_ = self.modeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.modeCode_nsprefix_) else ''
            self.modeCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='modeCode', pretty_print=pretty_print)
        if self.proficiencyLevelCode is not None:
            namespaceprefix_ = self.proficiencyLevelCode_nsprefix_ + ':' if (UseCapturedNS_ and self.proficiencyLevelCode_nsprefix_) else ''
            self.proficiencyLevelCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='proficiencyLevelCode', pretty_print=pretty_print)
        if self.preferenceInd is not None:
            namespaceprefix_ = self.preferenceInd_nsprefix_ + ':' if (UseCapturedNS_ and self.preferenceInd_nsprefix_) else ''
            self.preferenceInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='preferenceInd', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'modeCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modeCode = obj_
            obj_.original_tagname_ = 'modeCode'
        elif nodeName_ == 'proficiencyLevelCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.proficiencyLevelCode = obj_
            obj_.original_tagname_ = 'proficiencyLevelCode'
        elif nodeName_ == 'preferenceInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.preferenceInd = obj_
            obj_.original_tagname_ = 'preferenceInd'
# end class POCD_MT000040_LanguageCommunication


class POCD_MT000040_LegalAuthenticator(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='LA', contextControlCode='OP', realmCode=None, typeId=None, templateId=None, time=None, signatureCode=None, assignedEntity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.signatureCode = signatureCode
        self.signatureCode_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_LegalAuthenticator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_LegalAuthenticator.subclass:
            return POCD_MT000040_LegalAuthenticator.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_LegalAuthenticator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_signatureCode(self):
        return self.signatureCode
    def set_signatureCode(self, signatureCode):
        self.signatureCode = signatureCode
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.signatureCode is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.LegalAuthenticator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.LegalAuthenticator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.LegalAuthenticator':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.LegalAuthenticator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.LegalAuthenticator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.LegalAuthenticator'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "LA" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.LegalAuthenticator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.signatureCode is not None:
            namespaceprefix_ = self.signatureCode_nsprefix_ + ':' if (UseCapturedNS_ and self.signatureCode_nsprefix_) else ''
            self.signatureCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signatureCode', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'signatureCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signatureCode = obj_
            obj_.original_tagname_ = 'signatureCode'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_LegalAuthenticator


class POCD_MT000040_Location(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='LOC', realmCode=None, typeId=None, templateId=None, healthCareFacility=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.healthCareFacility = healthCareFacility
        self.healthCareFacility_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Location)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Location.subclass:
            return POCD_MT000040_Location.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_healthCareFacility(self):
        return self.healthCareFacility
    def set_healthCareFacility(self, healthCareFacility):
        self.healthCareFacility = healthCareFacility
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetLocation(self, value):
        # Validate type ParticipationTargetLocation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['LOC', 'DST', 'ELOC', 'ORG', 'RML', 'VIA']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetLocation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetLocation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetLocation_patterns_, ))
    validate_ParticipationTargetLocation_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.healthCareFacility is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Location', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Location')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Location':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Location')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Location', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Location'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "LOC" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Location', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.healthCareFacility is not None:
            namespaceprefix_ = self.healthCareFacility_nsprefix_ + ':' if (UseCapturedNS_ and self.healthCareFacility_nsprefix_) else ''
            self.healthCareFacility.export(outfile, level, namespaceprefix_, namespacedef_='', name_='healthCareFacility', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetLocation(self.typeCode)    # validate type ParticipationTargetLocation
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'healthCareFacility':
            obj_ = POCD_MT000040_HealthCareFacility.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.healthCareFacility = obj_
            obj_.original_tagname_ = 'healthCareFacility'
# end class POCD_MT000040_Location


class POCD_MT000040_MaintainedEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='MNT', realmCode=None, typeId=None, templateId=None, effectiveTime=None, maintainingPerson=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.maintainingPerson = maintainingPerson
        self.maintainingPerson_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_MaintainedEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_MaintainedEntity.subclass:
            return POCD_MT000040_MaintainedEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_MaintainedEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_maintainingPerson(self):
        return self.maintainingPerson
    def set_maintainingPerson(self, maintainingPerson):
        self.maintainingPerson = maintainingPerson
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.effectiveTime is not None or
            self.maintainingPerson is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.MaintainedEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.MaintainedEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.MaintainedEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.MaintainedEntity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.MaintainedEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.MaintainedEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "MNT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.MaintainedEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.maintainingPerson is not None:
            namespaceprefix_ = self.maintainingPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.maintainingPerson_nsprefix_) else ''
            self.maintainingPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maintainingPerson', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'maintainingPerson':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maintainingPerson = obj_
            obj_.original_tagname_ = 'maintainingPerson'
# end class POCD_MT000040_MaintainedEntity


class POCD_MT000040_ManufacturedProduct(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='MANU', realmCode=None, typeId=None, templateId=None, id=None, manufacturedLabeledDrug=None, manufacturedMaterial=None, manufacturerOrganization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.manufacturedLabeledDrug = manufacturedLabeledDrug
        self.manufacturedLabeledDrug_nsprefix_ = None
        self.manufacturedMaterial = manufacturedMaterial
        self.manufacturedMaterial_nsprefix_ = None
        self.manufacturerOrganization = manufacturerOrganization
        self.manufacturerOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ManufacturedProduct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ManufacturedProduct.subclass:
            return POCD_MT000040_ManufacturedProduct.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ManufacturedProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_manufacturedLabeledDrug(self):
        return self.manufacturedLabeledDrug
    def set_manufacturedLabeledDrug(self, manufacturedLabeledDrug):
        self.manufacturedLabeledDrug = manufacturedLabeledDrug
    def get_manufacturedMaterial(self):
        return self.manufacturedMaterial
    def set_manufacturedMaterial(self, manufacturedMaterial):
        self.manufacturedMaterial = manufacturedMaterial
    def get_manufacturerOrganization(self):
        return self.manufacturerOrganization
    def set_manufacturerOrganization(self, manufacturerOrganization):
        self.manufacturerOrganization = manufacturerOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassManufacturedProduct(self, value):
        # Validate type RoleClassManufacturedProduct, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MANU', 'THER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassManufacturedProduct' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassManufacturedProduct_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassManufacturedProduct_patterns_, ))
    validate_RoleClassManufacturedProduct_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.manufacturedLabeledDrug is not None or
            self.manufacturedMaterial is not None or
            self.manufacturerOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ManufacturedProduct', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ManufacturedProduct')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ManufacturedProduct':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ManufacturedProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ManufacturedProduct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ManufacturedProduct'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "MANU" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ManufacturedProduct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.manufacturedLabeledDrug is not None:
            namespaceprefix_ = self.manufacturedLabeledDrug_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturedLabeledDrug_nsprefix_) else ''
            self.manufacturedLabeledDrug.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturedLabeledDrug', pretty_print=pretty_print)
        if self.manufacturedMaterial is not None:
            namespaceprefix_ = self.manufacturedMaterial_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturedMaterial_nsprefix_) else ''
            self.manufacturedMaterial.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturedMaterial', pretty_print=pretty_print)
        if self.manufacturerOrganization is not None:
            namespaceprefix_ = self.manufacturerOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturerOrganization_nsprefix_) else ''
            self.manufacturerOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturerOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassManufacturedProduct(self.classCode)    # validate type RoleClassManufacturedProduct
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'manufacturedLabeledDrug':
            obj_ = POCD_MT000040_LabeledDrug.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturedLabeledDrug = obj_
            obj_.original_tagname_ = 'manufacturedLabeledDrug'
        elif nodeName_ == 'manufacturedMaterial':
            obj_ = POCD_MT000040_Material.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturedMaterial = obj_
            obj_.original_tagname_ = 'manufacturedMaterial'
        elif nodeName_ == 'manufacturerOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturerOrganization = obj_
            obj_.original_tagname_ = 'manufacturerOrganization'
# end class POCD_MT000040_ManufacturedProduct


class POCD_MT000040_Material(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='MMAT', determinerCode='KIND', realmCode=None, typeId=None, templateId=None, code=None, name=None, lotNumberText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.lotNumberText = lotNumberText
        self.lotNumberText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Material)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Material.subclass:
            return POCD_MT000040_Material.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Material(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_lotNumberText(self):
        return self.lotNumberText
    def set_lotNumberText(self, lotNumberText):
        self.lotNumberText = lotNumberText
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassManufacturedMaterial(self, value):
        # Validate type EntityClassManufacturedMaterial, a restriction on cs.
        pass
    def validate_EntityDeterminerDetermined(self, value):
        # Validate type EntityDeterminerDetermined, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['KIND', 'QUANTIFIED_KIND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityDeterminerDetermined' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityDeterminerDetermined_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityDeterminerDetermined_patterns_, ))
    validate_EntityDeterminerDetermined_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.name is not None or
            self.lotNumberText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Material', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Material')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Material':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Material')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Material', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Material'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "MMAT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "KIND" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Material', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.lotNumberText is not None:
            namespaceprefix_ = self.lotNumberText_nsprefix_ + ':' if (UseCapturedNS_ and self.lotNumberText_nsprefix_) else ''
            self.lotNumberText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lotNumberText', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassManufacturedMaterial(self.classCode)    # validate type EntityClassManufacturedMaterial
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminerDetermined(self.determinerCode)    # validate type EntityDeterminerDetermined
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, EN)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'lotNumberText':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lotNumberText = obj_
            obj_.original_tagname_ = 'lotNumberText'
# end class POCD_MT000040_Material


class POCD_MT000040_NonXMLBody(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, nullFlavor=None, classCode='DOCBODY', moodCode='EVN', realmCode=None, typeId=None, templateId=None, text=None, confidentialityCode=None, languageCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_NonXMLBody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_NonXMLBody.subclass:
            return POCD_MT000040_NonXMLBody.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_NonXMLBody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.text is not None or
            self.confidentialityCode is not None or
            self.languageCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.NonXMLBody', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.NonXMLBody')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.NonXMLBody':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.NonXMLBody')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.NonXMLBody', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.NonXMLBody'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DOCBODY" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.NonXMLBody', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
# end class POCD_MT000040_NonXMLBody


class POCD_MT000040_Observation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode=None, moodCode=None, negationInd=None, realmCode=None, typeId=None, templateId=None, id=None, code=None, derivationExpr=None, text=None, statusCode=None, effectiveTime=None, priorityCode=None, repeatNumber=None, languageCode=None, value=None, interpretationCode=None, methodCode=None, targetSiteCode=None, subject=None, specimen=None, performer=None, author=None, informant=None, participant=None, entryRelationship=None, reference=None, precondition=None, referenceRange=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.derivationExpr = derivationExpr
        self.derivationExpr_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.repeatNumber = repeatNumber
        self.repeatNumber_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = None
        if interpretationCode is None:
            self.interpretationCode = []
        else:
            self.interpretationCode = interpretationCode
        self.interpretationCode_nsprefix_ = None
        if methodCode is None:
            self.methodCode = []
        else:
            self.methodCode = methodCode
        self.methodCode_nsprefix_ = None
        if targetSiteCode is None:
            self.targetSiteCode = []
        else:
            self.targetSiteCode = targetSiteCode
        self.targetSiteCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
        if referenceRange is None:
            self.referenceRange = []
        else:
            self.referenceRange = referenceRange
        self.referenceRange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Observation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Observation.subclass:
            return POCD_MT000040_Observation.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Observation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_derivationExpr(self):
        return self.derivationExpr
    def set_derivationExpr(self, derivationExpr):
        self.derivationExpr = derivationExpr
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_repeatNumber(self):
        return self.repeatNumber
    def set_repeatNumber(self, repeatNumber):
        self.repeatNumber = repeatNumber
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def set_value_with_type(self, value):
        self.value = value
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def add_value(self, value):
        self.value.append(value)
    def add_value_with_type(self, value):
        self.value.append(value)
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_interpretationCode(self):
        return self.interpretationCode
    def set_interpretationCode(self, interpretationCode):
        self.interpretationCode = interpretationCode
    def add_interpretationCode(self, value):
        self.interpretationCode.append(value)
    def insert_interpretationCode_at(self, index, value):
        self.interpretationCode.insert(index, value)
    def replace_interpretationCode_at(self, index, value):
        self.interpretationCode[index] = value
    def get_methodCode(self):
        return self.methodCode
    def set_methodCode(self, methodCode):
        self.methodCode = methodCode
    def add_methodCode(self, value):
        self.methodCode.append(value)
    def insert_methodCode_at(self, index, value):
        self.methodCode.insert(index, value)
    def replace_methodCode_at(self, index, value):
        self.methodCode[index] = value
    def get_targetSiteCode(self):
        return self.targetSiteCode
    def set_targetSiteCode(self, targetSiteCode):
        self.targetSiteCode = targetSiteCode
    def add_targetSiteCode(self, value):
        self.targetSiteCode.append(value)
    def insert_targetSiteCode_at(self, index, value):
        self.targetSiteCode.insert(index, value)
    def replace_targetSiteCode_at(self, index, value):
        self.targetSiteCode[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_referenceRange(self):
        return self.referenceRange
    def set_referenceRange(self, referenceRange):
        self.referenceRange = referenceRange
    def add_referenceRange(self, value):
        self.referenceRange.append(value)
    def insert_referenceRange_at(self, index, value):
        self.referenceRange.insert(index, value)
    def replace_referenceRange_at(self, index, value):
        self.referenceRange[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        pass
    def validate_x_ActMoodDocumentObservation(self, value):
        # Validate type x_ActMoodDocumentObservation, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INT', 'DEF', 'EVN', 'GOL', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActMoodDocumentObservation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActMoodDocumentObservation_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActMoodDocumentObservation_patterns_, ))
    validate_x_ActMoodDocumentObservation_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.derivationExpr is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.priorityCode is not None or
            self.repeatNumber is not None or
            self.languageCode is not None or
            self.value or
            self.interpretationCode or
            self.methodCode or
            self.targetSiteCode or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition or
            self.referenceRange
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Observation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Observation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Observation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Observation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Observation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Observation'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Observation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.derivationExpr is not None:
            namespaceprefix_ = self.derivationExpr_nsprefix_ + ':' if (UseCapturedNS_ and self.derivationExpr_nsprefix_) else ''
            self.derivationExpr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='derivationExpr', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.repeatNumber is not None:
            namespaceprefix_ = self.repeatNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.repeatNumber_nsprefix_) else ''
            self.repeatNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repeatNumber', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        for value_ in self.value:
            value_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        for interpretationCode_ in self.interpretationCode:
            namespaceprefix_ = self.interpretationCode_nsprefix_ + ':' if (UseCapturedNS_ and self.interpretationCode_nsprefix_) else ''
            interpretationCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interpretationCode', pretty_print=pretty_print)
        for methodCode_ in self.methodCode:
            namespaceprefix_ = self.methodCode_nsprefix_ + ':' if (UseCapturedNS_ and self.methodCode_nsprefix_) else ''
            methodCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methodCode', pretty_print=pretty_print)
        for targetSiteCode_ in self.targetSiteCode:
            namespaceprefix_ = self.targetSiteCode_nsprefix_ + ':' if (UseCapturedNS_ and self.targetSiteCode_nsprefix_) else ''
            targetSiteCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='targetSiteCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
        for referenceRange_ in self.referenceRange:
            namespaceprefix_ = self.referenceRange_nsprefix_ + ':' if (UseCapturedNS_ and self.referenceRange_nsprefix_) else ''
            referenceRange_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='referenceRange', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_ActMoodDocumentObservation(self.moodCode)    # validate type x_ActMoodDocumentObservation
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'derivationExpr':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.derivationExpr = obj_
            obj_.original_tagname_ = 'derivationExpr'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'repeatNumber':
            obj_ = IVL_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.repeatNumber = obj_
            obj_.original_tagname_ = 'repeatNumber'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'value':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <value> element')
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'interpretationCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interpretationCode.append(obj_)
            obj_.original_tagname_ = 'interpretationCode'
        elif nodeName_ == 'methodCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methodCode.append(obj_)
            obj_.original_tagname_ = 'methodCode'
        elif nodeName_ == 'targetSiteCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.targetSiteCode.append(obj_)
            obj_.original_tagname_ = 'targetSiteCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
        elif nodeName_ == 'referenceRange':
            obj_ = POCD_MT000040_ReferenceRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.referenceRange.append(obj_)
            obj_.original_tagname_ = 'referenceRange'
# end class POCD_MT000040_Observation


class POCD_MT000040_ObservationMedia(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, nullFlavor=None, classCode=None, moodCode=None, realmCode=None, typeId=None, templateId=None, id=None, languageCode=None, value=None, subject=None, specimen=None, performer=None, author=None, informant=None, participant=None, entryRelationship=None, reference=None, precondition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ObservationMedia)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ObservationMedia.subclass:
            return POCD_MT000040_ObservationMedia.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ObservationMedia(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.languageCode is not None or
            self.value is not None or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ObservationMedia', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ObservationMedia')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ObservationMedia':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ObservationMedia')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ObservationMedia', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ObservationMedia'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ObservationMedia', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'value':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040_ObservationMedia


class POCD_MT000040_ObservationRange(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='OBS', moodCode='EVN.CRT', realmCode=None, typeId=None, templateId=None, code=None, text=None, value=None, interpretationCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.interpretationCode = interpretationCode
        self.interpretationCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ObservationRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ObservationRange.subclass:
            return POCD_MT000040_ObservationRange.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ObservationRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def set_value_with_type(self, value):
        self.value = value
        value.original_tagname_ = 'value'
        value.extensiontype_ = value.__class__.__name__
    def get_interpretationCode(self):
        return self.interpretationCode
    def set_interpretationCode(self, interpretationCode):
        self.interpretationCode = interpretationCode
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassObservation(self, value):
        # Validate type ActClassObservation, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.text is not None or
            self.value is not None or
            self.interpretationCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ObservationRange', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ObservationRange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ObservationRange':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ObservationRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ObservationRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ObservationRange'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "OBS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN.CRT" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ObservationRange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.interpretationCode is not None:
            namespaceprefix_ = self.interpretationCode_nsprefix_ + ':' if (UseCapturedNS_ and self.interpretationCode_nsprefix_) else ''
            self.interpretationCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interpretationCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassObservation(self.classCode)    # validate type ActClassObservation
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'value':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <value> element')
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'interpretationCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interpretationCode = obj_
            obj_.original_tagname_ = 'interpretationCode'
# end class POCD_MT000040_ObservationRange


class POCD_MT000040_Order(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='ACT', moodCode='RQO', realmCode=None, typeId=None, templateId=None, id=None, code=None, priorityCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Order)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Order.subclass:
            return POCD_MT000040_Order.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Order(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassRoot(self, value):
        # Validate type ActClassRoot, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.priorityCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Order', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Order')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Order':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Order')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Order', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Order'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ACT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "RQO" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Order', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassRoot(self.classCode)    # validate type ActClassRoot
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
# end class POCD_MT000040_Order


class POCD_MT000040_Organization(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='ORG', determinerCode='INSTANCE', realmCode=None, typeId=None, templateId=None, id=None, name=None, telecom=None, addr=None, standardIndustryClassCode=None, asOrganizationPartOf=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        self.standardIndustryClassCode = standardIndustryClassCode
        self.standardIndustryClassCode_nsprefix_ = None
        self.asOrganizationPartOf = asOrganizationPartOf
        self.asOrganizationPartOf_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Organization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Organization.subclass:
            return POCD_MT000040_Organization.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Organization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_standardIndustryClassCode(self):
        return self.standardIndustryClassCode
    def set_standardIndustryClassCode(self, standardIndustryClassCode):
        self.standardIndustryClassCode = standardIndustryClassCode
    def get_asOrganizationPartOf(self):
        return self.asOrganizationPartOf
    def set_asOrganizationPartOf(self, asOrganizationPartOf):
        self.asOrganizationPartOf = asOrganizationPartOf
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassOrganization(self, value):
        # Validate type EntityClassOrganization, a restriction on cs.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.name or
            self.telecom or
            self.addr or
            self.standardIndustryClassCode is not None or
            self.asOrganizationPartOf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Organization', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Organization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Organization':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Organization')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Organization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Organization'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ORG" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Organization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        if self.standardIndustryClassCode is not None:
            namespaceprefix_ = self.standardIndustryClassCode_nsprefix_ + ':' if (UseCapturedNS_ and self.standardIndustryClassCode_nsprefix_) else ''
            self.standardIndustryClassCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='standardIndustryClassCode', pretty_print=pretty_print)
        if self.asOrganizationPartOf is not None:
            namespaceprefix_ = self.asOrganizationPartOf_nsprefix_ + ':' if (UseCapturedNS_ and self.asOrganizationPartOf_nsprefix_) else ''
            self.asOrganizationPartOf.export(outfile, level, namespaceprefix_, namespacedef_='', name_='asOrganizationPartOf', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassOrganization(self.classCode)    # validate type EntityClassOrganization
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = ON.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'standardIndustryClassCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.standardIndustryClassCode = obj_
            obj_.original_tagname_ = 'standardIndustryClassCode'
        elif nodeName_ == 'asOrganizationPartOf':
            obj_ = POCD_MT000040_OrganizationPartOf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.asOrganizationPartOf = obj_
            obj_.original_tagname_ = 'asOrganizationPartOf'
# end class POCD_MT000040_Organization


class POCD_MT000040_OrganizationPartOf(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='PART', realmCode=None, typeId=None, templateId=None, id=None, code=None, statusCode=None, effectiveTime=None, wholeOrganization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.wholeOrganization = wholeOrganization
        self.wholeOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_OrganizationPartOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_OrganizationPartOf.subclass:
            return POCD_MT000040_OrganizationPartOf.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_OrganizationPartOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_wholeOrganization(self):
        return self.wholeOrganization
    def set_wholeOrganization(self, wholeOrganization):
        self.wholeOrganization = wholeOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.wholeOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.OrganizationPartOf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.OrganizationPartOf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.OrganizationPartOf':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.OrganizationPartOf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.OrganizationPartOf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.OrganizationPartOf'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PART" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.OrganizationPartOf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.wholeOrganization is not None:
            namespaceprefix_ = self.wholeOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.wholeOrganization_nsprefix_) else ''
            self.wholeOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='wholeOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'wholeOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wholeOrganization = obj_
            obj_.original_tagname_ = 'wholeOrganization'
# end class POCD_MT000040_OrganizationPartOf


class POCD_MT000040_Organizer(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode=None, moodCode=None, realmCode=None, typeId=None, templateId=None, id=None, code=None, statusCode=None, effectiveTime=None, subject=None, specimen=None, performer=None, author=None, informant=None, participant=None, reference=None, precondition=None, component=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
        if component is None:
            self.component = []
        else:
            self.component = component
        self.component_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Organizer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Organizer.subclass:
            return POCD_MT000040_Organizer.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Organizer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def add_component(self, value):
        self.component.append(value)
    def insert_component_at(self, index, value):
        self.component.insert(index, value)
    def replace_component_at(self, index, value):
        self.component[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ActClassDocumentEntryOrganizer(self, value):
        # Validate type x_ActClassDocumentEntryOrganizer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['BATTERY', 'CLUSTER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActClassDocumentEntryOrganizer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActClassDocumentEntryOrganizer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActClassDocumentEntryOrganizer_patterns_, ))
    validate_x_ActClassDocumentEntryOrganizer_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.reference or
            self.precondition or
            self.component
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Organizer', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Organizer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Organizer':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Organizer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Organizer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Organizer'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Organizer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
        for component_ in self.component:
            namespaceprefix_ = self.component_nsprefix_ + ':' if (UseCapturedNS_ and self.component_nsprefix_) else ''
            component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='component', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_x_ActClassDocumentEntryOrganizer(self.classCode)    # validate type x_ActClassDocumentEntryOrganizer
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
        elif nodeName_ == 'component':
            obj_ = POCD_MT000040_Component4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component.append(obj_)
            obj_.original_tagname_ = 'component'
# end class POCD_MT000040_Organizer


class POCD_MT000040_ParentDocument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='DOCCLIN', moodCode='EVN', realmCode=None, typeId=None, templateId=None, id=None, code=None, text=None, setId=None, versionNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.setId = setId
        self.setId_nsprefix_ = None
        self.versionNumber = versionNumber
        self.versionNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ParentDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ParentDocument.subclass:
            return POCD_MT000040_ParentDocument.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ParentDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_setId(self):
        return self.setId
    def set_setId(self, setId):
        self.setId = setId
    def get_versionNumber(self):
        return self.versionNumber
    def set_versionNumber(self, versionNumber):
        self.versionNumber = versionNumber
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClinicalDocument(self, value):
        # Validate type ActClinicalDocument, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DOCCLIN', 'CDALVLONE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClinicalDocument' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClinicalDocument_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClinicalDocument_patterns_, ))
    validate_ActClinicalDocument_patterns_ = [['^([^\\s]+)$']]
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.setId is not None or
            self.versionNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ParentDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ParentDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ParentDocument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ParentDocument')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ParentDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ParentDocument'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DOCCLIN" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ParentDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.setId is not None:
            namespaceprefix_ = self.setId_nsprefix_ + ':' if (UseCapturedNS_ and self.setId_nsprefix_) else ''
            self.setId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setId', pretty_print=pretty_print)
        if self.versionNumber is not None:
            namespaceprefix_ = self.versionNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.versionNumber_nsprefix_) else ''
            self.versionNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='versionNumber', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClinicalDocument(self.classCode)    # validate type ActClinicalDocument
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'setId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setId = obj_
            obj_.original_tagname_ = 'setId'
        elif nodeName_ == 'versionNumber':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.versionNumber = obj_
            obj_.original_tagname_ = 'versionNumber'
# end class POCD_MT000040_ParentDocument


class POCD_MT000040_Participant1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode=None, contextControlCode='OP', realmCode=None, typeId=None, templateId=None, functionCode=None, time=None, associatedEntity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.associatedEntity = associatedEntity
        self.associatedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Participant1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Participant1.subclass:
            return POCD_MT000040_Participant1.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Participant1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_associatedEntity(self):
        return self.associatedEntity
    def set_associatedEntity(self, associatedEntity):
        self.associatedEntity = associatedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.functionCode is not None or
            self.time is not None or
            self.associatedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Participant1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Participant1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Participant1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Participant1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Participant1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Participant1'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Participant1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.associatedEntity is not None:
            namespaceprefix_ = self.associatedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.associatedEntity_nsprefix_) else ''
            self.associatedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='associatedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'associatedEntity':
            obj_ = POCD_MT000040_AssociatedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.associatedEntity = obj_
            obj_.original_tagname_ = 'associatedEntity'
# end class POCD_MT000040_Participant1


class POCD_MT000040_Participant2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode=None, contextControlCode='OP', realmCode=None, typeId=None, templateId=None, time=None, awarenessCode=None, participantRole=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.awarenessCode = awarenessCode
        self.awarenessCode_nsprefix_ = None
        self.participantRole = participantRole
        self.participantRole_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Participant2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Participant2.subclass:
            return POCD_MT000040_Participant2.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Participant2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_awarenessCode(self):
        return self.awarenessCode
    def set_awarenessCode(self, awarenessCode):
        self.awarenessCode = awarenessCode
    def get_participantRole(self):
        return self.participantRole
    def set_participantRole(self, participantRole):
        self.participantRole = participantRole
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.awarenessCode is not None or
            self.participantRole is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Participant2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Participant2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Participant2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Participant2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Participant2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Participant2'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Participant2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.awarenessCode is not None:
            namespaceprefix_ = self.awarenessCode_nsprefix_ + ':' if (UseCapturedNS_ and self.awarenessCode_nsprefix_) else ''
            self.awarenessCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='awarenessCode', pretty_print=pretty_print)
        if self.participantRole is not None:
            namespaceprefix_ = self.participantRole_nsprefix_ + ':' if (UseCapturedNS_ and self.participantRole_nsprefix_) else ''
            self.participantRole.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participantRole', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'awarenessCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.awarenessCode = obj_
            obj_.original_tagname_ = 'awarenessCode'
        elif nodeName_ == 'participantRole':
            obj_ = POCD_MT000040_ParticipantRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participantRole = obj_
            obj_.original_tagname_ = 'participantRole'
# end class POCD_MT000040_Participant2


class POCD_MT000040_ParticipantRole(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='ROL', realmCode=None, typeId=None, templateId=None, id=None, code=None, addr=None, telecom=None, playingDevice=None, playingEntity=None, scopingEntity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.playingDevice = playingDevice
        self.playingDevice_nsprefix_ = None
        self.playingEntity = playingEntity
        self.playingEntity_nsprefix_ = None
        self.scopingEntity = scopingEntity
        self.scopingEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ParticipantRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ParticipantRole.subclass:
            return POCD_MT000040_ParticipantRole.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ParticipantRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_playingDevice(self):
        return self.playingDevice
    def set_playingDevice(self, playingDevice):
        self.playingDevice = playingDevice
    def get_playingEntity(self):
        return self.playingEntity
    def set_playingEntity(self, playingEntity):
        self.playingEntity = playingEntity
    def get_scopingEntity(self):
        return self.scopingEntity
    def set_scopingEntity(self, scopingEntity):
        self.scopingEntity = scopingEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassRoot(self, value):
        # Validate type RoleClassRoot, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.addr or
            self.telecom or
            self.playingDevice is not None or
            self.playingEntity is not None or
            self.scopingEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ParticipantRole', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ParticipantRole')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ParticipantRole':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ParticipantRole')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ParticipantRole', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ParticipantRole'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ROL" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ParticipantRole', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.playingDevice is not None:
            namespaceprefix_ = self.playingDevice_nsprefix_ + ':' if (UseCapturedNS_ and self.playingDevice_nsprefix_) else ''
            self.playingDevice.export(outfile, level, namespaceprefix_, namespacedef_='', name_='playingDevice', pretty_print=pretty_print)
        if self.playingEntity is not None:
            namespaceprefix_ = self.playingEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.playingEntity_nsprefix_) else ''
            self.playingEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='playingEntity', pretty_print=pretty_print)
        if self.scopingEntity is not None:
            namespaceprefix_ = self.scopingEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.scopingEntity_nsprefix_) else ''
            self.scopingEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scopingEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassRoot(self.classCode)    # validate type RoleClassRoot
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'playingDevice':
            obj_ = POCD_MT000040_Device.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.playingDevice = obj_
            obj_.original_tagname_ = 'playingDevice'
        elif nodeName_ == 'playingEntity':
            obj_ = POCD_MT000040_PlayingEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.playingEntity = obj_
            obj_.original_tagname_ = 'playingEntity'
        elif nodeName_ == 'scopingEntity':
            obj_ = POCD_MT000040_Entity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scopingEntity = obj_
            obj_.original_tagname_ = 'scopingEntity'
# end class POCD_MT000040_ParticipantRole


class POCD_MT000040_Patient(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='PSN', determinerCode='INSTANCE', realmCode=None, typeId=None, templateId=None, id=None, name=None, administrativeGenderCode=None, birthTime=None, maritalStatusCode=None, religiousAffiliationCode=None, raceCode=None, ethnicGroupCode=None, guardian=None, birthplace=None, languageCommunication=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.administrativeGenderCode = administrativeGenderCode
        self.administrativeGenderCode_nsprefix_ = None
        self.birthTime = birthTime
        self.birthTime_nsprefix_ = None
        self.maritalStatusCode = maritalStatusCode
        self.maritalStatusCode_nsprefix_ = None
        self.religiousAffiliationCode = religiousAffiliationCode
        self.religiousAffiliationCode_nsprefix_ = None
        self.raceCode = raceCode
        self.raceCode_nsprefix_ = None
        self.ethnicGroupCode = ethnicGroupCode
        self.ethnicGroupCode_nsprefix_ = None
        if guardian is None:
            self.guardian = []
        else:
            self.guardian = guardian
        self.guardian_nsprefix_ = None
        self.birthplace = birthplace
        self.birthplace_nsprefix_ = None
        if languageCommunication is None:
            self.languageCommunication = []
        else:
            self.languageCommunication = languageCommunication
        self.languageCommunication_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Patient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Patient.subclass:
            return POCD_MT000040_Patient.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Patient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_administrativeGenderCode(self):
        return self.administrativeGenderCode
    def set_administrativeGenderCode(self, administrativeGenderCode):
        self.administrativeGenderCode = administrativeGenderCode
    def get_birthTime(self):
        return self.birthTime
    def set_birthTime(self, birthTime):
        self.birthTime = birthTime
    def get_maritalStatusCode(self):
        return self.maritalStatusCode
    def set_maritalStatusCode(self, maritalStatusCode):
        self.maritalStatusCode = maritalStatusCode
    def get_religiousAffiliationCode(self):
        return self.religiousAffiliationCode
    def set_religiousAffiliationCode(self, religiousAffiliationCode):
        self.religiousAffiliationCode = religiousAffiliationCode
    def get_raceCode(self):
        return self.raceCode
    def set_raceCode(self, raceCode):
        self.raceCode = raceCode
    def get_ethnicGroupCode(self):
        return self.ethnicGroupCode
    def set_ethnicGroupCode(self, ethnicGroupCode):
        self.ethnicGroupCode = ethnicGroupCode
    def get_guardian(self):
        return self.guardian
    def set_guardian(self, guardian):
        self.guardian = guardian
    def add_guardian(self, value):
        self.guardian.append(value)
    def insert_guardian_at(self, index, value):
        self.guardian.insert(index, value)
    def replace_guardian_at(self, index, value):
        self.guardian[index] = value
    def get_birthplace(self):
        return self.birthplace
    def set_birthplace(self, birthplace):
        self.birthplace = birthplace
    def get_languageCommunication(self):
        return self.languageCommunication
    def set_languageCommunication(self, languageCommunication):
        self.languageCommunication = languageCommunication
    def add_languageCommunication(self, value):
        self.languageCommunication.append(value)
    def insert_languageCommunication_at(self, index, value):
        self.languageCommunication.insert(index, value)
    def replace_languageCommunication_at(self, index, value):
        self.languageCommunication[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on None.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.name or
            self.administrativeGenderCode is not None or
            self.birthTime is not None or
            self.maritalStatusCode is not None or
            self.religiousAffiliationCode is not None or
            self.raceCode is not None or
            self.ethnicGroupCode is not None or
            self.guardian or
            self.birthplace is not None or
            self.languageCommunication
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Patient', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Patient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Patient':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Patient')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Patient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Patient'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PSN" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Patient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.administrativeGenderCode is not None:
            namespaceprefix_ = self.administrativeGenderCode_nsprefix_ + ':' if (UseCapturedNS_ and self.administrativeGenderCode_nsprefix_) else ''
            self.administrativeGenderCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='administrativeGenderCode', pretty_print=pretty_print)
        if self.birthTime is not None:
            namespaceprefix_ = self.birthTime_nsprefix_ + ':' if (UseCapturedNS_ and self.birthTime_nsprefix_) else ''
            self.birthTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='birthTime', pretty_print=pretty_print)
        if self.maritalStatusCode is not None:
            namespaceprefix_ = self.maritalStatusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.maritalStatusCode_nsprefix_) else ''
            self.maritalStatusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maritalStatusCode', pretty_print=pretty_print)
        if self.religiousAffiliationCode is not None:
            namespaceprefix_ = self.religiousAffiliationCode_nsprefix_ + ':' if (UseCapturedNS_ and self.religiousAffiliationCode_nsprefix_) else ''
            self.religiousAffiliationCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='religiousAffiliationCode', pretty_print=pretty_print)
        if self.raceCode is not None:
            namespaceprefix_ = self.raceCode_nsprefix_ + ':' if (UseCapturedNS_ and self.raceCode_nsprefix_) else ''
            self.raceCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='raceCode', pretty_print=pretty_print)
        if self.ethnicGroupCode is not None:
            namespaceprefix_ = self.ethnicGroupCode_nsprefix_ + ':' if (UseCapturedNS_ and self.ethnicGroupCode_nsprefix_) else ''
            self.ethnicGroupCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ethnicGroupCode', pretty_print=pretty_print)
        for guardian_ in self.guardian:
            namespaceprefix_ = self.guardian_nsprefix_ + ':' if (UseCapturedNS_ and self.guardian_nsprefix_) else ''
            guardian_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='guardian', pretty_print=pretty_print)
        if self.birthplace is not None:
            namespaceprefix_ = self.birthplace_nsprefix_ + ':' if (UseCapturedNS_ and self.birthplace_nsprefix_) else ''
            self.birthplace.export(outfile, level, namespaceprefix_, namespacedef_='', name_='birthplace', pretty_print=pretty_print)
        for languageCommunication_ in self.languageCommunication:
            namespaceprefix_ = self.languageCommunication_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCommunication_nsprefix_) else ''
            languageCommunication_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCommunication', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = PN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'administrativeGenderCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.administrativeGenderCode = obj_
            obj_.original_tagname_ = 'administrativeGenderCode'
        elif nodeName_ == 'birthTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.birthTime = obj_
            obj_.original_tagname_ = 'birthTime'
        elif nodeName_ == 'maritalStatusCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maritalStatusCode = obj_
            obj_.original_tagname_ = 'maritalStatusCode'
        elif nodeName_ == 'religiousAffiliationCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.religiousAffiliationCode = obj_
            obj_.original_tagname_ = 'religiousAffiliationCode'
        elif nodeName_ == 'raceCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.raceCode = obj_
            obj_.original_tagname_ = 'raceCode'
        elif nodeName_ == 'ethnicGroupCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ethnicGroupCode = obj_
            obj_.original_tagname_ = 'ethnicGroupCode'
        elif nodeName_ == 'guardian':
            obj_ = POCD_MT000040_Guardian.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.guardian.append(obj_)
            obj_.original_tagname_ = 'guardian'
        elif nodeName_ == 'birthplace':
            obj_ = POCD_MT000040_Birthplace.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.birthplace = obj_
            obj_.original_tagname_ = 'birthplace'
        elif nodeName_ == 'languageCommunication':
            obj_ = POCD_MT000040_LanguageCommunication.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCommunication.append(obj_)
            obj_.original_tagname_ = 'languageCommunication'
# end class POCD_MT000040_Patient


class POCD_MT000040_PatientRole(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='PAT', realmCode=None, typeId=None, templateId=None, id=None, addr=None, telecom=None, patient=None, providerOrganization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.patient = patient
        self.patient_nsprefix_ = None
        self.providerOrganization = providerOrganization
        self.providerOrganization_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_PatientRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_PatientRole.subclass:
            return POCD_MT000040_PatientRole.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_PatientRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_patient(self):
        return self.patient
    def set_patient(self, patient):
        self.patient = patient
    def get_providerOrganization(self):
        return self.providerOrganization
    def set_providerOrganization(self, providerOrganization):
        self.providerOrganization = providerOrganization
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClass(self, value):
        # Validate type RoleClass, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.addr or
            self.telecom or
            self.patient is not None or
            self.providerOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.PatientRole', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.PatientRole')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.PatientRole':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.PatientRole')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.PatientRole', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.PatientRole'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PAT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.PatientRole', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.patient is not None:
            namespaceprefix_ = self.patient_nsprefix_ + ':' if (UseCapturedNS_ and self.patient_nsprefix_) else ''
            self.patient.export(outfile, level, namespaceprefix_, namespacedef_='', name_='patient', pretty_print=pretty_print)
        if self.providerOrganization is not None:
            namespaceprefix_ = self.providerOrganization_nsprefix_ + ':' if (UseCapturedNS_ and self.providerOrganization_nsprefix_) else ''
            self.providerOrganization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='providerOrganization', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_RoleClass(self.classCode)    # validate type RoleClass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'patient':
            obj_ = POCD_MT000040_Patient.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.patient = obj_
            obj_.original_tagname_ = 'patient'
        elif nodeName_ == 'providerOrganization':
            obj_ = POCD_MT000040_Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.providerOrganization = obj_
            obj_.original_tagname_ = 'providerOrganization'
# end class POCD_MT000040_PatientRole


class POCD_MT000040_Performer1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode=None, realmCode=None, typeId=None, templateId=None, functionCode=None, time=None, assignedEntity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Performer1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Performer1.subclass:
            return POCD_MT000040_Performer1.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Performer1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ServiceEventPerformer(self, value):
        # Validate type x_ServiceEventPerformer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PRF', 'PPRF', 'SPRF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ServiceEventPerformer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ServiceEventPerformer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ServiceEventPerformer_patterns_, ))
    validate_x_ServiceEventPerformer_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.functionCode is not None or
            self.time is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Performer1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Performer1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Performer1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Performer1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Performer1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Performer1'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Performer1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ServiceEventPerformer(self.typeCode)    # validate type x_ServiceEventPerformer
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_Performer1


class POCD_MT000040_Performer2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='PRF', realmCode=None, typeId=None, templateId=None, time=None, modeCode=None, assignedEntity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.time = time
        self.time_nsprefix_ = None
        self.modeCode = modeCode
        self.modeCode_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Performer2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Performer2.subclass:
            return POCD_MT000040_Performer2.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Performer2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_modeCode(self):
        return self.modeCode
    def set_modeCode(self, modeCode):
        self.modeCode = modeCode
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationPhysicalPerformer(self, value):
        # Validate type ParticipationPhysicalPerformer, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PRF', 'DIST', 'PPRF', 'SPRF']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationPhysicalPerformer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationPhysicalPerformer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationPhysicalPerformer_patterns_, ))
    validate_ParticipationPhysicalPerformer_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.time is not None or
            self.modeCode is not None or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Performer2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Performer2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Performer2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Performer2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Performer2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Performer2'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "PRF" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Performer2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.time is not None:
            namespaceprefix_ = self.time_nsprefix_ + ':' if (UseCapturedNS_ and self.time_nsprefix_) else ''
            self.time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time', pretty_print=pretty_print)
        if self.modeCode is not None:
            namespaceprefix_ = self.modeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.modeCode_nsprefix_) else ''
            self.modeCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='modeCode', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationPhysicalPerformer(self.typeCode)    # validate type ParticipationPhysicalPerformer
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'time':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'modeCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modeCode = obj_
            obj_.original_tagname_ = 'modeCode'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_Performer2


class POCD_MT000040_Person(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='PSN', determinerCode='INSTANCE', realmCode=None, typeId=None, templateId=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Person)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Person.subclass:
            return POCD_MT000040_Person.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Person(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on None.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.name
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Person', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Person')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Person':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Person')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Person', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Person'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PSN" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Person', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'name':
            obj_ = PN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
# end class POCD_MT000040_Person


class POCD_MT000040_Place(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='PLC', determinerCode='INSTANCE', realmCode=None, typeId=None, templateId=None, name=None, addr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.addr = addr
        self.addr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Place)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Place.subclass:
            return POCD_MT000040_Place.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Place(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassPlace(self, value):
        # Validate type EntityClassPlace, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PLC', 'CITY', 'COUNTRY', 'COUNTY', 'PROVINCE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EntityClassPlace' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityClassPlace_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityClassPlace_patterns_, ))
    validate_EntityClassPlace_patterns_ = [['^([^\\s]+)$']]
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.name is not None or
            self.addr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Place', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Place')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Place':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Place')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Place', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Place'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PLC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Place', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.addr is not None:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            self.addr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassPlace(self.classCode)    # validate type EntityClassPlace
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, EN)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr = obj_
            obj_.original_tagname_ = 'addr'
# end class POCD_MT000040_Place


class POCD_MT000040_PlayingEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='ENT', determinerCode='INSTANCE', realmCode=None, typeId=None, templateId=None, code=None, quantity=None, name=None, desc=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
        self.quantity_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.desc = desc
        self.desc_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_PlayingEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_PlayingEntity.subclass:
            return POCD_MT000040_PlayingEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_PlayingEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def add_quantity(self, value):
        self.quantity.append(value)
    def insert_quantity_at(self, index, value):
        self.quantity.insert(index, value)
    def replace_quantity_at(self, index, value):
        self.quantity[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_desc(self):
        return self.desc
    def set_desc(self, desc):
        self.desc = desc
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClassRoot(self, value):
        # Validate type EntityClassRoot, a restriction on cs.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.quantity or
            self.name or
            self.desc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.PlayingEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.PlayingEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.PlayingEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.PlayingEntity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.PlayingEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.PlayingEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ENT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.PlayingEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for quantity_ in self.quantity:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            quantity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantity', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.desc is not None:
            namespaceprefix_ = self.desc_nsprefix_ + ':' if (UseCapturedNS_ and self.desc_nsprefix_) else ''
            self.desc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='desc', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_EntityClassRoot(self.classCode)    # validate type EntityClassRoot
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'quantity':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantity.append(obj_)
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'name':
            obj_ = PN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'desc':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.desc = obj_
            obj_.original_tagname_ = 'desc'
# end class POCD_MT000040_PlayingEntity


class POCD_MT000040_Precondition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='PRCN', realmCode=None, typeId=None, templateId=None, criterion=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.criterion = criterion
        self.criterion_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Precondition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Precondition.subclass:
            return POCD_MT000040_Precondition.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Precondition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_criterion(self):
        return self.criterion
    def set_criterion(self, criterion):
        self.criterion = criterion
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.criterion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Precondition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Precondition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Precondition':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Precondition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Precondition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Precondition'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "PRCN" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Precondition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.criterion is not None:
            namespaceprefix_ = self.criterion_nsprefix_ + ':' if (UseCapturedNS_ and self.criterion_nsprefix_) else ''
            self.criterion.export(outfile, level, namespaceprefix_, namespacedef_='', name_='criterion', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'criterion':
            obj_ = POCD_MT000040_Criterion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.criterion = obj_
            obj_.original_tagname_ = 'criterion'
# end class POCD_MT000040_Precondition


class POCD_MT000040_Procedure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode=None, moodCode=None, negationInd=None, realmCode=None, typeId=None, templateId=None, id=None, code=None, text=None, statusCode=None, effectiveTime=None, priorityCode=None, languageCode=None, methodCode=None, approachSiteCode=None, targetSiteCode=None, subject=None, specimen=None, performer=None, author=None, informant=None, participant=None, entryRelationship=None, reference=None, precondition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        if methodCode is None:
            self.methodCode = []
        else:
            self.methodCode = methodCode
        self.methodCode_nsprefix_ = None
        if approachSiteCode is None:
            self.approachSiteCode = []
        else:
            self.approachSiteCode = approachSiteCode
        self.approachSiteCode_nsprefix_ = None
        if targetSiteCode is None:
            self.targetSiteCode = []
        else:
            self.targetSiteCode = targetSiteCode
        self.targetSiteCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Procedure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Procedure.subclass:
            return POCD_MT000040_Procedure.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Procedure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_methodCode(self):
        return self.methodCode
    def set_methodCode(self, methodCode):
        self.methodCode = methodCode
    def add_methodCode(self, value):
        self.methodCode.append(value)
    def insert_methodCode_at(self, index, value):
        self.methodCode.insert(index, value)
    def replace_methodCode_at(self, index, value):
        self.methodCode[index] = value
    def get_approachSiteCode(self):
        return self.approachSiteCode
    def set_approachSiteCode(self, approachSiteCode):
        self.approachSiteCode = approachSiteCode
    def add_approachSiteCode(self, value):
        self.approachSiteCode.append(value)
    def insert_approachSiteCode_at(self, index, value):
        self.approachSiteCode.insert(index, value)
    def replace_approachSiteCode_at(self, index, value):
        self.approachSiteCode[index] = value
    def get_targetSiteCode(self):
        return self.targetSiteCode
    def set_targetSiteCode(self, targetSiteCode):
        self.targetSiteCode = targetSiteCode
    def add_targetSiteCode(self, value):
        self.targetSiteCode.append(value)
    def insert_targetSiteCode_at(self, index, value):
        self.targetSiteCode.insert(index, value)
    def replace_targetSiteCode_at(self, index, value):
        self.targetSiteCode[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_x_DocumentProcedureMood(self, value):
        # Validate type x_DocumentProcedureMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INT', 'APT', 'ARQ', 'DEF', 'EVN', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentProcedureMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentProcedureMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentProcedureMood_patterns_, ))
    validate_x_DocumentProcedureMood_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime is not None or
            self.priorityCode is not None or
            self.languageCode is not None or
            self.methodCode or
            self.approachSiteCode or
            self.targetSiteCode or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Procedure', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Procedure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Procedure':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Procedure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Procedure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Procedure'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Procedure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        for methodCode_ in self.methodCode:
            namespaceprefix_ = self.methodCode_nsprefix_ + ':' if (UseCapturedNS_ and self.methodCode_nsprefix_) else ''
            methodCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='methodCode', pretty_print=pretty_print)
        for approachSiteCode_ in self.approachSiteCode:
            namespaceprefix_ = self.approachSiteCode_nsprefix_ + ':' if (UseCapturedNS_ and self.approachSiteCode_nsprefix_) else ''
            approachSiteCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='approachSiteCode', pretty_print=pretty_print)
        for targetSiteCode_ in self.targetSiteCode:
            namespaceprefix_ = self.targetSiteCode_nsprefix_ + ':' if (UseCapturedNS_ and self.targetSiteCode_nsprefix_) else ''
            targetSiteCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='targetSiteCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentProcedureMood(self.moodCode)    # validate type x_DocumentProcedureMood
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'methodCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.methodCode.append(obj_)
            obj_.original_tagname_ = 'methodCode'
        elif nodeName_ == 'approachSiteCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.approachSiteCode.append(obj_)
            obj_.original_tagname_ = 'approachSiteCode'
        elif nodeName_ == 'targetSiteCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.targetSiteCode.append(obj_)
            obj_.original_tagname_ = 'targetSiteCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040_Procedure


class POCD_MT000040_Product(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='PRD', realmCode=None, typeId=None, templateId=None, manufacturedProduct=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.manufacturedProduct = manufacturedProduct
        self.manufacturedProduct_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Product)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Product.subclass:
            return POCD_MT000040_Product.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Product(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_manufacturedProduct(self):
        return self.manufacturedProduct
    def set_manufacturedProduct(self, manufacturedProduct):
        self.manufacturedProduct = manufacturedProduct
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.manufacturedProduct is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Product', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Product')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Product':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Product')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Product', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Product'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "PRD" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Product', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.manufacturedProduct is not None:
            namespaceprefix_ = self.manufacturedProduct_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturedProduct_nsprefix_) else ''
            self.manufacturedProduct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturedProduct', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'manufacturedProduct':
            obj_ = POCD_MT000040_ManufacturedProduct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturedProduct = obj_
            obj_.original_tagname_ = 'manufacturedProduct'
# end class POCD_MT000040_Product


class POCD_MT000040_RecordTarget(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='RCT', contextControlCode='OP', realmCode=None, typeId=None, templateId=None, patientRole=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.patientRole = patientRole
        self.patientRole_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_RecordTarget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_RecordTarget.subclass:
            return POCD_MT000040_RecordTarget.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_RecordTarget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_patientRole(self):
        return self.patientRole
    def set_patientRole(self, patientRole):
        self.patientRole = patientRole
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.patientRole is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RecordTarget', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.RecordTarget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.RecordTarget':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RecordTarget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.RecordTarget', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.RecordTarget'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "RCT" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RecordTarget', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.patientRole is not None:
            namespaceprefix_ = self.patientRole_nsprefix_ + ':' if (UseCapturedNS_ and self.patientRole_nsprefix_) else ''
            self.patientRole.export(outfile, level, namespaceprefix_, namespacedef_='', name_='patientRole', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'patientRole':
            obj_ = POCD_MT000040_PatientRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.patientRole = obj_
            obj_.original_tagname_ = 'patientRole'
# end class POCD_MT000040_RecordTarget


class POCD_MT000040_Reference(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode=None, realmCode=None, typeId=None, templateId=None, seperatableInd=None, externalAct=None, externalObservation=None, externalProcedure=None, externalDocument=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.seperatableInd = seperatableInd
        self.seperatableInd_nsprefix_ = None
        self.externalAct = externalAct
        self.externalAct_nsprefix_ = None
        self.externalObservation = externalObservation
        self.externalObservation_nsprefix_ = None
        self.externalProcedure = externalProcedure
        self.externalProcedure_nsprefix_ = None
        self.externalDocument = externalDocument
        self.externalDocument_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Reference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Reference.subclass:
            return POCD_MT000040_Reference.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_seperatableInd(self):
        return self.seperatableInd
    def set_seperatableInd(self, seperatableInd):
        self.seperatableInd = seperatableInd
    def get_externalAct(self):
        return self.externalAct
    def set_externalAct(self, externalAct):
        self.externalAct = externalAct
    def get_externalObservation(self):
        return self.externalObservation
    def set_externalObservation(self, externalObservation):
        self.externalObservation = externalObservation
    def get_externalProcedure(self):
        return self.externalProcedure
    def set_externalProcedure(self, externalProcedure):
        self.externalProcedure = externalProcedure
    def get_externalDocument(self):
        return self.externalDocument
    def set_externalDocument(self, externalDocument):
        self.externalDocument = externalDocument
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ActRelationshipExternalReference(self, value):
        # Validate type x_ActRelationshipExternalReference, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['XCRPT', 'RPLC', 'SPRT', 'ELNK', 'REFR', 'SUBJ']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActRelationshipExternalReference' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActRelationshipExternalReference_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActRelationshipExternalReference_patterns_, ))
    validate_x_ActRelationshipExternalReference_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.seperatableInd is not None or
            self.externalAct is not None or
            self.externalObservation is not None or
            self.externalProcedure is not None or
            self.externalDocument is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Reference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Reference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Reference':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Reference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Reference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Reference'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Reference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.seperatableInd is not None:
            namespaceprefix_ = self.seperatableInd_nsprefix_ + ':' if (UseCapturedNS_ and self.seperatableInd_nsprefix_) else ''
            self.seperatableInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='seperatableInd', pretty_print=pretty_print)
        if self.externalAct is not None:
            namespaceprefix_ = self.externalAct_nsprefix_ + ':' if (UseCapturedNS_ and self.externalAct_nsprefix_) else ''
            self.externalAct.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externalAct', pretty_print=pretty_print)
        if self.externalObservation is not None:
            namespaceprefix_ = self.externalObservation_nsprefix_ + ':' if (UseCapturedNS_ and self.externalObservation_nsprefix_) else ''
            self.externalObservation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externalObservation', pretty_print=pretty_print)
        if self.externalProcedure is not None:
            namespaceprefix_ = self.externalProcedure_nsprefix_ + ':' if (UseCapturedNS_ and self.externalProcedure_nsprefix_) else ''
            self.externalProcedure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externalProcedure', pretty_print=pretty_print)
        if self.externalDocument is not None:
            namespaceprefix_ = self.externalDocument_nsprefix_ + ':' if (UseCapturedNS_ and self.externalDocument_nsprefix_) else ''
            self.externalDocument.export(outfile, level, namespaceprefix_, namespacedef_='', name_='externalDocument', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ActRelationshipExternalReference(self.typeCode)    # validate type x_ActRelationshipExternalReference
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'seperatableInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.seperatableInd = obj_
            obj_.original_tagname_ = 'seperatableInd'
        elif nodeName_ == 'externalAct':
            obj_ = POCD_MT000040_ExternalAct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalAct = obj_
            obj_.original_tagname_ = 'externalAct'
        elif nodeName_ == 'externalObservation':
            obj_ = POCD_MT000040_ExternalObservation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalObservation = obj_
            obj_.original_tagname_ = 'externalObservation'
        elif nodeName_ == 'externalProcedure':
            obj_ = POCD_MT000040_ExternalProcedure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalProcedure = obj_
            obj_.original_tagname_ = 'externalProcedure'
        elif nodeName_ == 'externalDocument':
            obj_ = POCD_MT000040_ExternalDocument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalDocument = obj_
            obj_.original_tagname_ = 'externalDocument'
# end class POCD_MT000040_Reference


class POCD_MT000040_ReferenceRange(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='REFV', realmCode=None, typeId=None, templateId=None, observationRange=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.observationRange = observationRange
        self.observationRange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ReferenceRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ReferenceRange.subclass:
            return POCD_MT000040_ReferenceRange.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ReferenceRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_observationRange(self):
        return self.observationRange
    def set_observationRange(self, observationRange):
        self.observationRange = observationRange
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActRelationshipType(self, value):
        # Validate type ActRelationshipType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.observationRange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ReferenceRange', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ReferenceRange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ReferenceRange':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ReferenceRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ReferenceRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ReferenceRange'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "REFV" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ReferenceRange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.observationRange is not None:
            namespaceprefix_ = self.observationRange_nsprefix_ + ':' if (UseCapturedNS_ and self.observationRange_nsprefix_) else ''
            self.observationRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='observationRange', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.validate_ActRelationshipType(self.typeCode)    # validate type ActRelationshipType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'observationRange':
            obj_ = POCD_MT000040_ObservationRange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.observationRange = obj_
            obj_.original_tagname_ = 'observationRange'
# end class POCD_MT000040_ReferenceRange


class POCD_MT000040_RegionOfInterest(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, nullFlavor=None, classCode='ROIOVL', moodCode='EVN', realmCode=None, typeId=None, templateId=None, id=None, code=None, value=None, subject=None, specimen=None, performer=None, author=None, informant=None, participant=None, entryRelationship=None, reference=None, precondition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_RegionOfInterest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_RegionOfInterest.subclass:
            return POCD_MT000040_RegionOfInterest.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_RegionOfInterest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def add_value(self, value):
        self.value.append(value)
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.value or
            self.subject is not None or
            self.specimen or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RegionOfInterest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.RegionOfInterest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.RegionOfInterest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RegionOfInterest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.RegionOfInterest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.RegionOfInterest'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RegionOfInterest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for value_ in self.value:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'value':
            obj_ = POCD_MT000040_RegionOfInterest_value.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040_RegionOfInterest


class POCD_MT000040_RelatedDocument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode=None, realmCode=None, typeId=None, templateId=None, parentDocument=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.parentDocument = parentDocument
        self.parentDocument_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_RelatedDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_RelatedDocument.subclass:
            return POCD_MT000040_RelatedDocument.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_RelatedDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_parentDocument(self):
        return self.parentDocument
    def set_parentDocument(self, parentDocument):
        self.parentDocument = parentDocument
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_ActRelationshipDocument(self, value):
        # Validate type x_ActRelationshipDocument, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RPLC', 'APND', 'XFRM']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_ActRelationshipDocument' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_ActRelationshipDocument_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_ActRelationshipDocument_patterns_, ))
    validate_x_ActRelationshipDocument_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.parentDocument is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RelatedDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.RelatedDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.RelatedDocument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RelatedDocument')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.RelatedDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.RelatedDocument'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RelatedDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.parentDocument is not None:
            namespaceprefix_ = self.parentDocument_nsprefix_ + ':' if (UseCapturedNS_ and self.parentDocument_nsprefix_) else ''
            self.parentDocument.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parentDocument', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_x_ActRelationshipDocument(self.typeCode)    # validate type x_ActRelationshipDocument
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'parentDocument':
            obj_ = POCD_MT000040_ParentDocument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parentDocument = obj_
            obj_.original_tagname_ = 'parentDocument'
# end class POCD_MT000040_RelatedDocument


class POCD_MT000040_RelatedEntity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode=None, realmCode=None, typeId=None, templateId=None, code=None, addr=None, telecom=None, effectiveTime=None, relatedPerson=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.relatedPerson = relatedPerson
        self.relatedPerson_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_RelatedEntity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_RelatedEntity.subclass:
            return POCD_MT000040_RelatedEntity.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_RelatedEntity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_relatedPerson(self):
        return self.relatedPerson
    def set_relatedPerson(self, relatedPerson):
        self.relatedPerson = relatedPerson
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassMutualRelationship(self, value):
        # Validate type RoleClassMutualRelationship, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.addr or
            self.telecom or
            self.effectiveTime is not None or
            self.relatedPerson is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RelatedEntity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.RelatedEntity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.RelatedEntity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RelatedEntity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.RelatedEntity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.RelatedEntity'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RelatedEntity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.relatedPerson is not None:
            namespaceprefix_ = self.relatedPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedPerson_nsprefix_) else ''
            self.relatedPerson.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedPerson', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassMutualRelationship(self.classCode)    # validate type RoleClassMutualRelationship
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'relatedPerson':
            obj_ = POCD_MT000040_Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedPerson = obj_
            obj_.original_tagname_ = 'relatedPerson'
# end class POCD_MT000040_RelatedEntity


class POCD_MT000040_RelatedSubject(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='PRS', realmCode=None, typeId=None, templateId=None, code=None, addr=None, telecom=None, subject=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        self.addr_nsprefix_ = None
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.telecom_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_RelatedSubject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_RelatedSubject.subclass:
            return POCD_MT000040_RelatedSubject.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_RelatedSubject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_addr(self):
        return self.addr
    def set_addr(self, addr):
        self.addr = addr
    def add_addr(self, value):
        self.addr.append(value)
    def insert_addr_at(self, index, value):
        self.addr.insert(index, value)
    def replace_addr_at(self, index, value):
        self.addr[index] = value
    def get_telecom(self):
        return self.telecom
    def set_telecom(self, telecom):
        self.telecom = telecom
    def add_telecom(self, value):
        self.telecom.append(value)
    def insert_telecom_at(self, index, value):
        self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value):
        self.telecom[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_x_DocumentSubject(self, value):
        # Validate type x_DocumentSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PAT', 'PRS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentSubject_patterns_, ))
    validate_x_DocumentSubject_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.addr or
            self.telecom or
            self.subject is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RelatedSubject', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.RelatedSubject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.RelatedSubject':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RelatedSubject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.RelatedSubject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.RelatedSubject'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PRS" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.RelatedSubject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        for addr_ in self.addr:
            namespaceprefix_ = self.addr_nsprefix_ + ':' if (UseCapturedNS_ and self.addr_nsprefix_) else ''
            addr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            namespaceprefix_ = self.telecom_nsprefix_ + ':' if (UseCapturedNS_ and self.telecom_nsprefix_) else ''
            telecom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='telecom', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_x_DocumentSubject(self.classCode)    # validate type x_DocumentSubject
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'addr':
            obj_ = AD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_SubjectPerson.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
# end class POCD_MT000040_RelatedSubject


class POCD_MT000040_ResponsibleParty(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='RESP', realmCode=None, typeId=None, templateId=None, assignedEntity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.assignedEntity = assignedEntity
        self.assignedEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ResponsibleParty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ResponsibleParty.subclass:
            return POCD_MT000040_ResponsibleParty.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ResponsibleParty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_assignedEntity(self):
        return self.assignedEntity
    def set_assignedEntity(self, assignedEntity):
        self.assignedEntity = assignedEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.assignedEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ResponsibleParty', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ResponsibleParty')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ResponsibleParty':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ResponsibleParty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ResponsibleParty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ResponsibleParty'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "RESP" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ResponsibleParty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.assignedEntity is not None:
            namespaceprefix_ = self.assignedEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.assignedEntity_nsprefix_) else ''
            self.assignedEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assignedEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'assignedEntity':
            obj_ = POCD_MT000040_AssignedEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assignedEntity = obj_
            obj_.original_tagname_ = 'assignedEntity'
# end class POCD_MT000040_ResponsibleParty


class POCD_MT000040_Section(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, nullFlavor=None, classCode='DOCSECT', moodCode='EVN', realmCode=None, typeId=None, templateId=None, id=None, code=None, title=None, text=None, confidentialityCode=None, languageCode=None, subject=None, author=None, informant=None, entry=None, component=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if entry is None:
            self.entry = []
        else:
            self.entry = entry
        self.entry_nsprefix_ = None
        if component is None:
            self.component = []
        else:
            self.component = component
        self.component_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Section)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Section.subclass:
            return POCD_MT000040_Section.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Section(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_entry(self):
        return self.entry
    def set_entry(self, entry):
        self.entry = entry
    def add_entry(self, value):
        self.entry.append(value)
    def insert_entry_at(self, index, value):
        self.entry.insert(index, value)
    def replace_entry_at(self, index, value):
        self.entry[index] = value
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def add_component(self, value):
        self.component.append(value)
    def insert_component_at(self, index, value):
        self.component.insert(index, value)
    def replace_component_at(self, index, value):
        self.component[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.code is not None or
            self.title is not None or
            self.text is not None or
            self.confidentialityCode is not None or
            self.languageCode is not None or
            self.subject is not None or
            self.author or
            self.informant or
            self.entry or
            self.component
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Section', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Section')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Section':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Section')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Section', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Section'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DOCSECT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Section', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            self.id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for entry_ in self.entry:
            namespaceprefix_ = self.entry_nsprefix_ + ':' if (UseCapturedNS_ and self.entry_nsprefix_) else ''
            entry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entry', pretty_print=pretty_print)
        for component_ in self.component:
            namespaceprefix_ = self.component_nsprefix_ + ':' if (UseCapturedNS_ and self.component_nsprefix_) else ''
            component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='component', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'text':
            obj_ = StrucDoc_Text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'entry':
            obj_ = POCD_MT000040_Entry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entry.append(obj_)
            obj_.original_tagname_ = 'entry'
        elif nodeName_ == 'component':
            obj_ = POCD_MT000040_Component5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component.append(obj_)
            obj_.original_tagname_ = 'component'
# end class POCD_MT000040_Section


class POCD_MT000040_ServiceEvent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='ACT', moodCode='EVN', realmCode=None, typeId=None, templateId=None, id=None, code=None, effectiveTime=None, performer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_ServiceEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_ServiceEvent.subclass:
            return POCD_MT000040_ServiceEvent.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_ServiceEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassRoot(self, value):
        # Validate type ActClassRoot, a restriction on cs.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.effectiveTime is not None or
            self.performer
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ServiceEvent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.ServiceEvent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.ServiceEvent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.ServiceEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.ServiceEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.ServiceEvent'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "ACT" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.ServiceEvent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassRoot(self.classCode)    # validate type ActClassRoot
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'effectiveTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
# end class POCD_MT000040_ServiceEvent


class POCD_MT000040_Specimen(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='SPC', realmCode=None, typeId=None, templateId=None, specimenRole=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.specimenRole = specimenRole
        self.specimenRole_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Specimen)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Specimen.subclass:
            return POCD_MT000040_Specimen.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Specimen(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_specimenRole(self):
        return self.specimenRole
    def set_specimenRole(self, specimenRole):
        self.specimenRole = specimenRole
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationType(self, value):
        # Validate type ParticipationType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.specimenRole is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Specimen', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Specimen')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Specimen':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Specimen')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Specimen', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Specimen'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "SPC" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Specimen', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.specimenRole is not None:
            namespaceprefix_ = self.specimenRole_nsprefix_ + ':' if (UseCapturedNS_ and self.specimenRole_nsprefix_) else ''
            self.specimenRole.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimenRole', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationType(self.typeCode)    # validate type ParticipationType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'specimenRole':
            obj_ = POCD_MT000040_SpecimenRole.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimenRole = obj_
            obj_.original_tagname_ = 'specimenRole'
# end class POCD_MT000040_Specimen


class POCD_MT000040_SpecimenRole(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='SPEC', realmCode=None, typeId=None, templateId=None, id=None, specimenPlayingEntity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.specimenPlayingEntity = specimenPlayingEntity
        self.specimenPlayingEntity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_SpecimenRole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_SpecimenRole.subclass:
            return POCD_MT000040_SpecimenRole.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_SpecimenRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_specimenPlayingEntity(self):
        return self.specimenPlayingEntity
    def set_specimenPlayingEntity(self, specimenPlayingEntity):
        self.specimenPlayingEntity = specimenPlayingEntity
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_RoleClassSpecimen(self, value):
        # Validate type RoleClassSpecimen, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SPEC', 'ALQT', 'ISLT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RoleClassSpecimen' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_RoleClassSpecimen_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RoleClassSpecimen_patterns_, ))
    validate_RoleClassSpecimen_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.specimenPlayingEntity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.SpecimenRole', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.SpecimenRole')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.SpecimenRole':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.SpecimenRole')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.SpecimenRole', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.SpecimenRole'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "SPEC" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.SpecimenRole', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.specimenPlayingEntity is not None:
            namespaceprefix_ = self.specimenPlayingEntity_nsprefix_ + ':' if (UseCapturedNS_ and self.specimenPlayingEntity_nsprefix_) else ''
            self.specimenPlayingEntity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimenPlayingEntity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_RoleClassSpecimen(self.classCode)    # validate type RoleClassSpecimen
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'specimenPlayingEntity':
            obj_ = POCD_MT000040_PlayingEntity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimenPlayingEntity = obj_
            obj_.original_tagname_ = 'specimenPlayingEntity'
# end class POCD_MT000040_SpecimenRole


class POCD_MT000040_StructuredBody(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, nullFlavor=None, classCode='DOCBODY', moodCode='EVN', realmCode=None, typeId=None, templateId=None, confidentialityCode=None, languageCode=None, component=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.confidentialityCode = confidentialityCode
        self.confidentialityCode_nsprefix_ = None
        self.languageCode = languageCode
        self.languageCode_nsprefix_ = None
        if component is None:
            self.component = []
        else:
            self.component = component
        self.component_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_StructuredBody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_StructuredBody.subclass:
            return POCD_MT000040_StructuredBody.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_StructuredBody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_confidentialityCode(self):
        return self.confidentialityCode
    def set_confidentialityCode(self, confidentialityCode):
        self.confidentialityCode = confidentialityCode
    def get_languageCode(self):
        return self.languageCode
    def set_languageCode(self, languageCode):
        self.languageCode = languageCode
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def add_component(self, value):
        self.component.append(value)
    def insert_component_at(self, index, value):
        self.component.insert(index, value)
    def replace_component_at(self, index, value):
        self.component[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_ActMood(self, value):
        # Validate type ActMood, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.confidentialityCode is not None or
            self.languageCode is not None or
            self.component
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.StructuredBody', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.StructuredBody')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.StructuredBody':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.StructuredBody')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.StructuredBody', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.StructuredBody'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "DOCBODY" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode != "EVN" and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.StructuredBody', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.confidentialityCode is not None:
            namespaceprefix_ = self.confidentialityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.confidentialityCode_nsprefix_) else ''
            self.confidentialityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='confidentialityCode', pretty_print=pretty_print)
        if self.languageCode is not None:
            namespaceprefix_ = self.languageCode_nsprefix_ + ':' if (UseCapturedNS_ and self.languageCode_nsprefix_) else ''
            self.languageCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageCode', pretty_print=pretty_print)
        for component_ in self.component:
            namespaceprefix_ = self.component_nsprefix_ + ':' if (UseCapturedNS_ and self.component_nsprefix_) else ''
            component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='component', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_ActMood(self.moodCode)    # validate type ActMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'confidentialityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.confidentialityCode = obj_
            obj_.original_tagname_ = 'confidentialityCode'
        elif nodeName_ == 'languageCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageCode = obj_
            obj_.original_tagname_ = 'languageCode'
        elif nodeName_ == 'component':
            obj_ = POCD_MT000040_Component3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component.append(obj_)
            obj_.original_tagname_ = 'component'
# end class POCD_MT000040_StructuredBody


class POCD_MT000040_Subject(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, typeCode='SBJ', contextControlCode='OP', realmCode=None, typeId=None, templateId=None, awarenessCode=None, relatedSubject=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.typeCode = _cast(None, typeCode)
        self.typeCode_nsprefix_ = None
        self.contextControlCode = _cast(None, contextControlCode)
        self.contextControlCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        self.awarenessCode = awarenessCode
        self.awarenessCode_nsprefix_ = None
        self.relatedSubject = relatedSubject
        self.relatedSubject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Subject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Subject.subclass:
            return POCD_MT000040_Subject.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Subject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_awarenessCode(self):
        return self.awarenessCode
    def set_awarenessCode(self, awarenessCode):
        self.awarenessCode = awarenessCode
    def get_relatedSubject(self):
        return self.relatedSubject
    def set_relatedSubject(self, relatedSubject):
        self.relatedSubject = relatedSubject
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_contextControlCode(self):
        return self.contextControlCode
    def set_contextControlCode(self, contextControlCode):
        self.contextControlCode = contextControlCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ParticipationTargetSubject(self, value):
        # Validate type ParticipationTargetSubject, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SBJ', 'SPC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParticipationTargetSubject' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ParticipationTargetSubject_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ParticipationTargetSubject_patterns_, ))
    validate_ParticipationTargetSubject_patterns_ = [['^([^\\s]+)$']]
    def validate_ContextControl(self, value):
        # Validate type ContextControl, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.awarenessCode is not None or
            self.relatedSubject is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Subject', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Subject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Subject':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Subject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Subject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Subject'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.typeCode != "SBJ" and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.contextControlCode != "OP" and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            outfile.write(' contextControlCode=%s' % (quote_attrib(self.contextControlCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Subject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        if self.awarenessCode is not None:
            namespaceprefix_ = self.awarenessCode_nsprefix_ + ':' if (UseCapturedNS_ and self.awarenessCode_nsprefix_) else ''
            self.awarenessCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='awarenessCode', pretty_print=pretty_print)
        if self.relatedSubject is not None:
            namespaceprefix_ = self.relatedSubject_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedSubject_nsprefix_) else ''
            self.relatedSubject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedSubject', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.typeCode = ' '.join(self.typeCode.split())
            self.validate_ParticipationTargetSubject(self.typeCode)    # validate type ParticipationTargetSubject
        value = find_attr_value_('contextControlCode', node)
        if value is not None and 'contextControlCode' not in already_processed:
            already_processed.add('contextControlCode')
            self.contextControlCode = value
            self.validate_ContextControl(self.contextControlCode)    # validate type ContextControl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'awarenessCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.awarenessCode = obj_
            obj_.original_tagname_ = 'awarenessCode'
        elif nodeName_ == 'relatedSubject':
            obj_ = POCD_MT000040_RelatedSubject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedSubject = obj_
            obj_.original_tagname_ = 'relatedSubject'
# end class POCD_MT000040_Subject


class POCD_MT000040_SubjectPerson(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='PSN', determinerCode='INSTANCE', realmCode=None, typeId=None, templateId=None, name=None, administrativeGenderCode=None, birthTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.determinerCode = _cast(None, determinerCode)
        self.determinerCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        self.administrativeGenderCode = administrativeGenderCode
        self.administrativeGenderCode_nsprefix_ = None
        self.birthTime = birthTime
        self.birthTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_SubjectPerson)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_SubjectPerson.subclass:
            return POCD_MT000040_SubjectPerson.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_SubjectPerson(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_administrativeGenderCode(self):
        return self.administrativeGenderCode
    def set_administrativeGenderCode(self, administrativeGenderCode):
        self.administrativeGenderCode = administrativeGenderCode
    def get_birthTime(self):
        return self.birthTime
    def set_birthTime(self, birthTime):
        self.birthTime = birthTime
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_determinerCode(self):
        return self.determinerCode
    def set_determinerCode(self, determinerCode):
        self.determinerCode = determinerCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_EntityClass(self, value):
        # Validate type EntityClass, a restriction on None.
        pass
    def validate_EntityDeterminer(self, value):
        # Validate type EntityDeterminer, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.name or
            self.administrativeGenderCode is not None or
            self.birthTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.SubjectPerson', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.SubjectPerson')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.SubjectPerson':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.SubjectPerson')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.SubjectPerson', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.SubjectPerson'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode != "PSN" and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode != "INSTANCE" and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.SubjectPerson', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.administrativeGenderCode is not None:
            namespaceprefix_ = self.administrativeGenderCode_nsprefix_ + ':' if (UseCapturedNS_ and self.administrativeGenderCode_nsprefix_) else ''
            self.administrativeGenderCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='administrativeGenderCode', pretty_print=pretty_print)
        if self.birthTime is not None:
            namespaceprefix_ = self.birthTime_nsprefix_ + ':' if (UseCapturedNS_ and self.birthTime_nsprefix_) else ''
            self.birthTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='birthTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_EntityClass(self.classCode)    # validate type EntityClass
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.determinerCode = ' '.join(self.determinerCode.split())
            self.validate_EntityDeterminer(self.determinerCode)    # validate type EntityDeterminer
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'name':
            obj_ = PN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'administrativeGenderCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.administrativeGenderCode = obj_
            obj_.original_tagname_ = 'administrativeGenderCode'
        elif nodeName_ == 'birthTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.birthTime = obj_
            obj_.original_tagname_ = 'birthTime'
# end class POCD_MT000040_SubjectPerson


class POCD_MT000040_SubstanceAdministration(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='SBADM', moodCode=None, negationInd=None, realmCode=None, typeId=None, templateId=None, id=None, code=None, text=None, statusCode=None, effectiveTime=None, priorityCode=None, repeatNumber=None, routeCode=None, approachSiteCode=None, doseQuantity=None, rateQuantity=None, maxDoseQuantity=None, administrationUnitCode=None, subject=None, specimen=None, consumable=None, performer=None, author=None, informant=None, participant=None, entryRelationship=None, reference=None, precondition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        self.negationInd = _cast(bool, negationInd)
        self.negationInd_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        if effectiveTime is None:
            self.effectiveTime = []
        else:
            self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.repeatNumber = repeatNumber
        self.repeatNumber_nsprefix_ = None
        self.routeCode = routeCode
        self.routeCode_nsprefix_ = None
        if approachSiteCode is None:
            self.approachSiteCode = []
        else:
            self.approachSiteCode = approachSiteCode
        self.approachSiteCode_nsprefix_ = None
        self.doseQuantity = doseQuantity
        self.doseQuantity_nsprefix_ = None
        self.rateQuantity = rateQuantity
        self.rateQuantity_nsprefix_ = None
        self.maxDoseQuantity = maxDoseQuantity
        self.maxDoseQuantity_nsprefix_ = None
        self.administrationUnitCode = administrationUnitCode
        self.administrationUnitCode_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        self.consumable = consumable
        self.consumable_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_SubstanceAdministration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_SubstanceAdministration.subclass:
            return POCD_MT000040_SubstanceAdministration.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_SubstanceAdministration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def add_effectiveTime(self, value):
        self.effectiveTime.append(value)
    def insert_effectiveTime_at(self, index, value):
        self.effectiveTime.insert(index, value)
    def replace_effectiveTime_at(self, index, value):
        self.effectiveTime[index] = value
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def get_repeatNumber(self):
        return self.repeatNumber
    def set_repeatNumber(self, repeatNumber):
        self.repeatNumber = repeatNumber
    def get_routeCode(self):
        return self.routeCode
    def set_routeCode(self, routeCode):
        self.routeCode = routeCode
    def get_approachSiteCode(self):
        return self.approachSiteCode
    def set_approachSiteCode(self, approachSiteCode):
        self.approachSiteCode = approachSiteCode
    def add_approachSiteCode(self, value):
        self.approachSiteCode.append(value)
    def insert_approachSiteCode_at(self, index, value):
        self.approachSiteCode.insert(index, value)
    def replace_approachSiteCode_at(self, index, value):
        self.approachSiteCode[index] = value
    def get_doseQuantity(self):
        return self.doseQuantity
    def set_doseQuantity(self, doseQuantity):
        self.doseQuantity = doseQuantity
    def get_rateQuantity(self):
        return self.rateQuantity
    def set_rateQuantity(self, rateQuantity):
        self.rateQuantity = rateQuantity
    def get_maxDoseQuantity(self):
        return self.maxDoseQuantity
    def set_maxDoseQuantity(self, maxDoseQuantity):
        self.maxDoseQuantity = maxDoseQuantity
    def get_administrationUnitCode(self):
        return self.administrationUnitCode
    def set_administrationUnitCode(self, administrationUnitCode):
        self.administrationUnitCode = administrationUnitCode
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_consumable(self):
        return self.consumable
    def set_consumable(self, consumable):
        self.consumable = consumable
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def get_negationInd(self):
        return self.negationInd
    def set_negationInd(self, negationInd):
        self.negationInd = negationInd
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClass(self, value):
        # Validate type ActClass, a restriction on None.
        pass
    def validate_x_DocumentSubstanceMood(self, value):
        # Validate type x_DocumentSubstanceMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INT', 'EVN', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentSubstanceMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentSubstanceMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentSubstanceMood_patterns_, ))
    validate_x_DocumentSubstanceMood_patterns_ = [['^([^\\s]+)$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime or
            self.priorityCode is not None or
            self.repeatNumber is not None or
            self.routeCode is not None or
            self.approachSiteCode or
            self.doseQuantity is not None or
            self.rateQuantity is not None or
            self.maxDoseQuantity is not None or
            self.administrationUnitCode is not None or
            self.subject is not None or
            self.specimen or
            self.consumable is not None or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.SubstanceAdministration', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.SubstanceAdministration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.SubstanceAdministration':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.SubstanceAdministration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.SubstanceAdministration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.SubstanceAdministration'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.negationInd is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            outfile.write(' negationInd="%s"' % self.gds_format_boolean(self.negationInd, input_name='negationInd'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.SubstanceAdministration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        for effectiveTime_ in self.effectiveTime:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            effectiveTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.priorityCode is not None:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            self.priorityCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.repeatNumber is not None:
            namespaceprefix_ = self.repeatNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.repeatNumber_nsprefix_) else ''
            self.repeatNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repeatNumber', pretty_print=pretty_print)
        if self.routeCode is not None:
            namespaceprefix_ = self.routeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.routeCode_nsprefix_) else ''
            self.routeCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='routeCode', pretty_print=pretty_print)
        for approachSiteCode_ in self.approachSiteCode:
            namespaceprefix_ = self.approachSiteCode_nsprefix_ + ':' if (UseCapturedNS_ and self.approachSiteCode_nsprefix_) else ''
            approachSiteCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='approachSiteCode', pretty_print=pretty_print)
        if self.doseQuantity is not None:
            namespaceprefix_ = self.doseQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.doseQuantity_nsprefix_) else ''
            self.doseQuantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='doseQuantity', pretty_print=pretty_print)
        if self.rateQuantity is not None:
            namespaceprefix_ = self.rateQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.rateQuantity_nsprefix_) else ''
            self.rateQuantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rateQuantity', pretty_print=pretty_print)
        if self.maxDoseQuantity is not None:
            namespaceprefix_ = self.maxDoseQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.maxDoseQuantity_nsprefix_) else ''
            self.maxDoseQuantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maxDoseQuantity', pretty_print=pretty_print)
        if self.administrationUnitCode is not None:
            namespaceprefix_ = self.administrationUnitCode_nsprefix_ + ':' if (UseCapturedNS_ and self.administrationUnitCode_nsprefix_) else ''
            self.administrationUnitCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='administrationUnitCode', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        if self.consumable is not None:
            namespaceprefix_ = self.consumable_nsprefix_ + ':' if (UseCapturedNS_ and self.consumable_nsprefix_) else ''
            self.consumable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='consumable', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_ActClass(self.classCode)    # validate type ActClass
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentSubstanceMood(self.moodCode)    # validate type x_DocumentSubstanceMood
        value = find_attr_value_('negationInd', node)
        if value is not None and 'negationInd' not in already_processed:
            already_processed.add('negationInd')
            if value in ('true', '1'):
                self.negationInd = True
            elif value in ('false', '0'):
                self.negationInd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.negationInd)    # validate type bl
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime.append(obj_)
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode = obj_
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'repeatNumber':
            obj_ = IVL_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.repeatNumber = obj_
            obj_.original_tagname_ = 'repeatNumber'
        elif nodeName_ == 'routeCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.routeCode = obj_
            obj_.original_tagname_ = 'routeCode'
        elif nodeName_ == 'approachSiteCode':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.approachSiteCode.append(obj_)
            obj_.original_tagname_ = 'approachSiteCode'
        elif nodeName_ == 'doseQuantity':
            class_obj_ = self.get_class_obj_(child_, IVL_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.doseQuantity = obj_
            obj_.original_tagname_ = 'doseQuantity'
        elif nodeName_ == 'rateQuantity':
            class_obj_ = self.get_class_obj_(child_, IVL_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rateQuantity = obj_
            obj_.original_tagname_ = 'rateQuantity'
        elif nodeName_ == 'maxDoseQuantity':
            obj_ = RTO_PQ_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maxDoseQuantity = obj_
            obj_.original_tagname_ = 'maxDoseQuantity'
        elif nodeName_ == 'administrationUnitCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.administrationUnitCode = obj_
            obj_.original_tagname_ = 'administrationUnitCode'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'consumable':
            obj_ = POCD_MT000040_Consumable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.consumable = obj_
            obj_.original_tagname_ = 'consumable'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040_SubstanceAdministration


class POCD_MT000040_Supply(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, classCode='SPLY', moodCode=None, realmCode=None, typeId=None, templateId=None, id=None, code=None, text=None, statusCode=None, effectiveTime=None, priorityCode=None, repeatNumber=None, independentInd=None, quantity=None, expectedUseTime=None, subject=None, specimen=None, product=None, performer=None, author=None, informant=None, participant=None, entryRelationship=None, reference=None, precondition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.classCode = _cast(None, classCode)
        self.classCode_nsprefix_ = None
        self.moodCode = _cast(None, moodCode)
        self.moodCode_nsprefix_ = None
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.realmCode_nsprefix_ = None
        self.typeId = typeId
        self.typeId_nsprefix_ = None
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.templateId_nsprefix_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        self.id_nsprefix_ = None
        self.code = code
        self.code_nsprefix_ = None
        self.text = text
        self.text_nsprefix_ = None
        self.statusCode = statusCode
        self.statusCode_nsprefix_ = None
        if effectiveTime is None:
            self.effectiveTime = []
        else:
            self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        if priorityCode is None:
            self.priorityCode = []
        else:
            self.priorityCode = priorityCode
        self.priorityCode_nsprefix_ = None
        self.repeatNumber = repeatNumber
        self.repeatNumber_nsprefix_ = None
        self.independentInd = independentInd
        self.independentInd_nsprefix_ = None
        self.quantity = quantity
        self.quantity_nsprefix_ = None
        self.expectedUseTime = expectedUseTime
        self.expectedUseTime_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
        if specimen is None:
            self.specimen = []
        else:
            self.specimen = specimen
        self.specimen_nsprefix_ = None
        self.product = product
        self.product_nsprefix_ = None
        if performer is None:
            self.performer = []
        else:
            self.performer = performer
        self.performer_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = None
        if informant is None:
            self.informant = []
        else:
            self.informant = informant
        self.informant_nsprefix_ = None
        if participant is None:
            self.participant = []
        else:
            self.participant = participant
        self.participant_nsprefix_ = None
        if entryRelationship is None:
            self.entryRelationship = []
        else:
            self.entryRelationship = entryRelationship
        self.entryRelationship_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        if precondition is None:
            self.precondition = []
        else:
            self.precondition = precondition
        self.precondition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_Supply)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_Supply.subclass:
            return POCD_MT000040_Supply.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_Supply(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_realmCode(self):
        return self.realmCode
    def set_realmCode(self, realmCode):
        self.realmCode = realmCode
    def add_realmCode(self, value):
        self.realmCode.append(value)
    def insert_realmCode_at(self, index, value):
        self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value):
        self.realmCode[index] = value
    def get_typeId(self):
        return self.typeId
    def set_typeId(self, typeId):
        self.typeId = typeId
    def get_templateId(self):
        return self.templateId
    def set_templateId(self, templateId):
        self.templateId = templateId
    def add_templateId(self, value):
        self.templateId.append(value)
    def insert_templateId_at(self, index, value):
        self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value):
        self.templateId[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def add_id(self, value):
        self.id.append(value)
    def insert_id_at(self, index, value):
        self.id.insert(index, value)
    def replace_id_at(self, index, value):
        self.id[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_statusCode(self):
        return self.statusCode
    def set_statusCode(self, statusCode):
        self.statusCode = statusCode
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def add_effectiveTime(self, value):
        self.effectiveTime.append(value)
    def insert_effectiveTime_at(self, index, value):
        self.effectiveTime.insert(index, value)
    def replace_effectiveTime_at(self, index, value):
        self.effectiveTime[index] = value
    def get_priorityCode(self):
        return self.priorityCode
    def set_priorityCode(self, priorityCode):
        self.priorityCode = priorityCode
    def add_priorityCode(self, value):
        self.priorityCode.append(value)
    def insert_priorityCode_at(self, index, value):
        self.priorityCode.insert(index, value)
    def replace_priorityCode_at(self, index, value):
        self.priorityCode[index] = value
    def get_repeatNumber(self):
        return self.repeatNumber
    def set_repeatNumber(self, repeatNumber):
        self.repeatNumber = repeatNumber
    def get_independentInd(self):
        return self.independentInd
    def set_independentInd(self, independentInd):
        self.independentInd = independentInd
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def get_expectedUseTime(self):
        return self.expectedUseTime
    def set_expectedUseTime(self, expectedUseTime):
        self.expectedUseTime = expectedUseTime
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_specimen(self):
        return self.specimen
    def set_specimen(self, specimen):
        self.specimen = specimen
    def add_specimen(self, value):
        self.specimen.append(value)
    def insert_specimen_at(self, index, value):
        self.specimen.insert(index, value)
    def replace_specimen_at(self, index, value):
        self.specimen[index] = value
    def get_product(self):
        return self.product
    def set_product(self, product):
        self.product = product
    def get_performer(self):
        return self.performer
    def set_performer(self, performer):
        self.performer = performer
    def add_performer(self, value):
        self.performer.append(value)
    def insert_performer_at(self, index, value):
        self.performer.insert(index, value)
    def replace_performer_at(self, index, value):
        self.performer[index] = value
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_informant(self):
        return self.informant
    def set_informant(self, informant):
        self.informant = informant
    def add_informant(self, value):
        self.informant.append(value)
    def insert_informant_at(self, index, value):
        self.informant.insert(index, value)
    def replace_informant_at(self, index, value):
        self.informant[index] = value
    def get_participant(self):
        return self.participant
    def set_participant(self, participant):
        self.participant = participant
    def add_participant(self, value):
        self.participant.append(value)
    def insert_participant_at(self, index, value):
        self.participant.insert(index, value)
    def replace_participant_at(self, index, value):
        self.participant[index] = value
    def get_entryRelationship(self):
        return self.entryRelationship
    def set_entryRelationship(self, entryRelationship):
        self.entryRelationship = entryRelationship
    def add_entryRelationship(self, value):
        self.entryRelationship.append(value)
    def insert_entryRelationship_at(self, index, value):
        self.entryRelationship.insert(index, value)
    def replace_entryRelationship_at(self, index, value):
        self.entryRelationship[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_precondition(self):
        return self.precondition
    def set_precondition(self, precondition):
        self.precondition = precondition
    def add_precondition(self, value):
        self.precondition.append(value)
    def insert_precondition_at(self, index, value):
        self.precondition.insert(index, value)
    def replace_precondition_at(self, index, value):
        self.precondition[index] = value
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_classCode(self):
        return self.classCode
    def set_classCode(self, classCode):
        self.classCode = classCode
    def get_moodCode(self):
        return self.moodCode
    def set_moodCode(self, moodCode):
        self.moodCode = moodCode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def validate_ActClassSupply(self, value):
        # Validate type ActClassSupply, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SPLY', 'DIET']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ActClassSupply' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ActClassSupply_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ActClassSupply_patterns_, ))
    validate_ActClassSupply_patterns_ = [['^([^\\s]+)$']]
    def validate_x_DocumentSubstanceMood(self, value):
        # Validate type x_DocumentSubstanceMood, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INT', 'EVN', 'PRMS', 'PRP', 'RQO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on x_DocumentSubstanceMood' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_x_DocumentSubstanceMood_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_x_DocumentSubstanceMood_patterns_, ))
    validate_x_DocumentSubstanceMood_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.code is not None or
            self.text is not None or
            self.statusCode is not None or
            self.effectiveTime or
            self.priorityCode or
            self.repeatNumber is not None or
            self.independentInd is not None or
            self.quantity is not None or
            self.expectedUseTime is not None or
            self.subject is not None or
            self.specimen or
            self.product is not None or
            self.performer or
            self.author or
            self.informant or
            self.participant or
            self.entryRelationship or
            self.reference or
            self.precondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Supply', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.Supply')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.Supply':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.Supply')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.Supply', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.Supply'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='POCD_MT000040.Supply', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            namespaceprefix_ = self.realmCode_nsprefix_ + ':' if (UseCapturedNS_ and self.realmCode_nsprefix_) else ''
            realmCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            namespaceprefix_ = self.typeId_nsprefix_ + ':' if (UseCapturedNS_ and self.typeId_nsprefix_) else ''
            self.typeId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            namespaceprefix_ = self.templateId_nsprefix_ + ':' if (UseCapturedNS_ and self.templateId_nsprefix_) else ''
            templateId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            namespaceprefix_ = self.id_nsprefix_ + ':' if (UseCapturedNS_ and self.id_nsprefix_) else ''
            id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='id', pretty_print=pretty_print)
        if self.code is not None:
            namespaceprefix_ = self.code_nsprefix_ + ':' if (UseCapturedNS_ and self.code_nsprefix_) else ''
            self.code.export(outfile, level, namespaceprefix_, namespacedef_='', name_='code', pretty_print=pretty_print)
        if self.text is not None:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            self.text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
        if self.statusCode is not None:
            namespaceprefix_ = self.statusCode_nsprefix_ + ':' if (UseCapturedNS_ and self.statusCode_nsprefix_) else ''
            self.statusCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusCode', pretty_print=pretty_print)
        for effectiveTime_ in self.effectiveTime:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            effectiveTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        for priorityCode_ in self.priorityCode:
            namespaceprefix_ = self.priorityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.priorityCode_nsprefix_) else ''
            priorityCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priorityCode', pretty_print=pretty_print)
        if self.repeatNumber is not None:
            namespaceprefix_ = self.repeatNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.repeatNumber_nsprefix_) else ''
            self.repeatNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repeatNumber', pretty_print=pretty_print)
        if self.independentInd is not None:
            namespaceprefix_ = self.independentInd_nsprefix_ + ':' if (UseCapturedNS_ and self.independentInd_nsprefix_) else ''
            self.independentInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='independentInd', pretty_print=pretty_print)
        if self.quantity is not None:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            self.quantity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantity', pretty_print=pretty_print)
        if self.expectedUseTime is not None:
            namespaceprefix_ = self.expectedUseTime_nsprefix_ + ':' if (UseCapturedNS_ and self.expectedUseTime_nsprefix_) else ''
            self.expectedUseTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='expectedUseTime', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for specimen_ in self.specimen:
            namespaceprefix_ = self.specimen_nsprefix_ + ':' if (UseCapturedNS_ and self.specimen_nsprefix_) else ''
            specimen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specimen', pretty_print=pretty_print)
        if self.product is not None:
            namespaceprefix_ = self.product_nsprefix_ + ':' if (UseCapturedNS_ and self.product_nsprefix_) else ''
            self.product.export(outfile, level, namespaceprefix_, namespacedef_='', name_='product', pretty_print=pretty_print)
        for performer_ in self.performer:
            namespaceprefix_ = self.performer_nsprefix_ + ':' if (UseCapturedNS_ and self.performer_nsprefix_) else ''
            performer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='performer', pretty_print=pretty_print)
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        for informant_ in self.informant:
            namespaceprefix_ = self.informant_nsprefix_ + ':' if (UseCapturedNS_ and self.informant_nsprefix_) else ''
            informant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='informant', pretty_print=pretty_print)
        for participant_ in self.participant:
            namespaceprefix_ = self.participant_nsprefix_ + ':' if (UseCapturedNS_ and self.participant_nsprefix_) else ''
            participant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='participant', pretty_print=pretty_print)
        for entryRelationship_ in self.entryRelationship:
            namespaceprefix_ = self.entryRelationship_nsprefix_ + ':' if (UseCapturedNS_ and self.entryRelationship_nsprefix_) else ''
            entryRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entryRelationship', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for precondition_ in self.precondition:
            namespaceprefix_ = self.precondition_nsprefix_ + ':' if (UseCapturedNS_ and self.precondition_nsprefix_) else ''
            precondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precondition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.classCode = ' '.join(self.classCode.split())
            self.validate_ActClassSupply(self.classCode)    # validate type ActClassSupply
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.moodCode = ' '.join(self.moodCode.split())
            self.validate_x_DocumentSubstanceMood(self.moodCode)    # validate type x_DocumentSubstanceMood
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = POCD_MT000040_InfrastructureRoot_typeId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = POCD_MT000040_InfrastructureRoot_templateId.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'text':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'statusCode':
            obj_ = CS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusCode = obj_
            obj_.original_tagname_ = 'statusCode'
        elif nodeName_ == 'effectiveTime':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime.append(obj_)
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'priorityCode':
            class_obj_ = self.get_class_obj_(child_, CE)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priorityCode.append(obj_)
            obj_.original_tagname_ = 'priorityCode'
        elif nodeName_ == 'repeatNumber':
            obj_ = IVL_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.repeatNumber = obj_
            obj_.original_tagname_ = 'repeatNumber'
        elif nodeName_ == 'independentInd':
            obj_ = BL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.independentInd = obj_
            obj_.original_tagname_ = 'independentInd'
        elif nodeName_ == 'quantity':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantity = obj_
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'expectedUseTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expectedUseTime = obj_
            obj_.original_tagname_ = 'expectedUseTime'
        elif nodeName_ == 'subject':
            obj_ = POCD_MT000040_Subject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'specimen':
            obj_ = POCD_MT000040_Specimen.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specimen.append(obj_)
            obj_.original_tagname_ = 'specimen'
        elif nodeName_ == 'product':
            obj_ = POCD_MT000040_Product.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.product = obj_
            obj_.original_tagname_ = 'product'
        elif nodeName_ == 'performer':
            obj_ = POCD_MT000040_Performer2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.performer.append(obj_)
            obj_.original_tagname_ = 'performer'
        elif nodeName_ == 'author':
            obj_ = POCD_MT000040_Author.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'informant':
            obj_ = POCD_MT000040_Informant12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.informant.append(obj_)
            obj_.original_tagname_ = 'informant'
        elif nodeName_ == 'participant':
            obj_ = POCD_MT000040_Participant2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.participant.append(obj_)
            obj_.original_tagname_ = 'participant'
        elif nodeName_ == 'entryRelationship':
            obj_ = POCD_MT000040_EntryRelationship.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entryRelationship.append(obj_)
            obj_.original_tagname_ = 'entryRelationship'
        elif nodeName_ == 'reference':
            obj_ = POCD_MT000040_Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'precondition':
            obj_ = POCD_MT000040_Precondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.precondition.append(obj_)
            obj_.original_tagname_ = 'precondition'
# end class POCD_MT000040_Supply


class ANY(GeneratedsSuper):
    """Defines the basic properties of every data value. This
    is an abstract type, meaning that no value can be just
    a data value without belonging to any concrete type.
    Every concrete type is a specialization of this
    general abstract DataValue type.
    An exceptional value expressing missing information
    and possibly the reason why the information is missing."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANY.subclass:
            return ANY.subclass(*args_, **kwargs_)
        else:
            return ANY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANY', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANY':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANY')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANY'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANY', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class ANY


class BL(ANY):
    """The Boolean type stands for the values of two-valued logic.
    A Boolean value can be either true or
    false, or, as any other value may be NULL."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BL, self).__init__(nullFlavor,  **kwargs_)
        self.value = _cast(bool, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BL.subclass:
            return BL.subclass(*args_, **kwargs_)
        else:
            return BL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            super(BL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BL'):
        super(BL, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BL')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_boolean(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BL', fromsubclass_=False, pretty_print=True):
        super(BL, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            if value in ('true', '1'):
                self.value = True
            elif value in ('false', '0'):
                self.value = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.value)    # validate type bl
        super(BL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BL, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BL


class ANYNonNull(ANY):
    """The BooleanNonNull type is used where a Boolean cannot
    have a null value. A Boolean value can be either
    true or false."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ANYNonNull, self).__init__(nullFlavor, extensiontype_,  **kwargs_)
        self.nullFlavor = _cast(None, nullFlavor)
        self.nullFlavor_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANYNonNull)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANYNonNull.subclass:
            return ANYNonNull.subclass(*args_, **kwargs_)
        else:
            return ANYNonNull(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nullFlavor(self):
        return self.nullFlavor
    def set_nullFlavor(self, nullFlavor):
        self.nullFlavor = nullFlavor
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            super(ANYNonNull, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANYNonNull', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANYNonNull')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANYNonNull':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANYNonNull')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANYNonNull', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANYNonNull'):
        super(ANYNonNull, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANYNonNull')
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANYNonNull', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.nullFlavor = ' '.join(self.nullFlavor.split())
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ANYNonNull, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ANYNonNull


class BN(ANYNonNull):
    """The BooleanNonNull type is used where a Boolean cannot
    have a null value. A Boolean value can be either
    true or false."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANYNonNull
    def __init__(self, nullFlavor=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BN, self).__init__(nullFlavor,  **kwargs_)
        self.value = _cast(bool, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BN.subclass:
            return BN.subclass(*args_, **kwargs_)
        else:
            return BN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_bn(self, value):
        # Validate type bn, a restriction on bl.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bn_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bn_patterns_, ))
    validate_bn_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            super(BN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BN', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BN'):
        super(BN, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BN')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BN', fromsubclass_=False, pretty_print=True):
        super(BN, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            if value in ('true', '1'):
                self.value = True
            elif value in ('false', '0'):
                self.value = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bn(self.value)    # validate type bn
        super(BN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BN, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BN


class BIN(ANY):
    """Binary data is a raw block of bits. Binary data is a
    protected type that MUST not be used outside the data
    type specification.
    Specifies the representation of the binary data that
    is the content of the binary data value."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, representation='TXT', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BIN, self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.representation = _cast(None, representation)
        self.representation_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BIN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BIN.subclass:
            return BIN.subclass(*args_, **kwargs_)
        else:
            return BIN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_representation(self):
        return self.representation
    def set_representation(self, representation):
        self.representation = representation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_BinaryDataEncoding(self, value):
        # Validate type BinaryDataEncoding, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B64', 'TXT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BinaryDataEncoding' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(BIN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BIN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BIN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BIN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BIN')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BIN'):
        super(BIN, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BIN')
        if self.representation != "TXT" and 'representation' not in already_processed:
            already_processed.add('representation')
            outfile.write(' representation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.representation), input_name='representation')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BIN', fromsubclass_=False, pretty_print=True):
        super(BIN, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('representation', node)
        if value is not None and 'representation' not in already_processed:
            already_processed.add('representation')
            self.representation = value
            self.validate_BinaryDataEncoding(self.representation)    # validate type BinaryDataEncoding
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BIN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(BIN, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BIN


class ED(BIN):
    """Data that is primarily intended for human interpretation
    or for further machine processing is outside the scope of
    HL7. This includes unformatted or formatted written language,
    multimedia data, or structured information as defined by a
    different standard (e.g., XML-signatures.) Instead of the
    data itself, an ED may contain
    only a reference (see TEL.) Note
    that the ST data type is a
    specialization of the ED data type
    when the ED media type is text/plain.
    Identifies the type of the encapsulated data and
    identifies a method to interpret or render the data.
    For character based information the language property
    specifies the human language of the text.
    Indicates whether the raw byte data is compressed,
    and what compression algorithm was used.
    The integrity check is a short binary value representing
    a cryptographically strong checksum that is calculated
    over the binary data. The purpose of this property, when
    communicated with a reference is for anyone to validate
    later whether the reference still resolved to the same
    data that the reference resolved to when the encapsulated
    data value with reference was created.
    Specifies the algorithm used to compute the
    integrityCheck value."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BIN
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ED, self).__init__(nullFlavor, representation, valueOf_, mixedclass_, content_,  **kwargs_)
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.compression = _cast(None, compression)
        self.compression_nsprefix_ = None
        self.integrityCheck = _cast(None, integrityCheck)
        self.integrityCheck_nsprefix_ = None
        self.integrityCheckAlgorithm = _cast(None, integrityCheckAlgorithm)
        self.integrityCheckAlgorithm_nsprefix_ = None
        self.reference = reference
        self.reference_nsprefix_ = None
        self.thumbnail = thumbnail
        self.thumbnail_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ED)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ED.subclass:
            return ED.subclass(*args_, **kwargs_)
        else:
            return ED(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_thumbnail(self):
        return self.thumbnail
    def set_thumbnail(self, thumbnail):
        self.thumbnail = thumbnail
    def get_mediaType(self):
        return self.mediaType
    def set_mediaType(self, mediaType):
        self.mediaType = mediaType
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_compression(self):
        return self.compression
    def set_compression(self, compression):
        self.compression = compression
    def get_integrityCheck(self):
        return self.integrityCheck
    def set_integrityCheck(self, integrityCheck):
        self.integrityCheck = integrityCheck
    def get_integrityCheckAlgorithm(self):
        return self.integrityCheckAlgorithm
    def set_integrityCheckAlgorithm(self, integrityCheckAlgorithm):
        self.integrityCheckAlgorithm = integrityCheckAlgorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_CompressionAlgorithm(self, value):
        # Validate type CompressionAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DF', 'GZ', 'Z', 'ZL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CompressionAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CompressionAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CompressionAlgorithm_patterns_, ))
    validate_CompressionAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def validate_bin(self, value):
        # Validate type bin, a restriction on xs:base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
    def validate_IntegrityCheckAlgorithm(self, value):
        # Validate type IntegrityCheckAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SHA-1', 'SHA-256']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on IntegrityCheckAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IntegrityCheckAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IntegrityCheckAlgorithm_patterns_, ))
    validate_IntegrityCheckAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ED, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='ED', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ED')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ED':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ED')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ED', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ED'):
        super(ED, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ED')
        if self.mediaType != "text/plain" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            outfile.write(' compression=%s' % (quote_attrib(self.compression), ))
        if self.integrityCheck is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            outfile.write(' integrityCheck=%s' % (quote_attrib(self.integrityCheck), ))
        if self.integrityCheckAlgorithm != "SHA-1" and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            outfile.write(' integrityCheckAlgorithm=%s' % (quote_attrib(self.integrityCheckAlgorithm), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='ED', fromsubclass_=False, pretty_print=True):
        super(ED, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            self.reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            namespaceprefix_ = self.thumbnail_nsprefix_ + ':' if (UseCapturedNS_ and self.thumbnail_nsprefix_) else ''
            self.thumbnail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thumbnail', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
            self.mediaType = ' '.join(self.mediaType.split())
            self.validate_cs(self.mediaType)    # validate type cs
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
            self.language = ' '.join(self.language.split())
            self.validate_cs(self.language)    # validate type cs
        value = find_attr_value_('compression', node)
        if value is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            self.compression = value
            self.compression = ' '.join(self.compression.split())
            self.validate_CompressionAlgorithm(self.compression)    # validate type CompressionAlgorithm
        value = find_attr_value_('integrityCheck', node)
        if value is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            self.integrityCheck = value
            self.validate_bin(self.integrityCheck)    # validate type bin
        value = find_attr_value_('integrityCheckAlgorithm', node)
        if value is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            self.integrityCheckAlgorithm = value
            self.integrityCheckAlgorithm = ' '.join(self.integrityCheckAlgorithm.split())
            self.validate_IntegrityCheckAlgorithm(self.integrityCheckAlgorithm)    # validate type IntegrityCheckAlgorithm
        super(ED, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnail.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ED, self).buildChildren(child_, node, nodeName_, True)
# end class ED


class thumbnail(ED):
    """A thumbnail is an abbreviated rendition of the full
    data. A thumbnail requires significantly fewer
    resources than the full data, while still maintaining
    some distinctive similarity with the full data. A
    thumbnail is typically used with by-reference
    encapsulated data. It allows a user to select data
    more efficiently before actually downloading through
    the reference."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ED
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, thumbnail_member=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(thumbnail, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, valueOf_, mixedclass_, content_,  **kwargs_)
        self.reference = reference
        self.reference_nsprefix_ = None
        self.thumbnail = thumbnail_member
        self.thumbnail_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, thumbnail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if thumbnail.subclass:
            return thumbnail.subclass(*args_, **kwargs_)
        else:
            return thumbnail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_thumbnail(self):
        return self.thumbnail
    def set_thumbnail(self, thumbnail):
        self.thumbnail = thumbnail
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(thumbnail, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='thumbnail', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('thumbnail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'thumbnail':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='thumbnail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='thumbnail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='thumbnail'):
        super(thumbnail, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='thumbnail')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='thumbnail', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            self.reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            namespaceprefix_ = self.thumbnail_nsprefix_ + ':' if (UseCapturedNS_ and self.thumbnail_nsprefix_) else ''
            self.thumbnail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thumbnail', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(thumbnail, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnail.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class thumbnail


class ST(ED):
    """The character string data type stands for text data,
    primarily intended for machine processing (e.g.,
    sorting, querying, indexing, etc.) Used for names,
    symbols, and formal expressions."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ED
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ST, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.representation = _cast(None, representation)
        self.representation_nsprefix_ = None
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.compression = _cast(None, compression)
        self.compression_nsprefix_ = None
        self.integrityCheck = _cast(None, integrityCheck)
        self.integrityCheck_nsprefix_ = None
        self.integrityCheckAlgorithm = _cast(None, integrityCheckAlgorithm)
        self.integrityCheckAlgorithm_nsprefix_ = None
        self.reference = reference
        self.reference_nsprefix_ = None
        self.thumbnail = thumbnail
        self.thumbnail_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ST)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ST.subclass:
            return ST.subclass(*args_, **kwargs_)
        else:
            return ST(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_thumbnail(self):
        return self.thumbnail
    def set_thumbnail(self, thumbnail):
        self.thumbnail = thumbnail
    def get_representation(self):
        return self.representation
    def set_representation(self, representation):
        self.representation = representation
    def get_mediaType(self):
        return self.mediaType
    def set_mediaType(self, mediaType):
        self.mediaType = mediaType
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_compression(self):
        return self.compression
    def set_compression(self, compression):
        self.compression = compression
    def get_integrityCheck(self):
        return self.integrityCheck
    def set_integrityCheck(self, integrityCheck):
        self.integrityCheck = integrityCheck
    def get_integrityCheckAlgorithm(self):
        return self.integrityCheckAlgorithm
    def set_integrityCheckAlgorithm(self, integrityCheckAlgorithm):
        self.integrityCheckAlgorithm = integrityCheckAlgorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_BinaryDataEncoding(self, value):
        # Validate type BinaryDataEncoding, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B64', 'TXT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BinaryDataEncoding' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_CompressionAlgorithm(self, value):
        # Validate type CompressionAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DF', 'GZ', 'Z', 'ZL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CompressionAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CompressionAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CompressionAlgorithm_patterns_, ))
    validate_CompressionAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def validate_bin(self, value):
        # Validate type bin, a restriction on xs:base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
    def validate_IntegrityCheckAlgorithm(self, value):
        # Validate type IntegrityCheckAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SHA-1', 'SHA-256']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on IntegrityCheckAlgorithm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IntegrityCheckAlgorithm_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IntegrityCheckAlgorithm_patterns_, ))
    validate_IntegrityCheckAlgorithm_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ST, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='ST', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ST')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ST':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ST')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ST', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ST'):
        super(ST, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ST')
        if self.representation != "TXT" and 'representation' not in already_processed:
            already_processed.add('representation')
            outfile.write(' representation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.representation), input_name='representation')), ))
        if self.mediaType != "text/plain" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            outfile.write(' compression=%s' % (quote_attrib(self.compression), ))
        if self.integrityCheck is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            outfile.write(' integrityCheck=%s' % (quote_attrib(self.integrityCheck), ))
        if self.integrityCheckAlgorithm is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            outfile.write(' integrityCheckAlgorithm=%s' % (quote_attrib(self.integrityCheckAlgorithm), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='ST', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            self.reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            namespaceprefix_ = self.thumbnail_nsprefix_ + ':' if (UseCapturedNS_ and self.thumbnail_nsprefix_) else ''
            self.thumbnail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thumbnail', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('representation', node)
        if value is not None and 'representation' not in already_processed:
            already_processed.add('representation')
            self.representation = value
            self.validate_BinaryDataEncoding(self.representation)    # validate type BinaryDataEncoding
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
            self.mediaType = ' '.join(self.mediaType.split())
            self.validate_cs(self.mediaType)    # validate type cs
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
            self.language = ' '.join(self.language.split())
            self.validate_cs(self.language)    # validate type cs
        value = find_attr_value_('compression', node)
        if value is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            self.compression = value
            self.compression = ' '.join(self.compression.split())
            self.validate_CompressionAlgorithm(self.compression)    # validate type CompressionAlgorithm
        value = find_attr_value_('integrityCheck', node)
        if value is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            self.integrityCheck = value
            self.validate_bin(self.integrityCheck)    # validate type bin
        value = find_attr_value_('integrityCheckAlgorithm', node)
        if value is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            self.integrityCheckAlgorithm = value
            self.integrityCheckAlgorithm = ' '.join(self.integrityCheckAlgorithm.split())
            self.validate_IntegrityCheckAlgorithm(self.integrityCheckAlgorithm)    # validate type IntegrityCheckAlgorithm
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ST, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = TEL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ST


class CD(ANY):
    """A concept descriptor represents any kind of concept usually
    by giving a code defined in a code system. A concept
    descriptor can contain the original text or phrase that
    served as the basis of the coding and one or more
    translations into different coding systems. A concept
    descriptor can also contain qualifiers to describe, e.g.,
    the concept of a "left foot" as a postcoordinated term built
    from the primary code "FOOT" and the qualifier "LEFT".
    In exceptional cases, the concept descriptor need not
    contain a code but only the original text describing
    that concept.
    The plain code symbol defined by the code system.
    For example, "784.0" is the code symbol of the ICD-9
    code "784.0" for headache.
    Specifies the code system that defines the code.
    A common name of the coding system.
    If applicable, a version descriptor defined
    specifically for the given code system.
    A name or title for the code, under which the sending
    system shows the code value to its users."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, translation=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CD, self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.originalText = originalText
        self.originalText_nsprefix_ = None
        if qualifier is None:
            self.qualifier = []
        else:
            self.qualifier = qualifier
        self.qualifier_nsprefix_ = None
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.translation_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CD.subclass:
            return CD.subclass(*args_, **kwargs_)
        else:
            return CD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originalText(self):
        return self.originalText
    def set_originalText(self, originalText):
        self.originalText = originalText
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def add_qualifier(self, value):
        self.qualifier.append(value)
    def insert_qualifier_at(self, index, value):
        self.qualifier.insert(index, value)
    def replace_qualifier_at(self, index, value):
        self.qualifier[index] = value
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def add_translation(self, value):
        self.translation.append(value)
    def insert_translation_at(self, index, value):
        self.translation.insert(index, value)
    def replace_translation_at(self, index, value):
        self.translation[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.originalText is not None or
            self.qualifier or
            self.translation or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(CD, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='CD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CD')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CD'):
        super(CD, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CD')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='CD', fromsubclass_=False, pretty_print=True):
        super(CD, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalText is not None:
            namespaceprefix_ = self.originalText_nsprefix_ + ':' if (UseCapturedNS_ and self.originalText_nsprefix_) else ''
            self.originalText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originalText', pretty_print=pretty_print)
        for qualifier_ in self.qualifier:
            namespaceprefix_ = self.qualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.qualifier_nsprefix_) else ''
            qualifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='qualifier', pretty_print=pretty_print)
        for translation_ in self.translation:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            translation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CD, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originalText':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'originalText', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_originalText'):
              self.add_originalText(obj_.value)
            elif hasattr(self, 'set_originalText'):
              self.set_originalText(obj_.value)
        elif nodeName_ == 'qualifier':
            obj_ = CR.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'qualifier', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_qualifier'):
              self.add_qualifier(obj_.value)
            elif hasattr(self, 'set_qualifier'):
              self.set_qualifier(obj_.value)
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            class_obj_ = CD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'translation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_translation'):
              self.add_translation(obj_.value)
            elif hasattr(self, 'set_translation'):
              self.set_translation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(CD, self).buildChildren(child_, node, nodeName_, True)
# end class CD


class CE(CD):
    """Coded data, consists of a coded value (CV)
    and, optionally, coded value(s) from other coding systems
    that identify the same concept. Used when alternative
    codes may exist.
    The plain code symbol defined by the code system.
    For example, "784.0" is the code symbol of the ICD-9
    code "784.0" for headache.
    Specifies the code system that defines the code.
    A common name of the coding system.
    If applicable, a version descriptor defined
    specifically for the given code system.
    A name or title for the code, under which the sending
    system shows the code value to its users."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CD
    def __init__(self, nullFlavor=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, translation=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CE, self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation, extensiontype_,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.originalText = originalText
        self.originalText_nsprefix_ = None
        self.qualifier = qualifier
        self.qualifier_nsprefix_ = None
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.translation_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CE.subclass:
            return CE.subclass(*args_, **kwargs_)
        else:
            return CE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originalText(self):
        return self.originalText
    def set_originalText(self, originalText):
        self.originalText = originalText
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def add_translation(self, value):
        self.translation.append(value)
    def insert_translation_at(self, index, value):
        self.translation.insert(index, value)
    def replace_translation_at(self, index, value):
        self.translation[index] = value
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.originalText is not None or
            self.qualifier is not None or
            self.translation or
            super(CE, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='CE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CE'):
        super(CE, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CE')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='CE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalText is not None:
            namespaceprefix_ = self.originalText_nsprefix_ + ':' if (UseCapturedNS_ and self.originalText_nsprefix_) else ''
            self.originalText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originalText', pretty_print=pretty_print)
        if self.qualifier is not None:
            namespaceprefix_ = self.qualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.qualifier_nsprefix_) else ''
            self.qualifier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='qualifier', pretty_print=pretty_print)
        for translation_ in self.translation:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            translation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CE, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originalText':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originalText = obj_
            obj_.original_tagname_ = 'originalText'
        elif nodeName_ == 'qualifier':
            obj_ = CR.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.qualifier = obj_
            obj_.original_tagname_ = 'qualifier'
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.translation.append(obj_)
            obj_.original_tagname_ = 'translation'
# end class CE


class CV(CE):
    """Coded data, consists of a code, display name, code system,
    and original text. Used when a single code value must be sent.
    The plain code symbol defined by the code system.
    For example, "784.0" is the code symbol of the ICD-9
    code "784.0" for headache.
    Specifies the code system that defines the code.
    A common name of the coding system.
    If applicable, a version descriptor defined
    specifically for the given code system.
    A name or title for the code, under which the sending
    system shows the code value to its users."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CE
    def __init__(self, nullFlavor=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, translation=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CV, self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation, extensiontype_,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.originalText = originalText
        self.originalText_nsprefix_ = None
        self.translation = translation
        self.translation_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CV.subclass:
            return CV.subclass(*args_, **kwargs_)
        else:
            return CV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originalText(self):
        return self.originalText
    def set_originalText(self, originalText):
        self.originalText = originalText
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.originalText is not None or
            self.translation is not None or
            super(CV, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='CV', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CV':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CV', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CV'):
        super(CV, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CV')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='CV', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalText is not None:
            namespaceprefix_ = self.originalText_nsprefix_ + ':' if (UseCapturedNS_ and self.originalText_nsprefix_) else ''
            self.originalText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originalText', pretty_print=pretty_print)
        if self.translation is not None:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            self.translation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CV, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originalText':
            obj_ = ED.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originalText = obj_
            obj_.original_tagname_ = 'originalText'
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.translation = obj_
            obj_.original_tagname_ = 'translation'
# end class CV


class CS(CV):
    """Coded data, consists of a code, display name, code system,
    and original text. Used when a single code value must be sent.
    The plain code symbol defined by the code system.
    For example, "784.0" is the code symbol of the ICD-9
    code "784.0" for headache."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CV
    def __init__(self, nullFlavor=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, translation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CS, self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CS.subclass:
            return CS.subclass(*args_, **kwargs_)
        else:
            return CS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CS'):
        super(CS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CS')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        super(CS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CS


class CO(CV):
    """Coded data, where the domain from which the codeset comes
    is ordered. The Coded Ordinal data type adds semantics
    related to ordering so that models that make use of such
    domains may introduce model elements that involve statements
    about the order of the terms in a domain."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CV
    def __init__(self, nullFlavor=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, translation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CO, self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CO.subclass:
            return CO.subclass(*args_, **kwargs_)
        else:
            return CO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (
            super(CO, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CO')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CO', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CO'):
        super(CO, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CO')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CO', fromsubclass_=False, pretty_print=True):
        super(CO, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CO, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CO, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CO


class CR(ANY):
    """A concept qualifier code with optionally named role.
    Both qualifier role and value codes must be defined by
    the coding system. For example, if SNOMED RT defines a
    concept "leg", a role relation "has-laterality", and
    another concept "left", the concept role relation allows
    to add the qualifier "has-laterality: left" to a primary
    code "leg" to construct the meaning "left leg".
    Indicates if the sense of the role name is inverted.
    This can be used in cases where the underlying code
    system defines inversion but does not provide reciprocal
    pairs of role names. By default, inverted is false."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, inverted='false', name=None, value=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CR, self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.inverted = _cast(bool, inverted)
        self.inverted_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CR.subclass:
            return CR.subclass(*args_, **kwargs_)
        else:
            return CR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_inverted(self):
        return self.inverted
    def set_inverted(self, inverted):
        self.inverted = inverted
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bn(self, value):
        # Validate type bn, a restriction on bl.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bn_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bn_patterns_, ))
    validate_bn_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(CR, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='CR', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CR':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CR', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CR'):
        super(CR, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CR')
        if self.inverted != "false" and 'inverted' not in already_processed:
            already_processed.add('inverted')
            outfile.write(' inverted=%s' % (quote_attrib(self.inverted), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='CR', fromsubclass_=False, pretty_print=True):
        super(CR, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inverted', node)
        if value is not None and 'inverted' not in already_processed:
            already_processed.add('inverted')
            if value in ('true', '1'):
                self.inverted = True
            elif value in ('false', '0'):
                self.inverted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bn(self.inverted)    # validate type bn
        super(CR, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CV)
            class_obj_ = CV.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'name', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_name'):
              self.add_name(obj_.value)
            elif hasattr(self, 'set_name'):
              self.set_name(obj_.value)
        elif nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, CD)
            class_obj_ = CD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'value', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_value'):
              self.add_value(obj_.value)
            elif hasattr(self, 'set_value'):
              self.set_value(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(CR, self).buildChildren(child_, node, nodeName_, True)
# end class CR


class SC(ST):
    """A ST that optionally may have a code attached.
    The text must always be present if a code is present. The
    code is often a local code.
    The plain code symbol defined by the code system.
    For example, "784.0" is the code symbol of the ICD-9
    code "784.0" for headache.
    Specifies the code system that defines the code.
    A common name of the coding system.
    If applicable, a version descriptor defined
    specifically for the given code system.
    A name or title for the code, under which the sending
    system shows the code value to its users."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ST
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SC, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, valueOf_, mixedclass_, content_,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.codeSystemVersion_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SC)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SC.subclass:
            return SC.subclass(*args_, **kwargs_)
        else:
            return SC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self):
        return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion):
        self.codeSystemVersion = codeSystemVersion
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SC, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SC', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SC')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SC':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SC')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SC', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SC'):
        super(SC, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SC')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemVersion), input_name='codeSystemVersion')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SC', fromsubclass_=False, pretty_print=True):
        super(SC, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        super(SC, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SC, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SC


class II(ANY):
    """An identifier that uniquely identifies a thing or object.
    Examples are object identifier for HL7 RIM objects,
    medical record number, order id, service catalog item id,
    Vehicle Identification Number (VIN), etc. Instance
    identifiers are defined based on ISO object identifiers.
    A unique identifier that guarantees the global uniqueness
    of the instance identifier. The root alone may be the
    entire instance identifier.
    A character string as a unique identifier within the
    scope of the identifier root.
    A human readable name or mnemonic for the assigning
    authority. This name may be provided solely for the
    convenience of unaided humans interpreting an II value
    and can have no computational meaning. Note: no
    automated processing must depend on the assigning
    authority name to be present in any form.
    Specifies if the identifier is intended for human
    display and data entry (displayable = true) as
    opposed to pure machine interoperation (displayable
    = false)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, root=None, extension=None, assigningAuthorityName=None, displayable=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(II, self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.root = _cast(None, root)
        self.root_nsprefix_ = None
        self.extension = _cast(None, extension)
        self.extension_nsprefix_ = None
        self.assigningAuthorityName = _cast(None, assigningAuthorityName)
        self.assigningAuthorityName_nsprefix_ = None
        self.displayable = _cast(bool, displayable)
        self.displayable_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, II)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if II.subclass:
            return II.subclass(*args_, **kwargs_)
        else:
            return II(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_root(self):
        return self.root
    def set_root(self, root):
        self.root = root
    def get_extension(self):
        return self.extension
    def set_extension(self, extension):
        self.extension = extension
    def get_assigningAuthorityName(self):
        return self.assigningAuthorityName
    def set_assigningAuthorityName(self, assigningAuthorityName):
        self.assigningAuthorityName = assigningAuthorityName
    def get_displayable(self):
        return self.displayable
    def set_displayable(self, displayable):
        self.displayable = displayable
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(II, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='II', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('II')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'II':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='II')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='II'):
        super(II, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='II')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.extension), input_name='extension')), ))
        if self.assigningAuthorityName is not None and 'assigningAuthorityName' not in already_processed:
            already_processed.add('assigningAuthorityName')
            outfile.write(' assigningAuthorityName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.assigningAuthorityName), input_name='assigningAuthorityName')), ))
        if self.displayable is not None and 'displayable' not in already_processed:
            already_processed.add('displayable')
            outfile.write(' displayable="%s"' % self.gds_format_boolean(self.displayable, input_name='displayable'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='II', fromsubclass_=False, pretty_print=True):
        super(II, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_uid(self.root)    # validate type uid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        value = find_attr_value_('assigningAuthorityName', node)
        if value is not None and 'assigningAuthorityName' not in already_processed:
            already_processed.add('assigningAuthorityName')
            self.assigningAuthorityName = value
            self.validate_st(self.assigningAuthorityName)    # validate type st
        value = find_attr_value_('displayable', node)
        if value is not None and 'displayable' not in already_processed:
            already_processed.add('displayable')
            if value in ('true', '1'):
                self.displayable = True
            elif value in ('false', '0'):
                self.displayable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.displayable)    # validate type bl
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(II, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(II, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class II


class URL(ANY):
    """A telecommunications address specified according to
    Internet standard RFC 1738
    [http://www.ietf.org/rfc/rfc1738.txt]. The
    URL specifies the protocol and the contact point defined
    by that protocol for the resource. Notable uses of the
    telecommunication address data type are for telephone and
    telefax numbers, e-mail addresses, Hypertext references,
    FTP references, etc."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, value=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(URL, self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, URL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if URL.subclass:
            return URL.subclass(*args_, **kwargs_)
        else:
            return URL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_url(self, value):
        # Validate type url, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(URL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='URL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('URL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'URL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='URL')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='URL'):
        super(URL, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='URL')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='URL', fromsubclass_=False, pretty_print=True):
        super(URL, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_url(self.value)    # validate type url
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(URL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(URL, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class URL


class TEL(URL):
    """A telephone number (voice or fax), e-mail address, or
    other locator for a resource (information or service)
    mediated by telecommunication equipment. The address
    is specified as a Universal Resource Locator (URL)
    qualified by time specification and use codes that help
    in deciding which address to use for a given time and
    purpose.
    One or more codes advising a system or user which
    telecommunication address in a set of like addresses
    to select for a given telecommunication need."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = URL
    def __init__(self, nullFlavor=None, value=None, use=None, useablePeriod=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TEL, self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.use = _cast(None, use)
        self.use_nsprefix_ = None
        if useablePeriod is None:
            self.useablePeriod = []
        else:
            self.useablePeriod = useablePeriod
        self.useablePeriod_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEL.subclass:
            return TEL.subclass(*args_, **kwargs_)
        else:
            return TEL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_useablePeriod(self):
        return self.useablePeriod
    def set_useablePeriod(self, useablePeriod):
        self.useablePeriod = useablePeriod
    def add_useablePeriod(self, value):
        self.useablePeriod.append(value)
    def insert_useablePeriod_at(self, index, value):
        self.useablePeriod.insert(index, value)
    def replace_useablePeriod_at(self, index, value):
        self.useablePeriod[index] = value
    def get_use(self):
        return self.use
    def set_use(self, use):
        self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_TelecommunicationAddressUse(self, value):
        # Validate type set_TelecommunicationAddressUse, a restriction on TelecommunicationAddressUse.
        pass
    def hasContent_(self):
        if (
            self.useablePeriod or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(TEL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='TEL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEL'):
        super(TEL, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEL')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='TEL', fromsubclass_=False, pretty_print=True):
        super(TEL, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for useablePeriod_ in self.useablePeriod:
            namespaceprefix_ = self.useablePeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.useablePeriod_nsprefix_) else ''
            useablePeriod_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='useablePeriod', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.use = ' '.join(self.use.split())
            self.validate_set_TelecommunicationAddressUse(self.use)    # validate type set_TelecommunicationAddressUse
        super(TEL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'useablePeriod':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            class_obj_ = SXCM_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'useablePeriod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_useablePeriod'):
              self.add_useablePeriod(obj_.value)
            elif hasattr(self, 'set_useablePeriod'):
              self.set_useablePeriod(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(TEL, self).buildChildren(child_, node, nodeName_, True)
# end class TEL


class ADXP(ST):
    """A character string that may have a type-tag signifying its
    role in the address. Typical parts that exist in about
    every address are street, house number, or post box,
    postal code, city, country but other roles may be defined
    regionally, nationally, or on an enterprise level (e.g. in
    military addresses). Addresses are usually broken up into
    lines, which are indicated by special line-breaking
    delimiter elements (e.g., DEL).
    Specifies whether an address part names the street,
    city, country, postal code, post box, etc. If the type
    is NULL the address part is unclassified and would
    simply appear on an address label as is."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ST
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ADXP, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADXP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADXP.subclass:
            return ADXP.subclass(*args_, **kwargs_)
        else:
            return ADXP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ADXP, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ADXP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ADXP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ADXP':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ADXP')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ADXP', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ADXP'):
        super(ADXP, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ADXP')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ADXP', fromsubclass_=False, pretty_print=True):
        super(ADXP, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(ADXP, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ADXP, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ADXP


class adxp_delimiter(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_delimiter, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_delimiter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_delimiter.subclass:
            return adxp_delimiter.subclass(*args_, **kwargs_)
        else:
            return adxp_delimiter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_delimiter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.delimiter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.delimiter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.delimiter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.delimiter')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.delimiter'):
        super(adxp_delimiter, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.delimiter')
        if self.partType != "DEL" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.delimiter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_delimiter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_delimiter


class adxp_country(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_country, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_country)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_country.subclass:
            return adxp_country.subclass(*args_, **kwargs_)
        else:
            return adxp_country(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_country, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.country', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.country')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.country':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.country')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.country'):
        super(adxp_country, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.country')
        if self.partType != "CNT" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.country', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_country, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_country


class adxp_state(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_state, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_state)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_state.subclass:
            return adxp_state.subclass(*args_, **kwargs_)
        else:
            return adxp_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_state, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.state', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.state')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.state':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.state')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.state'):
        super(adxp_state, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.state')
        if self.partType != "STA" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.state', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_state, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_state


class adxp_county(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_county, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_county)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_county.subclass:
            return adxp_county.subclass(*args_, **kwargs_)
        else:
            return adxp_county(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_county, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.county', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.county')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.county':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.county')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.county'):
        super(adxp_county, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.county')
        if self.partType != "CPA" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.county', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_county, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_county


class adxp_city(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_city, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_city)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_city.subclass:
            return adxp_city.subclass(*args_, **kwargs_)
        else:
            return adxp_city(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_city, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.city', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.city')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.city':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.city')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.city'):
        super(adxp_city, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.city')
        if self.partType != "CTY" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.city', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_city, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_city


class adxp_postalCode(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_postalCode, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_postalCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_postalCode.subclass:
            return adxp_postalCode.subclass(*args_, **kwargs_)
        else:
            return adxp_postalCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_postalCode, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.postalCode', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.postalCode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.postalCode':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.postalCode')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.postalCode'):
        super(adxp_postalCode, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.postalCode')
        if self.partType != "ZIP" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.postalCode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_postalCode, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_postalCode


class adxp_streetAddressLine(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_streetAddressLine, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_streetAddressLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_streetAddressLine.subclass:
            return adxp_streetAddressLine.subclass(*args_, **kwargs_)
        else:
            return adxp_streetAddressLine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_streetAddressLine, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetAddressLine', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.streetAddressLine')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.streetAddressLine':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetAddressLine')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.streetAddressLine'):
        super(adxp_streetAddressLine, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetAddressLine')
        if self.partType != "SAL" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetAddressLine', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_streetAddressLine, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_streetAddressLine


class adxp_houseNumber(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_houseNumber, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_houseNumber)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_houseNumber.subclass:
            return adxp_houseNumber.subclass(*args_, **kwargs_)
        else:
            return adxp_houseNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_houseNumber, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.houseNumber', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.houseNumber')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.houseNumber':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.houseNumber')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.houseNumber'):
        super(adxp_houseNumber, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.houseNumber')
        if self.partType != "BNR" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.houseNumber', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_houseNumber, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_houseNumber


class adxp_houseNumberNumeric(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_houseNumberNumeric, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_houseNumberNumeric)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_houseNumberNumeric.subclass:
            return adxp_houseNumberNumeric.subclass(*args_, **kwargs_)
        else:
            return adxp_houseNumberNumeric(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_houseNumberNumeric, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.houseNumberNumeric', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.houseNumberNumeric')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.houseNumberNumeric':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.houseNumberNumeric')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.houseNumberNumeric'):
        super(adxp_houseNumberNumeric, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.houseNumberNumeric')
        if self.partType != "BNN" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.houseNumberNumeric', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_houseNumberNumeric, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_houseNumberNumeric


class adxp_direction(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_direction, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_direction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_direction.subclass:
            return adxp_direction.subclass(*args_, **kwargs_)
        else:
            return adxp_direction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_direction, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.direction', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.direction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.direction':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.direction')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.direction'):
        super(adxp_direction, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.direction')
        if self.partType != "DIR" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.direction', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_direction, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_direction


class adxp_streetName(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_streetName, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_streetName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_streetName.subclass:
            return adxp_streetName.subclass(*args_, **kwargs_)
        else:
            return adxp_streetName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_streetName, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetName', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.streetName')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.streetName':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetName')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.streetName'):
        super(adxp_streetName, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetName')
        if self.partType != "STR" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_streetName, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_streetName


class adxp_streetNameBase(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_streetNameBase, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_streetNameBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_streetNameBase.subclass:
            return adxp_streetNameBase.subclass(*args_, **kwargs_)
        else:
            return adxp_streetNameBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_streetNameBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetNameBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.streetNameBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.streetNameBase':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetNameBase')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.streetNameBase'):
        super(adxp_streetNameBase, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetNameBase')
        if self.partType != "STB" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetNameBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_streetNameBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_streetNameBase


class adxp_streetNameType(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_streetNameType, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_streetNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_streetNameType.subclass:
            return adxp_streetNameType.subclass(*args_, **kwargs_)
        else:
            return adxp_streetNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_streetNameType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetNameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.streetNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.streetNameType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetNameType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.streetNameType'):
        super(adxp_streetNameType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.streetNameType')
        if self.partType != "STTYP" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.streetNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_streetNameType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_streetNameType


class adxp_additionalLocator(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_additionalLocator, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_additionalLocator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_additionalLocator.subclass:
            return adxp_additionalLocator.subclass(*args_, **kwargs_)
        else:
            return adxp_additionalLocator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_additionalLocator, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.additionalLocator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.additionalLocator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.additionalLocator':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.additionalLocator')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.additionalLocator'):
        super(adxp_additionalLocator, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.additionalLocator')
        if self.partType != "ADL" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.additionalLocator', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_additionalLocator, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_additionalLocator


class adxp_unitID(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_unitID, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_unitID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_unitID.subclass:
            return adxp_unitID.subclass(*args_, **kwargs_)
        else:
            return adxp_unitID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_unitID, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.unitID', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.unitID')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.unitID':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.unitID')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.unitID'):
        super(adxp_unitID, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.unitID')
        if self.partType != "UNID" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.unitID', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_unitID, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_unitID


class adxp_unitType(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_unitType, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_unitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_unitType.subclass:
            return adxp_unitType.subclass(*args_, **kwargs_)
        else:
            return adxp_unitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_unitType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.unitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.unitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.unitType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.unitType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.unitType'):
        super(adxp_unitType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.unitType')
        if self.partType != "UNIT" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.unitType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_unitType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_unitType


class adxp_careOf(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_careOf, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_careOf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_careOf.subclass:
            return adxp_careOf.subclass(*args_, **kwargs_)
        else:
            return adxp_careOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_careOf, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.careOf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.careOf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.careOf':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.careOf')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.careOf'):
        super(adxp_careOf, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.careOf')
        if self.partType != "CAR" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.careOf', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_careOf, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_careOf


class adxp_censusTract(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_censusTract, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_censusTract)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_censusTract.subclass:
            return adxp_censusTract.subclass(*args_, **kwargs_)
        else:
            return adxp_censusTract(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_censusTract, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.censusTract', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.censusTract')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.censusTract':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.censusTract')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.censusTract'):
        super(adxp_censusTract, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.censusTract')
        if self.partType != "CEN" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.censusTract', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_censusTract, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_censusTract


class adxp_deliveryAddressLine(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_deliveryAddressLine, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryAddressLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryAddressLine.subclass:
            return adxp_deliveryAddressLine.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryAddressLine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryAddressLine, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryAddressLine', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryAddressLine')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryAddressLine':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryAddressLine')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryAddressLine'):
        super(adxp_deliveryAddressLine, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryAddressLine')
        if self.partType != "DAL" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryAddressLine', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryAddressLine, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryAddressLine


class adxp_deliveryInstallationType(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_deliveryInstallationType, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryInstallationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryInstallationType.subclass:
            return adxp_deliveryInstallationType.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryInstallationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryInstallationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryInstallationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryInstallationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryInstallationType'):
        super(adxp_deliveryInstallationType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationType')
        if self.partType != "DINST" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryInstallationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryInstallationType


class adxp_deliveryInstallationArea(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_deliveryInstallationArea, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryInstallationArea)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryInstallationArea.subclass:
            return adxp_deliveryInstallationArea.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryInstallationArea(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryInstallationArea, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationArea', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryInstallationArea')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryInstallationArea':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationArea')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryInstallationArea'):
        super(adxp_deliveryInstallationArea, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationArea')
        if self.partType != "DINSTA" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationArea', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryInstallationArea, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryInstallationArea


class adxp_deliveryInstallationQualifier(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_deliveryInstallationQualifier, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryInstallationQualifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryInstallationQualifier.subclass:
            return adxp_deliveryInstallationQualifier.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryInstallationQualifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryInstallationQualifier, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationQualifier', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryInstallationQualifier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryInstallationQualifier':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationQualifier')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryInstallationQualifier'):
        super(adxp_deliveryInstallationQualifier, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryInstallationQualifier')
        if self.partType != "DINSTQ" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryInstallationQualifier', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryInstallationQualifier, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryInstallationQualifier


class adxp_deliveryMode(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_deliveryMode, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryMode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryMode.subclass:
            return adxp_deliveryMode.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryMode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryMode, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryMode', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryMode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryMode':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryMode')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryMode'):
        super(adxp_deliveryMode, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryMode')
        if self.partType != "DMOD" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryMode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryMode, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryMode


class adxp_deliveryModeIdentifier(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_deliveryModeIdentifier, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_deliveryModeIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_deliveryModeIdentifier.subclass:
            return adxp_deliveryModeIdentifier.subclass(*args_, **kwargs_)
        else:
            return adxp_deliveryModeIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_deliveryModeIdentifier, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryModeIdentifier', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.deliveryModeIdentifier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.deliveryModeIdentifier':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryModeIdentifier')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.deliveryModeIdentifier'):
        super(adxp_deliveryModeIdentifier, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.deliveryModeIdentifier')
        if self.partType != "DMODID" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.deliveryModeIdentifier', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_deliveryModeIdentifier, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_deliveryModeIdentifier


class adxp_buildingNumberSuffix(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_buildingNumberSuffix, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_buildingNumberSuffix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_buildingNumberSuffix.subclass:
            return adxp_buildingNumberSuffix.subclass(*args_, **kwargs_)
        else:
            return adxp_buildingNumberSuffix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_buildingNumberSuffix, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.buildingNumberSuffix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.buildingNumberSuffix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.buildingNumberSuffix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.buildingNumberSuffix')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.buildingNumberSuffix'):
        super(adxp_buildingNumberSuffix, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.buildingNumberSuffix')
        if self.partType != "BNS" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.buildingNumberSuffix', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_buildingNumberSuffix, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_buildingNumberSuffix


class adxp_postBox(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_postBox, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_postBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_postBox.subclass:
            return adxp_postBox.subclass(*args_, **kwargs_)
        else:
            return adxp_postBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_postBox, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.postBox', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.postBox')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.postBox':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.postBox')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.postBox'):
        super(adxp_postBox, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.postBox')
        if self.partType != "POB" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.postBox', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_postBox, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_postBox


class adxp_precinct(ADXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(adxp_precinct, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adxp_precinct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adxp_precinct.subclass:
            return adxp_precinct.subclass(*args_, **kwargs_)
        else:
            return adxp_precinct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_AddressPartType(self, value):
        # Validate type AddressPartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(adxp_precinct, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.precinct', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adxp.precinct')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adxp.precinct':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.precinct')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adxp.precinct'):
        super(adxp_precinct, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adxp.precinct')
        if self.partType != "PRE" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adxp.precinct', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_AddressPartType(self.partType)    # validate type AddressPartType
        super(adxp_precinct, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class adxp_precinct


class AD(ANY):
    """Mailing and home or office addresses. A sequence of
    address parts, such as street or post office Box, city,
    postal code, country, etc.
    A set of codes advising a system or user which address
    in a set of like addresses to select for a given purpose.
    A boolean value specifying whether the order of the
    address parts is known or not. While the address parts
    are always a Sequence, the order in which they are
    presented may or may not be known. Where this matters, the
    isNotOrdered property can be used to convey this
    information."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, use=None, isNotOrdered=None, delimiter=None, country=None, state=None, county=None, city=None, postalCode=None, streetAddressLine=None, houseNumber=None, houseNumberNumeric=None, direction=None, streetName=None, streetNameBase=None, streetNameType=None, additionalLocator=None, unitID=None, unitType=None, careOf=None, censusTract=None, deliveryAddressLine=None, deliveryInstallationType=None, deliveryInstallationArea=None, deliveryInstallationQualifier=None, deliveryMode=None, deliveryModeIdentifier=None, buildingNumberSuffix=None, postBox=None, precinct=None, useablePeriod=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AD, self).__init__(nullFlavor, valueOf_, mixedclass_, content_,  **kwargs_)
        self.use = _cast(None, use)
        self.use_nsprefix_ = None
        self.isNotOrdered = _cast(bool, isNotOrdered)
        self.isNotOrdered_nsprefix_ = None
        if delimiter is None:
            self.delimiter = []
        else:
            self.delimiter = delimiter
        self.delimiter_nsprefix_ = None
        if country is None:
            self.country = []
        else:
            self.country = country
        self.country_nsprefix_ = None
        if state is None:
            self.state = []
        else:
            self.state = state
        self.state_nsprefix_ = None
        if county is None:
            self.county = []
        else:
            self.county = county
        self.county_nsprefix_ = None
        if city is None:
            self.city = []
        else:
            self.city = city
        self.city_nsprefix_ = None
        if postalCode is None:
            self.postalCode = []
        else:
            self.postalCode = postalCode
        self.postalCode_nsprefix_ = None
        if streetAddressLine is None:
            self.streetAddressLine = []
        else:
            self.streetAddressLine = streetAddressLine
        self.streetAddressLine_nsprefix_ = None
        if houseNumber is None:
            self.houseNumber = []
        else:
            self.houseNumber = houseNumber
        self.houseNumber_nsprefix_ = None
        if houseNumberNumeric is None:
            self.houseNumberNumeric = []
        else:
            self.houseNumberNumeric = houseNumberNumeric
        self.houseNumberNumeric_nsprefix_ = None
        if direction is None:
            self.direction = []
        else:
            self.direction = direction
        self.direction_nsprefix_ = None
        if streetName is None:
            self.streetName = []
        else:
            self.streetName = streetName
        self.streetName_nsprefix_ = None
        if streetNameBase is None:
            self.streetNameBase = []
        else:
            self.streetNameBase = streetNameBase
        self.streetNameBase_nsprefix_ = None
        if streetNameType is None:
            self.streetNameType = []
        else:
            self.streetNameType = streetNameType
        self.streetNameType_nsprefix_ = None
        if additionalLocator is None:
            self.additionalLocator = []
        else:
            self.additionalLocator = additionalLocator
        self.additionalLocator_nsprefix_ = None
        if unitID is None:
            self.unitID = []
        else:
            self.unitID = unitID
        self.unitID_nsprefix_ = None
        if unitType is None:
            self.unitType = []
        else:
            self.unitType = unitType
        self.unitType_nsprefix_ = None
        if careOf is None:
            self.careOf = []
        else:
            self.careOf = careOf
        self.careOf_nsprefix_ = None
        if censusTract is None:
            self.censusTract = []
        else:
            self.censusTract = censusTract
        self.censusTract_nsprefix_ = None
        if deliveryAddressLine is None:
            self.deliveryAddressLine = []
        else:
            self.deliveryAddressLine = deliveryAddressLine
        self.deliveryAddressLine_nsprefix_ = None
        if deliveryInstallationType is None:
            self.deliveryInstallationType = []
        else:
            self.deliveryInstallationType = deliveryInstallationType
        self.deliveryInstallationType_nsprefix_ = None
        if deliveryInstallationArea is None:
            self.deliveryInstallationArea = []
        else:
            self.deliveryInstallationArea = deliveryInstallationArea
        self.deliveryInstallationArea_nsprefix_ = None
        if deliveryInstallationQualifier is None:
            self.deliveryInstallationQualifier = []
        else:
            self.deliveryInstallationQualifier = deliveryInstallationQualifier
        self.deliveryInstallationQualifier_nsprefix_ = None
        if deliveryMode is None:
            self.deliveryMode = []
        else:
            self.deliveryMode = deliveryMode
        self.deliveryMode_nsprefix_ = None
        if deliveryModeIdentifier is None:
            self.deliveryModeIdentifier = []
        else:
            self.deliveryModeIdentifier = deliveryModeIdentifier
        self.deliveryModeIdentifier_nsprefix_ = None
        if buildingNumberSuffix is None:
            self.buildingNumberSuffix = []
        else:
            self.buildingNumberSuffix = buildingNumberSuffix
        self.buildingNumberSuffix_nsprefix_ = None
        if postBox is None:
            self.postBox = []
        else:
            self.postBox = postBox
        self.postBox_nsprefix_ = None
        if precinct is None:
            self.precinct = []
        else:
            self.precinct = precinct
        self.precinct_nsprefix_ = None
        if useablePeriod is None:
            self.useablePeriod = []
        else:
            self.useablePeriod = useablePeriod
        self.useablePeriod_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AD.subclass:
            return AD.subclass(*args_, **kwargs_)
        else:
            return AD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_delimiter(self):
        return self.delimiter
    def set_delimiter(self, delimiter):
        self.delimiter = delimiter
    def add_delimiter(self, value):
        self.delimiter.append(value)
    def insert_delimiter_at(self, index, value):
        self.delimiter.insert(index, value)
    def replace_delimiter_at(self, index, value):
        self.delimiter[index] = value
    def get_country(self):
        return self.country
    def set_country(self, country):
        self.country = country
    def add_country(self, value):
        self.country.append(value)
    def insert_country_at(self, index, value):
        self.country.insert(index, value)
    def replace_country_at(self, index, value):
        self.country[index] = value
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def add_state(self, value):
        self.state.append(value)
    def insert_state_at(self, index, value):
        self.state.insert(index, value)
    def replace_state_at(self, index, value):
        self.state[index] = value
    def get_county(self):
        return self.county
    def set_county(self, county):
        self.county = county
    def add_county(self, value):
        self.county.append(value)
    def insert_county_at(self, index, value):
        self.county.insert(index, value)
    def replace_county_at(self, index, value):
        self.county[index] = value
    def get_city(self):
        return self.city
    def set_city(self, city):
        self.city = city
    def add_city(self, value):
        self.city.append(value)
    def insert_city_at(self, index, value):
        self.city.insert(index, value)
    def replace_city_at(self, index, value):
        self.city[index] = value
    def get_postalCode(self):
        return self.postalCode
    def set_postalCode(self, postalCode):
        self.postalCode = postalCode
    def add_postalCode(self, value):
        self.postalCode.append(value)
    def insert_postalCode_at(self, index, value):
        self.postalCode.insert(index, value)
    def replace_postalCode_at(self, index, value):
        self.postalCode[index] = value
    def get_streetAddressLine(self):
        return self.streetAddressLine
    def set_streetAddressLine(self, streetAddressLine):
        self.streetAddressLine = streetAddressLine
    def add_streetAddressLine(self, value):
        self.streetAddressLine.append(value)
    def insert_streetAddressLine_at(self, index, value):
        self.streetAddressLine.insert(index, value)
    def replace_streetAddressLine_at(self, index, value):
        self.streetAddressLine[index] = value
    def get_houseNumber(self):
        return self.houseNumber
    def set_houseNumber(self, houseNumber):
        self.houseNumber = houseNumber
    def add_houseNumber(self, value):
        self.houseNumber.append(value)
    def insert_houseNumber_at(self, index, value):
        self.houseNumber.insert(index, value)
    def replace_houseNumber_at(self, index, value):
        self.houseNumber[index] = value
    def get_houseNumberNumeric(self):
        return self.houseNumberNumeric
    def set_houseNumberNumeric(self, houseNumberNumeric):
        self.houseNumberNumeric = houseNumberNumeric
    def add_houseNumberNumeric(self, value):
        self.houseNumberNumeric.append(value)
    def insert_houseNumberNumeric_at(self, index, value):
        self.houseNumberNumeric.insert(index, value)
    def replace_houseNumberNumeric_at(self, index, value):
        self.houseNumberNumeric[index] = value
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def add_direction(self, value):
        self.direction.append(value)
    def insert_direction_at(self, index, value):
        self.direction.insert(index, value)
    def replace_direction_at(self, index, value):
        self.direction[index] = value
    def get_streetName(self):
        return self.streetName
    def set_streetName(self, streetName):
        self.streetName = streetName
    def add_streetName(self, value):
        self.streetName.append(value)
    def insert_streetName_at(self, index, value):
        self.streetName.insert(index, value)
    def replace_streetName_at(self, index, value):
        self.streetName[index] = value
    def get_streetNameBase(self):
        return self.streetNameBase
    def set_streetNameBase(self, streetNameBase):
        self.streetNameBase = streetNameBase
    def add_streetNameBase(self, value):
        self.streetNameBase.append(value)
    def insert_streetNameBase_at(self, index, value):
        self.streetNameBase.insert(index, value)
    def replace_streetNameBase_at(self, index, value):
        self.streetNameBase[index] = value
    def get_streetNameType(self):
        return self.streetNameType
    def set_streetNameType(self, streetNameType):
        self.streetNameType = streetNameType
    def add_streetNameType(self, value):
        self.streetNameType.append(value)
    def insert_streetNameType_at(self, index, value):
        self.streetNameType.insert(index, value)
    def replace_streetNameType_at(self, index, value):
        self.streetNameType[index] = value
    def get_additionalLocator(self):
        return self.additionalLocator
    def set_additionalLocator(self, additionalLocator):
        self.additionalLocator = additionalLocator
    def add_additionalLocator(self, value):
        self.additionalLocator.append(value)
    def insert_additionalLocator_at(self, index, value):
        self.additionalLocator.insert(index, value)
    def replace_additionalLocator_at(self, index, value):
        self.additionalLocator[index] = value
    def get_unitID(self):
        return self.unitID
    def set_unitID(self, unitID):
        self.unitID = unitID
    def add_unitID(self, value):
        self.unitID.append(value)
    def insert_unitID_at(self, index, value):
        self.unitID.insert(index, value)
    def replace_unitID_at(self, index, value):
        self.unitID[index] = value
    def get_unitType(self):
        return self.unitType
    def set_unitType(self, unitType):
        self.unitType = unitType
    def add_unitType(self, value):
        self.unitType.append(value)
    def insert_unitType_at(self, index, value):
        self.unitType.insert(index, value)
    def replace_unitType_at(self, index, value):
        self.unitType[index] = value
    def get_careOf(self):
        return self.careOf
    def set_careOf(self, careOf):
        self.careOf = careOf
    def add_careOf(self, value):
        self.careOf.append(value)
    def insert_careOf_at(self, index, value):
        self.careOf.insert(index, value)
    def replace_careOf_at(self, index, value):
        self.careOf[index] = value
    def get_censusTract(self):
        return self.censusTract
    def set_censusTract(self, censusTract):
        self.censusTract = censusTract
    def add_censusTract(self, value):
        self.censusTract.append(value)
    def insert_censusTract_at(self, index, value):
        self.censusTract.insert(index, value)
    def replace_censusTract_at(self, index, value):
        self.censusTract[index] = value
    def get_deliveryAddressLine(self):
        return self.deliveryAddressLine
    def set_deliveryAddressLine(self, deliveryAddressLine):
        self.deliveryAddressLine = deliveryAddressLine
    def add_deliveryAddressLine(self, value):
        self.deliveryAddressLine.append(value)
    def insert_deliveryAddressLine_at(self, index, value):
        self.deliveryAddressLine.insert(index, value)
    def replace_deliveryAddressLine_at(self, index, value):
        self.deliveryAddressLine[index] = value
    def get_deliveryInstallationType(self):
        return self.deliveryInstallationType
    def set_deliveryInstallationType(self, deliveryInstallationType):
        self.deliveryInstallationType = deliveryInstallationType
    def add_deliveryInstallationType(self, value):
        self.deliveryInstallationType.append(value)
    def insert_deliveryInstallationType_at(self, index, value):
        self.deliveryInstallationType.insert(index, value)
    def replace_deliveryInstallationType_at(self, index, value):
        self.deliveryInstallationType[index] = value
    def get_deliveryInstallationArea(self):
        return self.deliveryInstallationArea
    def set_deliveryInstallationArea(self, deliveryInstallationArea):
        self.deliveryInstallationArea = deliveryInstallationArea
    def add_deliveryInstallationArea(self, value):
        self.deliveryInstallationArea.append(value)
    def insert_deliveryInstallationArea_at(self, index, value):
        self.deliveryInstallationArea.insert(index, value)
    def replace_deliveryInstallationArea_at(self, index, value):
        self.deliveryInstallationArea[index] = value
    def get_deliveryInstallationQualifier(self):
        return self.deliveryInstallationQualifier
    def set_deliveryInstallationQualifier(self, deliveryInstallationQualifier):
        self.deliveryInstallationQualifier = deliveryInstallationQualifier
    def add_deliveryInstallationQualifier(self, value):
        self.deliveryInstallationQualifier.append(value)
    def insert_deliveryInstallationQualifier_at(self, index, value):
        self.deliveryInstallationQualifier.insert(index, value)
    def replace_deliveryInstallationQualifier_at(self, index, value):
        self.deliveryInstallationQualifier[index] = value
    def get_deliveryMode(self):
        return self.deliveryMode
    def set_deliveryMode(self, deliveryMode):
        self.deliveryMode = deliveryMode
    def add_deliveryMode(self, value):
        self.deliveryMode.append(value)
    def insert_deliveryMode_at(self, index, value):
        self.deliveryMode.insert(index, value)
    def replace_deliveryMode_at(self, index, value):
        self.deliveryMode[index] = value
    def get_deliveryModeIdentifier(self):
        return self.deliveryModeIdentifier
    def set_deliveryModeIdentifier(self, deliveryModeIdentifier):
        self.deliveryModeIdentifier = deliveryModeIdentifier
    def add_deliveryModeIdentifier(self, value):
        self.deliveryModeIdentifier.append(value)
    def insert_deliveryModeIdentifier_at(self, index, value):
        self.deliveryModeIdentifier.insert(index, value)
    def replace_deliveryModeIdentifier_at(self, index, value):
        self.deliveryModeIdentifier[index] = value
    def get_buildingNumberSuffix(self):
        return self.buildingNumberSuffix
    def set_buildingNumberSuffix(self, buildingNumberSuffix):
        self.buildingNumberSuffix = buildingNumberSuffix
    def add_buildingNumberSuffix(self, value):
        self.buildingNumberSuffix.append(value)
    def insert_buildingNumberSuffix_at(self, index, value):
        self.buildingNumberSuffix.insert(index, value)
    def replace_buildingNumberSuffix_at(self, index, value):
        self.buildingNumberSuffix[index] = value
    def get_postBox(self):
        return self.postBox
    def set_postBox(self, postBox):
        self.postBox = postBox
    def add_postBox(self, value):
        self.postBox.append(value)
    def insert_postBox_at(self, index, value):
        self.postBox.insert(index, value)
    def replace_postBox_at(self, index, value):
        self.postBox[index] = value
    def get_precinct(self):
        return self.precinct
    def set_precinct(self, precinct):
        self.precinct = precinct
    def add_precinct(self, value):
        self.precinct.append(value)
    def insert_precinct_at(self, index, value):
        self.precinct.insert(index, value)
    def replace_precinct_at(self, index, value):
        self.precinct[index] = value
    def get_useablePeriod(self):
        return self.useablePeriod
    def set_useablePeriod(self, useablePeriod):
        self.useablePeriod = useablePeriod
    def add_useablePeriod(self, value):
        self.useablePeriod.append(value)
    def insert_useablePeriod_at(self, index, value):
        self.useablePeriod.insert(index, value)
    def replace_useablePeriod_at(self, index, value):
        self.useablePeriod[index] = value
    def get_use(self):
        return self.use
    def set_use(self, use):
        self.use = use
    def get_isNotOrdered(self):
        return self.isNotOrdered
    def set_isNotOrdered(self, isNotOrdered):
        self.isNotOrdered = isNotOrdered
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_PostalAddressUse(self, value):
        # Validate type set_PostalAddressUse, a restriction on PostalAddressUse.
        pass
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.delimiter or
            self.country or
            self.state or
            self.county or
            self.city or
            self.postalCode or
            self.streetAddressLine or
            self.houseNumber or
            self.houseNumberNumeric or
            self.direction or
            self.streetName or
            self.streetNameBase or
            self.streetNameType or
            self.additionalLocator or
            self.unitID or
            self.unitType or
            self.careOf or
            self.censusTract or
            self.deliveryAddressLine or
            self.deliveryInstallationType or
            self.deliveryInstallationArea or
            self.deliveryInstallationQualifier or
            self.deliveryMode or
            self.deliveryModeIdentifier or
            self.buildingNumberSuffix or
            self.postBox or
            self.precinct or
            self.useablePeriod or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(AD, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='AD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AD')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AD'):
        super(AD, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AD')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
        if self.isNotOrdered is not None and 'isNotOrdered' not in already_processed:
            already_processed.add('isNotOrdered')
            outfile.write(' isNotOrdered="%s"' % self.gds_format_boolean(self.isNotOrdered, input_name='isNotOrdered'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='AD', fromsubclass_=False, pretty_print=True):
        super(AD, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for delimiter_ in self.delimiter:
            namespaceprefix_ = self.delimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.delimiter_nsprefix_) else ''
            delimiter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='delimiter', pretty_print=pretty_print)
        for country_ in self.country:
            namespaceprefix_ = self.country_nsprefix_ + ':' if (UseCapturedNS_ and self.country_nsprefix_) else ''
            country_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='country', pretty_print=pretty_print)
        for state_ in self.state:
            namespaceprefix_ = self.state_nsprefix_ + ':' if (UseCapturedNS_ and self.state_nsprefix_) else ''
            state_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='state', pretty_print=pretty_print)
        for county_ in self.county:
            namespaceprefix_ = self.county_nsprefix_ + ':' if (UseCapturedNS_ and self.county_nsprefix_) else ''
            county_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='county', pretty_print=pretty_print)
        for city_ in self.city:
            namespaceprefix_ = self.city_nsprefix_ + ':' if (UseCapturedNS_ and self.city_nsprefix_) else ''
            city_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='city', pretty_print=pretty_print)
        for postalCode_ in self.postalCode:
            namespaceprefix_ = self.postalCode_nsprefix_ + ':' if (UseCapturedNS_ and self.postalCode_nsprefix_) else ''
            postalCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='postalCode', pretty_print=pretty_print)
        for streetAddressLine_ in self.streetAddressLine:
            namespaceprefix_ = self.streetAddressLine_nsprefix_ + ':' if (UseCapturedNS_ and self.streetAddressLine_nsprefix_) else ''
            streetAddressLine_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='streetAddressLine', pretty_print=pretty_print)
        for houseNumber_ in self.houseNumber:
            namespaceprefix_ = self.houseNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.houseNumber_nsprefix_) else ''
            houseNumber_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='houseNumber', pretty_print=pretty_print)
        for houseNumberNumeric_ in self.houseNumberNumeric:
            namespaceprefix_ = self.houseNumberNumeric_nsprefix_ + ':' if (UseCapturedNS_ and self.houseNumberNumeric_nsprefix_) else ''
            houseNumberNumeric_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='houseNumberNumeric', pretty_print=pretty_print)
        for direction_ in self.direction:
            namespaceprefix_ = self.direction_nsprefix_ + ':' if (UseCapturedNS_ and self.direction_nsprefix_) else ''
            direction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='direction', pretty_print=pretty_print)
        for streetName_ in self.streetName:
            namespaceprefix_ = self.streetName_nsprefix_ + ':' if (UseCapturedNS_ and self.streetName_nsprefix_) else ''
            streetName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='streetName', pretty_print=pretty_print)
        for streetNameBase_ in self.streetNameBase:
            namespaceprefix_ = self.streetNameBase_nsprefix_ + ':' if (UseCapturedNS_ and self.streetNameBase_nsprefix_) else ''
            streetNameBase_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='streetNameBase', pretty_print=pretty_print)
        for streetNameType_ in self.streetNameType:
            namespaceprefix_ = self.streetNameType_nsprefix_ + ':' if (UseCapturedNS_ and self.streetNameType_nsprefix_) else ''
            streetNameType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='streetNameType', pretty_print=pretty_print)
        for additionalLocator_ in self.additionalLocator:
            namespaceprefix_ = self.additionalLocator_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalLocator_nsprefix_) else ''
            additionalLocator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalLocator', pretty_print=pretty_print)
        for unitID_ in self.unitID:
            namespaceprefix_ = self.unitID_nsprefix_ + ':' if (UseCapturedNS_ and self.unitID_nsprefix_) else ''
            unitID_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unitID', pretty_print=pretty_print)
        for unitType_ in self.unitType:
            namespaceprefix_ = self.unitType_nsprefix_ + ':' if (UseCapturedNS_ and self.unitType_nsprefix_) else ''
            unitType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unitType', pretty_print=pretty_print)
        for careOf_ in self.careOf:
            namespaceprefix_ = self.careOf_nsprefix_ + ':' if (UseCapturedNS_ and self.careOf_nsprefix_) else ''
            careOf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='careOf', pretty_print=pretty_print)
        for censusTract_ in self.censusTract:
            namespaceprefix_ = self.censusTract_nsprefix_ + ':' if (UseCapturedNS_ and self.censusTract_nsprefix_) else ''
            censusTract_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='censusTract', pretty_print=pretty_print)
        for deliveryAddressLine_ in self.deliveryAddressLine:
            namespaceprefix_ = self.deliveryAddressLine_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryAddressLine_nsprefix_) else ''
            deliveryAddressLine_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryAddressLine', pretty_print=pretty_print)
        for deliveryInstallationType_ in self.deliveryInstallationType:
            namespaceprefix_ = self.deliveryInstallationType_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryInstallationType_nsprefix_) else ''
            deliveryInstallationType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryInstallationType', pretty_print=pretty_print)
        for deliveryInstallationArea_ in self.deliveryInstallationArea:
            namespaceprefix_ = self.deliveryInstallationArea_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryInstallationArea_nsprefix_) else ''
            deliveryInstallationArea_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryInstallationArea', pretty_print=pretty_print)
        for deliveryInstallationQualifier_ in self.deliveryInstallationQualifier:
            namespaceprefix_ = self.deliveryInstallationQualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryInstallationQualifier_nsprefix_) else ''
            deliveryInstallationQualifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryInstallationQualifier', pretty_print=pretty_print)
        for deliveryMode_ in self.deliveryMode:
            namespaceprefix_ = self.deliveryMode_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryMode_nsprefix_) else ''
            deliveryMode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryMode', pretty_print=pretty_print)
        for deliveryModeIdentifier_ in self.deliveryModeIdentifier:
            namespaceprefix_ = self.deliveryModeIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryModeIdentifier_nsprefix_) else ''
            deliveryModeIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryModeIdentifier', pretty_print=pretty_print)
        for buildingNumberSuffix_ in self.buildingNumberSuffix:
            namespaceprefix_ = self.buildingNumberSuffix_nsprefix_ + ':' if (UseCapturedNS_ and self.buildingNumberSuffix_nsprefix_) else ''
            buildingNumberSuffix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='buildingNumberSuffix', pretty_print=pretty_print)
        for postBox_ in self.postBox:
            namespaceprefix_ = self.postBox_nsprefix_ + ':' if (UseCapturedNS_ and self.postBox_nsprefix_) else ''
            postBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='postBox', pretty_print=pretty_print)
        for precinct_ in self.precinct:
            namespaceprefix_ = self.precinct_nsprefix_ + ':' if (UseCapturedNS_ and self.precinct_nsprefix_) else ''
            precinct_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='precinct', pretty_print=pretty_print)
        for useablePeriod_ in self.useablePeriod:
            namespaceprefix_ = self.useablePeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.useablePeriod_nsprefix_) else ''
            useablePeriod_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='useablePeriod', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.use = ' '.join(self.use.split())
            self.validate_set_PostalAddressUse(self.use)    # validate type set_PostalAddressUse
        value = find_attr_value_('isNotOrdered', node)
        if value is not None and 'isNotOrdered' not in already_processed:
            already_processed.add('isNotOrdered')
            if value in ('true', '1'):
                self.isNotOrdered = True
            elif value in ('false', '0'):
                self.isNotOrdered = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.isNotOrdered)    # validate type bl
        super(AD, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'delimiter':
            obj_ = adxp_delimiter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'delimiter', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_delimiter'):
              self.add_delimiter(obj_.value)
            elif hasattr(self, 'set_delimiter'):
              self.set_delimiter(obj_.value)
        elif nodeName_ == 'country':
            obj_ = adxp_country.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'country', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_country'):
              self.add_country(obj_.value)
            elif hasattr(self, 'set_country'):
              self.set_country(obj_.value)
        elif nodeName_ == 'state':
            obj_ = adxp_state.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'state', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_state'):
              self.add_state(obj_.value)
            elif hasattr(self, 'set_state'):
              self.set_state(obj_.value)
        elif nodeName_ == 'county':
            obj_ = adxp_county.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'county', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_county'):
              self.add_county(obj_.value)
            elif hasattr(self, 'set_county'):
              self.set_county(obj_.value)
        elif nodeName_ == 'city':
            obj_ = adxp_city.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'city', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_city'):
              self.add_city(obj_.value)
            elif hasattr(self, 'set_city'):
              self.set_city(obj_.value)
        elif nodeName_ == 'postalCode':
            obj_ = adxp_postalCode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'postalCode', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_postalCode'):
              self.add_postalCode(obj_.value)
            elif hasattr(self, 'set_postalCode'):
              self.set_postalCode(obj_.value)
        elif nodeName_ == 'streetAddressLine':
            obj_ = adxp_streetAddressLine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetAddressLine', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetAddressLine'):
              self.add_streetAddressLine(obj_.value)
            elif hasattr(self, 'set_streetAddressLine'):
              self.set_streetAddressLine(obj_.value)
        elif nodeName_ == 'houseNumber':
            obj_ = adxp_houseNumber.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'houseNumber', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_houseNumber'):
              self.add_houseNumber(obj_.value)
            elif hasattr(self, 'set_houseNumber'):
              self.set_houseNumber(obj_.value)
        elif nodeName_ == 'houseNumberNumeric':
            obj_ = adxp_houseNumberNumeric.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'houseNumberNumeric', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_houseNumberNumeric'):
              self.add_houseNumberNumeric(obj_.value)
            elif hasattr(self, 'set_houseNumberNumeric'):
              self.set_houseNumberNumeric(obj_.value)
        elif nodeName_ == 'direction':
            obj_ = adxp_direction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'direction', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_direction'):
              self.add_direction(obj_.value)
            elif hasattr(self, 'set_direction'):
              self.set_direction(obj_.value)
        elif nodeName_ == 'streetName':
            obj_ = adxp_streetName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetName', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetName'):
              self.add_streetName(obj_.value)
            elif hasattr(self, 'set_streetName'):
              self.set_streetName(obj_.value)
        elif nodeName_ == 'streetNameBase':
            obj_ = adxp_streetNameBase.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetNameBase', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetNameBase'):
              self.add_streetNameBase(obj_.value)
            elif hasattr(self, 'set_streetNameBase'):
              self.set_streetNameBase(obj_.value)
        elif nodeName_ == 'streetNameType':
            obj_ = adxp_streetNameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetNameType', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetNameType'):
              self.add_streetNameType(obj_.value)
            elif hasattr(self, 'set_streetNameType'):
              self.set_streetNameType(obj_.value)
        elif nodeName_ == 'additionalLocator':
            obj_ = adxp_additionalLocator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'additionalLocator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_additionalLocator'):
              self.add_additionalLocator(obj_.value)
            elif hasattr(self, 'set_additionalLocator'):
              self.set_additionalLocator(obj_.value)
        elif nodeName_ == 'unitID':
            obj_ = adxp_unitID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'unitID', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_unitID'):
              self.add_unitID(obj_.value)
            elif hasattr(self, 'set_unitID'):
              self.set_unitID(obj_.value)
        elif nodeName_ == 'unitType':
            obj_ = adxp_unitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'unitType', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_unitType'):
              self.add_unitType(obj_.value)
            elif hasattr(self, 'set_unitType'):
              self.set_unitType(obj_.value)
        elif nodeName_ == 'careOf':
            obj_ = adxp_careOf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'careOf', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_careOf'):
              self.add_careOf(obj_.value)
            elif hasattr(self, 'set_careOf'):
              self.set_careOf(obj_.value)
        elif nodeName_ == 'censusTract':
            obj_ = adxp_censusTract.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'censusTract', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_censusTract'):
              self.add_censusTract(obj_.value)
            elif hasattr(self, 'set_censusTract'):
              self.set_censusTract(obj_.value)
        elif nodeName_ == 'deliveryAddressLine':
            obj_ = adxp_deliveryAddressLine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryAddressLine', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryAddressLine'):
              self.add_deliveryAddressLine(obj_.value)
            elif hasattr(self, 'set_deliveryAddressLine'):
              self.set_deliveryAddressLine(obj_.value)
        elif nodeName_ == 'deliveryInstallationType':
            obj_ = adxp_deliveryInstallationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryInstallationType', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryInstallationType'):
              self.add_deliveryInstallationType(obj_.value)
            elif hasattr(self, 'set_deliveryInstallationType'):
              self.set_deliveryInstallationType(obj_.value)
        elif nodeName_ == 'deliveryInstallationArea':
            obj_ = adxp_deliveryInstallationArea.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryInstallationArea', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryInstallationArea'):
              self.add_deliveryInstallationArea(obj_.value)
            elif hasattr(self, 'set_deliveryInstallationArea'):
              self.set_deliveryInstallationArea(obj_.value)
        elif nodeName_ == 'deliveryInstallationQualifier':
            obj_ = adxp_deliveryInstallationQualifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryInstallationQualifier', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryInstallationQualifier'):
              self.add_deliveryInstallationQualifier(obj_.value)
            elif hasattr(self, 'set_deliveryInstallationQualifier'):
              self.set_deliveryInstallationQualifier(obj_.value)
        elif nodeName_ == 'deliveryMode':
            obj_ = adxp_deliveryMode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryMode', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryMode'):
              self.add_deliveryMode(obj_.value)
            elif hasattr(self, 'set_deliveryMode'):
              self.set_deliveryMode(obj_.value)
        elif nodeName_ == 'deliveryModeIdentifier':
            obj_ = adxp_deliveryModeIdentifier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'deliveryModeIdentifier', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_deliveryModeIdentifier'):
              self.add_deliveryModeIdentifier(obj_.value)
            elif hasattr(self, 'set_deliveryModeIdentifier'):
              self.set_deliveryModeIdentifier(obj_.value)
        elif nodeName_ == 'buildingNumberSuffix':
            obj_ = adxp_buildingNumberSuffix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'buildingNumberSuffix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_buildingNumberSuffix'):
              self.add_buildingNumberSuffix(obj_.value)
            elif hasattr(self, 'set_buildingNumberSuffix'):
              self.set_buildingNumberSuffix(obj_.value)
        elif nodeName_ == 'postBox':
            obj_ = adxp_postBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'postBox', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_postBox'):
              self.add_postBox(obj_.value)
            elif hasattr(self, 'set_postBox'):
              self.set_postBox(obj_.value)
        elif nodeName_ == 'precinct':
            obj_ = adxp_precinct.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'precinct', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_precinct'):
              self.add_precinct(obj_.value)
            elif hasattr(self, 'set_precinct'):
              self.set_precinct(obj_.value)
        elif nodeName_ == 'useablePeriod':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            class_obj_ = SXCM_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'useablePeriod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_useablePeriod'):
              self.add_useablePeriod(obj_.value)
            elif hasattr(self, 'set_useablePeriod'):
              self.set_useablePeriod(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AD, self).buildChildren(child_, node, nodeName_, True)
# end class AD


class ENXP(ST):
    """A character string token representing a part of a name.
    May have a type code signifying the role of the part in
    the whole entity name, and a qualifier code for more detail
    about the name part type. Typical name parts for person
    names are given names, and family names, titles, etc.
    Indicates whether the name part is a given name, family
    name, prefix, suffix, etc.
    The qualifier is a set of codes each of which specifies
    a certain subcategory of the name part in addition to
    the main name part type. For example, a given name may
    be flagged as a nickname, a family name may be a
    pseudonym or a name of public records."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ST
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, qualifier=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ENXP, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.qualifier = _cast(None, qualifier)
        self.qualifier_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENXP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENXP.subclass:
            return ENXP.subclass(*args_, **kwargs_)
        else:
            return ENXP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        pass
    def validate_set_EntityNamePartQualifier(self, value):
        # Validate type set_EntityNamePartQualifier, a restriction on EntityNamePartQualifier.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ENXP, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ENXP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ENXP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ENXP':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ENXP')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ENXP', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ENXP'):
        super(ENXP, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ENXP')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier=%s' % (quote_attrib(self.qualifier), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ENXP', fromsubclass_=False, pretty_print=True):
        super(ENXP, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            self.qualifier = value
            self.validate_set_EntityNamePartQualifier(self.qualifier)    # validate type set_EntityNamePartQualifier
        super(ENXP, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ENXP, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ENXP


class en_delimiter(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, qualifier=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(en_delimiter, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_delimiter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_delimiter.subclass:
            return en_delimiter.subclass(*args_, **kwargs_)
        else:
            return en_delimiter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_delimiter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.delimiter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.delimiter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.delimiter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.delimiter')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.delimiter'):
        super(en_delimiter, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.delimiter')
        if self.partType != "DEL" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.delimiter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_delimiter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_delimiter


class en_family(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, qualifier=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(en_family, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_family)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_family.subclass:
            return en_family.subclass(*args_, **kwargs_)
        else:
            return en_family(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_family, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.family', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.family')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.family':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.family')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.family'):
        super(en_family, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.family')
        if self.partType != "FAM" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.family', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_family, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_family


class en_given(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, qualifier=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(en_given, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_given)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_given.subclass:
            return en_given.subclass(*args_, **kwargs_)
        else:
            return en_given(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_given, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.given', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.given')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.given':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.given')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.given'):
        super(en_given, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.given')
        if self.partType != "GIV" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.given', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_given, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_given


class en_prefix(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, qualifier=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(en_prefix, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_prefix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_prefix.subclass:
            return en_prefix.subclass(*args_, **kwargs_)
        else:
            return en_prefix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_prefix, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.prefix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.prefix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.prefix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.prefix')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.prefix'):
        super(en_prefix, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.prefix')
        if self.partType != "PFX" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.prefix', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_prefix, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_prefix


class en_suffix(ENXP):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, partType=None, qualifier=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(en_suffix, self).__init__(nullFlavor, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, partType, qualifier, valueOf_, mixedclass_, content_,  **kwargs_)
        self.partType = _cast(None, partType)
        self.partType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_suffix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_suffix.subclass:
            return en_suffix.subclass(*args_, **kwargs_)
        else:
            return en_suffix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_partType(self):
        return self.partType
    def set_partType(self, partType):
        self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityNamePartType(self, value):
        # Validate type EntityNamePartType, a restriction on cs.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(en_suffix, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.suffix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.suffix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'en.suffix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.suffix')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='en.suffix'):
        super(en_suffix, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='en.suffix')
        if self.partType != "SFX" and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='en.suffix', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.partType = ' '.join(self.partType.split())
            self.validate_EntityNamePartType(self.partType)    # validate type EntityNamePartType
        super(en_suffix, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class en_suffix


class EN(ANY):
    """A name for a person, organization, place or thing. A
    sequence of name parts, such as given name or family
    name, prefix, suffix, etc. Examples for entity name
    values are "Jim Bob Walton, Jr.", "Health Level Seven,
    Inc.", "Lake Tahoe", etc. An entity name may be as simple
    as a character string or may consist of several entity name
    parts, such as, "Jim", "Bob", "Walton", and "Jr.", "Health
    Level Seven" and "Inc.", "Lake" and "Tahoe".
    A set of codes advising a system or user which name
    in a set of like names to select for a given purpose.
    A name without specific use code might be a default
    name useful for any purpose, but a name with a specific
    use code would be preferred for that respective purpose."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, use=None, delimiter=None, family=None, given=None, prefix=None, suffix=None, validTime=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EN, self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.use = _cast(None, use)
        self.use_nsprefix_ = None
        if delimiter is None:
            self.delimiter = []
        else:
            self.delimiter = delimiter
        self.delimiter_nsprefix_ = None
        if family is None:
            self.family = []
        else:
            self.family = family
        self.family_nsprefix_ = None
        if given is None:
            self.given = []
        else:
            self.given = given
        self.given_nsprefix_ = None
        if prefix is None:
            self.prefix = []
        else:
            self.prefix = prefix
        self.prefix_nsprefix_ = None
        if suffix is None:
            self.suffix = []
        else:
            self.suffix = suffix
        self.suffix_nsprefix_ = None
        self.validTime = validTime
        self.validTime_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EN.subclass:
            return EN.subclass(*args_, **kwargs_)
        else:
            return EN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_delimiter(self):
        return self.delimiter
    def set_delimiter(self, delimiter):
        self.delimiter = delimiter
    def add_delimiter(self, value):
        self.delimiter.append(value)
    def insert_delimiter_at(self, index, value):
        self.delimiter.insert(index, value)
    def replace_delimiter_at(self, index, value):
        self.delimiter[index] = value
    def get_family(self):
        return self.family
    def set_family(self, family):
        self.family = family
    def add_family(self, value):
        self.family.append(value)
    def insert_family_at(self, index, value):
        self.family.insert(index, value)
    def replace_family_at(self, index, value):
        self.family[index] = value
    def get_given(self):
        return self.given
    def set_given(self, given):
        self.given = given
    def add_given(self, value):
        self.given.append(value)
    def insert_given_at(self, index, value):
        self.given.insert(index, value)
    def replace_given_at(self, index, value):
        self.given[index] = value
    def get_prefix(self):
        return self.prefix
    def set_prefix(self, prefix):
        self.prefix = prefix
    def add_prefix(self, value):
        self.prefix.append(value)
    def insert_prefix_at(self, index, value):
        self.prefix.insert(index, value)
    def replace_prefix_at(self, index, value):
        self.prefix[index] = value
    def get_suffix(self):
        return self.suffix
    def set_suffix(self, suffix):
        self.suffix = suffix
    def add_suffix(self, value):
        self.suffix.append(value)
    def insert_suffix_at(self, index, value):
        self.suffix.insert(index, value)
    def replace_suffix_at(self, index, value):
        self.suffix[index] = value
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def get_use(self):
        return self.use
    def set_use(self, use):
        self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_set_EntityNameUse(self, value):
        # Validate type set_EntityNameUse, a restriction on EntityNameUse.
        pass
    def hasContent_(self):
        if (
            self.delimiter or
            self.family or
            self.given or
            self.prefix or
            self.suffix or
            self.validTime is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(EN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='EN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EN'):
        super(EN, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EN')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='EN', fromsubclass_=False, pretty_print=True):
        super(EN, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for delimiter_ in self.delimiter:
            namespaceprefix_ = self.delimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.delimiter_nsprefix_) else ''
            delimiter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='delimiter', pretty_print=pretty_print)
        for family_ in self.family:
            namespaceprefix_ = self.family_nsprefix_ + ':' if (UseCapturedNS_ and self.family_nsprefix_) else ''
            family_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='family', pretty_print=pretty_print)
        for given_ in self.given:
            namespaceprefix_ = self.given_nsprefix_ + ':' if (UseCapturedNS_ and self.given_nsprefix_) else ''
            given_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='given', pretty_print=pretty_print)
        for prefix_ in self.prefix:
            namespaceprefix_ = self.prefix_nsprefix_ + ':' if (UseCapturedNS_ and self.prefix_nsprefix_) else ''
            prefix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='prefix', pretty_print=pretty_print)
        for suffix_ in self.suffix:
            namespaceprefix_ = self.suffix_nsprefix_ + ':' if (UseCapturedNS_ and self.suffix_nsprefix_) else ''
            suffix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='suffix', pretty_print=pretty_print)
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.use = ' '.join(self.use.split())
            self.validate_set_EntityNameUse(self.use)    # validate type set_EntityNameUse
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'delimiter':
            obj_ = en_delimiter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'delimiter', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_delimiter'):
              self.add_delimiter(obj_.value)
            elif hasattr(self, 'set_delimiter'):
              self.set_delimiter(obj_.value)
        elif nodeName_ == 'family':
            obj_ = en_family.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'family', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_family'):
              self.add_family(obj_.value)
            elif hasattr(self, 'set_family'):
              self.set_family(obj_.value)
        elif nodeName_ == 'given':
            obj_ = en_given.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'given', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_given'):
              self.add_given(obj_.value)
            elif hasattr(self, 'set_given'):
              self.set_given(obj_.value)
        elif nodeName_ == 'prefix':
            obj_ = en_prefix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'prefix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_prefix'):
              self.add_prefix(obj_.value)
            elif hasattr(self, 'set_prefix'):
              self.set_prefix(obj_.value)
        elif nodeName_ == 'suffix':
            obj_ = en_suffix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'suffix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_suffix'):
              self.add_suffix(obj_.value)
            elif hasattr(self, 'set_suffix'):
              self.set_suffix(obj_.value)
        elif nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'validTime', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_validTime'):
              self.add_validTime(obj_.value)
            elif hasattr(self, 'set_validTime'):
              self.set_validTime(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EN, self).buildChildren(child_, node, nodeName_, True)
# end class EN


class PN(EN):
    """A name for a person. A sequence of name parts, such as
    given name or family name, prefix, suffix, etc. PN differs
    from EN because the qualifier type cannot include LS
    (Legal Status)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EN
    def __init__(self, nullFlavor=None, use=None, delimiter=None, family=None, given=None, prefix=None, suffix=None, validTime=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PN, self).__init__(nullFlavor, use, delimiter, family, given, prefix, suffix, validTime, valueOf_, mixedclass_, content_,  **kwargs_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PN.subclass:
            return PN.subclass(*args_, **kwargs_)
        else:
            return PN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(PN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PN'):
        super(PN, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PN')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PN', fromsubclass_=False, pretty_print=True):
        super(PN, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PN, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PN


class ON(EN):
    """A name for an organization. A sequence of name parts.
    A set of codes advising a system or user which name
    in a set of like names to select for a given purpose.
    A name without specific use code might be a default
    name useful for any purpose, but a name with a specific
    use code would be preferred for that respective purpose."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EN
    def __init__(self, nullFlavor=None, use=None, delimiter=None, family=None, given=None, prefix=None, suffix=None, validTime=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ON, self).__init__(nullFlavor, use, delimiter, family, given, prefix, suffix, validTime, valueOf_, mixedclass_, content_,  **kwargs_)
        self.use = _cast(None, use)
        self.use_nsprefix_ = None
        if delimiter is None:
            self.delimiter = []
        else:
            self.delimiter = delimiter
        self.delimiter_nsprefix_ = None
        if prefix is None:
            self.prefix = []
        else:
            self.prefix = prefix
        self.prefix_nsprefix_ = None
        if suffix is None:
            self.suffix = []
        else:
            self.suffix = suffix
        self.suffix_nsprefix_ = None
        self.validTime = validTime
        self.validTime_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ON)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ON.subclass:
            return ON.subclass(*args_, **kwargs_)
        else:
            return ON(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_delimiter(self):
        return self.delimiter
    def set_delimiter(self, delimiter):
        self.delimiter = delimiter
    def add_delimiter(self, value):
        self.delimiter.append(value)
    def insert_delimiter_at(self, index, value):
        self.delimiter.insert(index, value)
    def replace_delimiter_at(self, index, value):
        self.delimiter[index] = value
    def get_prefix(self):
        return self.prefix
    def set_prefix(self, prefix):
        self.prefix = prefix
    def add_prefix(self, value):
        self.prefix.append(value)
    def insert_prefix_at(self, index, value):
        self.prefix.insert(index, value)
    def replace_prefix_at(self, index, value):
        self.prefix[index] = value
    def get_suffix(self):
        return self.suffix
    def set_suffix(self, suffix):
        self.suffix = suffix
    def add_suffix(self, value):
        self.suffix.append(value)
    def insert_suffix_at(self, index, value):
        self.suffix.insert(index, value)
    def replace_suffix_at(self, index, value):
        self.suffix[index] = value
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def get_use(self):
        return self.use
    def set_use(self, use):
        self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_EntityNameUse(self, value):
        # Validate type set_EntityNameUse, a restriction on EntityNameUse.
        pass
    def hasContent_(self):
        if (
            self.delimiter or
            self.prefix or
            self.suffix or
            self.validTime is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ON, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='ON', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ON')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ON':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ON')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ON', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ON'):
        super(ON, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ON')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='ON', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for delimiter_ in self.delimiter:
            namespaceprefix_ = self.delimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.delimiter_nsprefix_) else ''
            delimiter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='delimiter', pretty_print=pretty_print)
        for prefix_ in self.prefix:
            namespaceprefix_ = self.prefix_nsprefix_ + ':' if (UseCapturedNS_ and self.prefix_nsprefix_) else ''
            prefix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='prefix', pretty_print=pretty_print)
        for suffix_ in self.suffix:
            namespaceprefix_ = self.suffix_nsprefix_ + ':' if (UseCapturedNS_ and self.suffix_nsprefix_) else ''
            suffix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='suffix', pretty_print=pretty_print)
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.use = ' '.join(self.use.split())
            self.validate_set_EntityNameUse(self.use)    # validate type set_EntityNameUse
        super(ON, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'delimiter':
            obj_ = en_delimiter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'delimiter', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_delimiter'):
              self.add_delimiter(obj_.value)
            elif hasattr(self, 'set_delimiter'):
              self.set_delimiter(obj_.value)
        elif nodeName_ == 'prefix':
            obj_ = en_prefix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'prefix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_prefix'):
              self.add_prefix(obj_.value)
            elif hasattr(self, 'set_prefix'):
              self.set_prefix(obj_.value)
        elif nodeName_ == 'suffix':
            obj_ = en_suffix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'suffix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_suffix'):
              self.add_suffix(obj_.value)
            elif hasattr(self, 'set_suffix'):
              self.set_suffix(obj_.value)
        elif nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'validTime', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_validTime'):
              self.add_validTime(obj_.value)
            elif hasattr(self, 'set_validTime'):
              self.set_validTime(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ON


class TN(EN):
    """A restriction of entity name that is effectively a simple string used
    for a simple name for things and places."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EN
    def __init__(self, nullFlavor=None, use=None, delimiter=None, family=None, given=None, prefix=None, suffix=None, validTime=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TN, self).__init__(nullFlavor, use, delimiter, family, given, prefix, suffix, validTime, valueOf_, mixedclass_, content_,  **kwargs_)
        self.validTime = validTime
        self.validTime_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TN.subclass:
            return TN.subclass(*args_, **kwargs_)
        else:
            return TN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.validTime is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(TN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='TN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TN'):
        super(TN, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TN')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='TN', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'validTime', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_validTime'):
              self.add_validTime(obj_.value)
            elif hasattr(self, 'set_validTime'):
              self.set_validTime(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class TN


class QTY(ANY):
    """The quantity data type is an abstract generalization
    for all data types (1) whose value set has an order
    relation (less-or-equal) and (2) where difference is
    defined in all of the data type's totally ordered value
    subsets. The quantity type abstraction is needed in
    defining certain other types, such as the interval and
    the probability distribution."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(QTY, self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QTY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QTY.subclass:
            return QTY.subclass(*args_, **kwargs_)
        else:
            return QTY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(QTY, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QTY', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QTY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QTY':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QTY')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QTY'):
        super(QTY, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QTY')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QTY', fromsubclass_=False, pretty_print=True):
        super(QTY, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QTY, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(QTY, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QTY


class INT(QTY):
    """Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise
    numbers that are results of counting and enumerating.
    Integer numbers are discrete, the set of integers is
    infinite but countable. No arbitrary limit is imposed on
    the range of integer numbers. Two NULL flavors are
    defined for the positive and negative infinity."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, value=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(INT, self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(int, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INT.subclass:
            return INT.subclass(*args_, **kwargs_)
        else:
            return INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(INT, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='INT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'INT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INT')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='INT'):
        super(INT, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INT')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='INT', fromsubclass_=False, pretty_print=True):
        super(INT, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = self.gds_parse_integer(value, node, 'value')
            self.validate_int(self.value)    # validate type int
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(INT, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(INT, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class INT


class REAL(QTY):
    """Fractional numbers. Typically used whenever quantities
    are measured, estimated, or computed from other real
    numbers. The typical representation is decimal, where
    the number of significant decimal digits is known as the
    precision. Real numbers are needed beyond integers
    whenever quantities of the real world are measured,
    estimated, or computed from other real numbers. The term
    "Real number" in this specification is used to mean
    that fractional values are covered without necessarily
    implying the full set of the mathematical real numbers."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, value=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(REAL, self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REAL.subclass:
            return REAL.subclass(*args_, **kwargs_)
        else:
            return REAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(REAL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='REAL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('REAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'REAL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='REAL')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='REAL'):
        super(REAL, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='REAL')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='REAL', fromsubclass_=False, pretty_print=True):
        super(REAL, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(REAL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(REAL, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class REAL


class PQR(CV):
    """A representation of a physical quantity in a unit from
    any code system. Used to show alternative representation
    for a physical quantity.
    The magnitude of the measurement value in terms of
    the unit specified in the code."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CV
    def __init__(self, nullFlavor=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, translation=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PQR, self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PQR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PQR.subclass:
            return PQR.subclass(*args_, **kwargs_)
        else:
            return PQR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(PQR, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PQR', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PQR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PQR':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PQR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PQR', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PQR'):
        super(PQR, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PQR')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PQR', fromsubclass_=False, pretty_print=True):
        super(PQR, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        super(PQR, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PQR, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PQR


class PQ(QTY):
    """A dimensioned quantity expressing the result of a
    measurement act.
    The magnitude of the quantity measured in terms of
    the unit.
    The unit of measure specified in the Unified Code for
    Units of Measure (UCUM)
    [http://aurora.rg.iupui.edu/UCUM]."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, value=None, unit='1', translation=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PQ, self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.translation_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PQ.subclass:
            return PQ.subclass(*args_, **kwargs_)
        else:
            return PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_translation(self):
        return self.translation
    def set_translation(self, translation):
        self.translation = translation
    def add_translation(self, value):
        self.translation.append(value)
    def insert_translation_at(self, index, value):
        self.translation.insert(index, value)
    def replace_translation_at(self, index, value):
        self.translation[index] = value
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.translation or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PQ'):
        super(PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PQ')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.unit != "1" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='PQ', fromsubclass_=False, pretty_print=True):
        super(PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for translation_ in self.translation:
            namespaceprefix_ = self.translation_nsprefix_ + ':' if (UseCapturedNS_ and self.translation_nsprefix_) else ''
            translation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='translation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.unit = ' '.join(self.unit.split())
            self.validate_cs(self.unit)    # validate type cs
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'translation':
            obj_ = PQR.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'translation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_translation'):
              self.add_translation(obj_.value)
            elif hasattr(self, 'set_translation'):
              self.set_translation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PQ, self).buildChildren(child_, node, nodeName_, True)
# end class PQ


class MO(QTY):
    """A monetary amount is a quantity expressing the amount of
    money in some currency. Currencies are the units in which
    monetary amounts are denominated in different economic
    regions. While the monetary amount is a single kind of
    quantity (money) the exchange rates between the different
    units are variable. This is the principle difference
    between physical quantity and monetary amounts, and the
    reason why currency units are not physical units.
    The magnitude of the monetary amount in terms of the
    currency unit.
    The currency unit as defined in ISO 4217."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, value=None, currency=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MO, self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.currency = _cast(None, currency)
        self.currency_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MO.subclass:
            return MO.subclass(*args_, **kwargs_)
        else:
            return MO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_currency(self):
        return self.currency
    def set_currency(self, currency):
        self.currency = currency
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def validate_cs(self, value):
        # Validate type cs, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(MO, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MO')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MO'):
        super(MO, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MO')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.currency), input_name='currency')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MO', fromsubclass_=False, pretty_print=True):
        super(MO, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
            self.currency = ' '.join(self.currency.split())
            self.validate_cs(self.currency)    # validate type cs
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(MO, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(MO, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MO


class EIVL_event(CE):
    """A code for a common (periodical) activity of daily
    living based on which the event related periodic
    interval is specified."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CE
    def __init__(self, nullFlavor=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, translation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EIVL_event, self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation,  **kwargs_)
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystem_nsprefix_ = None
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EIVL_event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EIVL_event.subclass:
            return EIVL_event.subclass(*args_, **kwargs_)
        else:
            return EIVL_event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_codeSystem(self):
        return self.codeSystem
    def set_codeSystem(self, codeSystem):
        self.codeSystem = codeSystem
    def get_codeSystemName(self):
        return self.codeSystemName
    def set_codeSystemName(self, codeSystemName):
        self.codeSystemName = codeSystemName
    def validate_TimingEvent(self, value):
        # Validate type TimingEvent, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'ACD', 'ACM', 'ACV', 'HS', 'IC', 'ICD', 'ICM', 'ICV', 'PC', 'PCD', 'PCM', 'PCV']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TimingEvent' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TimingEvent_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TimingEvent_patterns_, ))
    validate_TimingEvent_patterns_ = [['^([^\\s]+)$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(EIVL_event, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIVL.event', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EIVL.event')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EIVL.event':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL.event')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EIVL.event', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EIVL.event'):
        super(EIVL_event, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL.event')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem != "2.16.840.1.113883.5.139" and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName != "TimingEvent" and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codeSystemName), input_name='codeSystemName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIVL.event', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.code = ' '.join(self.code.split())
            self.validate_TimingEvent(self.code)    # validate type TimingEvent
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        super(EIVL_event, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EIVL_event


class RTO_QTY_QTY(QTY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, numerator=None, denominator=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RTO_QTY_QTY, self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.numerator = numerator
        self.numerator_nsprefix_ = None
        self.denominator = denominator
        self.denominator_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO_QTY_QTY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO_QTY_QTY.subclass:
            return RTO_QTY_QTY.subclass(*args_, **kwargs_)
        else:
            return RTO_QTY_QTY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numerator(self):
        return self.numerator
    def set_numerator(self, numerator):
        self.numerator = numerator
    def set_numerator_with_type(self, value):
        self.numerator = value
        value.original_tagname_ = 'numerator'
        value.extensiontype_ = value.__class__.__name__
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def set_denominator_with_type(self, value):
        self.denominator = value
        value.original_tagname_ = 'denominator'
        value.extensiontype_ = value.__class__.__name__
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.numerator is not None or
            self.denominator is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(RTO_QTY_QTY, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='RTO_QTY_QTY', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO_QTY_QTY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RTO_QTY_QTY':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_QTY_QTY')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RTO_QTY_QTY', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RTO_QTY_QTY'):
        super(RTO_QTY_QTY, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_QTY_QTY')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='RTO_QTY_QTY', fromsubclass_=False, pretty_print=True):
        super(RTO_QTY_QTY, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numerator is not None:
            self.numerator.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.denominator is not None:
            self.denominator.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(RTO_QTY_QTY, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'numerator':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <numerator> element')
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'numerator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_numerator'):
              self.add_numerator(obj_.value)
            elif hasattr(self, 'set_numerator'):
              self.set_numerator(obj_.value)
        elif nodeName_ == 'denominator':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <denominator> element')
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'denominator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_denominator'):
              self.add_denominator(obj_.value)
            elif hasattr(self, 'set_denominator'):
              self.set_denominator(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(RTO_QTY_QTY, self).buildChildren(child_, node, nodeName_, True)
# end class RTO_QTY_QTY


class StrucDoc_Text(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, mediaType='text/x-hl7-text+xml', content=None, linkHtml=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, renderMultiMedia=None, paragraph=None, list=None, table=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        self.paragraph_nsprefix_ = None
        if list is None:
            self.list = []
        else:
            self.list = list
        self.list_nsprefix_ = None
        if table is None:
            self.table = []
        else:
            self.table = table
        self.table_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Text)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Text.subclass:
            return StrucDoc_Text.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_paragraph(self):
        return self.paragraph
    def set_paragraph(self, paragraph):
        self.paragraph = paragraph
    def add_paragraph(self, value):
        self.paragraph.append(value)
    def insert_paragraph_at(self, index, value):
        self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value):
        self.paragraph[index] = value
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def add_list(self, value):
        self.list.append(value)
    def insert_list_at(self, index, value):
        self.list.insert(index, value)
    def replace_list_at(self, index, value):
        self.list[index] = value
    def get_table(self):
        return self.table
    def set_table(self, table):
        self.table = table
    def add_table(self, value):
        self.table.append(value)
    def insert_table_at(self, index, value):
        self.table.insert(index, value)
    def replace_table_at(self, index, value):
        self.table[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_mediaType(self):
        return self.mediaType
    def set_mediaType(self, mediaType):
        self.mediaType = mediaType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            self.table or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Text', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Text')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Text':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Text')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Text', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Text'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.mediaType != "text/x-hl7-text+xml" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Text', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            namespaceprefix_ = self.paragraph_nsprefix_ + ':' if (UseCapturedNS_ and self.paragraph_nsprefix_) else ''
            paragraph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            namespaceprefix_ = self.list_nsprefix_ + ':' if (UseCapturedNS_ and self.list_nsprefix_) else ''
            list_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='list', pretty_print=pretty_print)
        for table_ in self.table:
            namespaceprefix_ = self.table_nsprefix_ + ':' if (UseCapturedNS_ and self.table_nsprefix_) else ''
            table_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='table', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        elif nodeName_ == 'table':
            obj_ = StrucDoc_Table.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Text


class StrucDoc_Title(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, mediaType='text/x-hl7-title+xml', content=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Title)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Title.subclass:
            return StrucDoc_Title.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Title(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_mediaType(self):
        return self.mediaType
    def set_mediaType(self, mediaType):
        self.mediaType = mediaType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.content or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Title', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Title')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Title':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Title')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Title', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Title'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.mediaType != "text/x-hl7-title+xml" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Title', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_TitleContent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_TitleFootnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Title


class StrucDoc_Br(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Br)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Br.subclass:
            return StrucDoc_Br.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Br(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Br', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Br')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Br':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Br')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Br', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Br'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Br', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StrucDoc_Br


class StrucDoc_Caption(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, linkHtml=None, sub=None, sup=None, footnote=None, footnoteRef=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Caption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Caption.subclass:
            return StrucDoc_Caption.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Caption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.linkHtml or
            self.sub or
            self.sup or
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Caption', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Caption')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Caption':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Caption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Caption', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Caption'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Caption', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Caption


class StrucDoc_Col(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, span='1', width=None, align=None, char=None, charoff=None, valign=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.span = _cast(None, span)
        self.span_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Col)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Col.subclass:
            return StrucDoc_Col.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Col(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_span(self):
        return self.span
    def set_span(self, span):
        self.span = span
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType(self, value):
        # Validate type alignType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType(self, value):
        # Validate type valignType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Col', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Col')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Col':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Col')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Col', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Col'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.span != "1" and 'span' not in already_processed:
            already_processed.add('span')
            outfile.write(' span=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.span), input_name='span')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Col', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('span', node)
        if value is not None and 'span' not in already_processed:
            already_processed.add('span')
            self.span = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType(self.align)    # validate type alignType
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType(self.valign)    # validate type valignType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StrucDoc_Col


class StrucDoc_Colgroup(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, span='1', width=None, align=None, char=None, charoff=None, valign=None, col=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.span = _cast(None, span)
        self.span_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if col is None:
            self.col = []
        else:
            self.col = col
        self.col_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Colgroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Colgroup.subclass:
            return StrucDoc_Colgroup.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Colgroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_col(self):
        return self.col
    def set_col(self, col):
        self.col = col
    def add_col(self, value):
        self.col.append(value)
    def insert_col_at(self, index, value):
        self.col.insert(index, value)
    def replace_col_at(self, index, value):
        self.col[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_span(self):
        return self.span
    def set_span(self, span):
        self.span = span
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType1(self, value):
        # Validate type alignType1, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType1' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType2(self, value):
        # Validate type valignType2, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType2' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.col
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Colgroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Colgroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Colgroup':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Colgroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Colgroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Colgroup'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.span != "1" and 'span' not in already_processed:
            already_processed.add('span')
            outfile.write(' span=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.span), input_name='span')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Colgroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for col_ in self.col:
            namespaceprefix_ = self.col_nsprefix_ + ':' if (UseCapturedNS_ and self.col_nsprefix_) else ''
            col_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='col', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('span', node)
        if value is not None and 'span' not in already_processed:
            already_processed.add('span')
            self.span = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType1(self.align)    # validate type alignType1
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType2(self.valign)    # validate type valignType2
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'col':
            obj_ = StrucDoc_Col.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.col.append(obj_)
            obj_.original_tagname_ = 'col'
# end class StrucDoc_Colgroup


class StrucDoc_Content(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, revised=None, content=None, linkHtml=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, renderMultiMedia=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.revised = _cast(None, revised)
        self.revised_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Content)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Content.subclass:
            return StrucDoc_Content.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Content(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_revised(self):
        return self.revised
    def set_revised(self, revised):
        self.revised = revised
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_revisedType(self, value):
        # Validate type revisedType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['insert', 'delete']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on revisedType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Content', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Content')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Content':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Content')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Content', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Content'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.revised is not None and 'revised' not in already_processed:
            already_processed.add('revised')
            outfile.write(' revised=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.revised), input_name='revised')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Content', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('revised', node)
        if value is not None and 'revised' not in already_processed:
            already_processed.add('revised')
            self.revised = value
            self.validate_revisedType(self.revised)    # validate type revisedType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Content


class StrucDoc_TitleContent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, content=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_TitleContent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_TitleContent.subclass:
            return StrucDoc_TitleContent.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_TitleContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.content or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.TitleContent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.TitleContent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.TitleContent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.TitleContent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.TitleContent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.TitleContent'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.TitleContent', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_TitleContent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_TitleFootnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_TitleContent


class StrucDoc_Footnote(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, content=None, linkHtml=None, sub=None, sup=None, br=None, renderMultiMedia=None, paragraph=None, list=None, table=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        self.paragraph_nsprefix_ = None
        if list is None:
            self.list = []
        else:
            self.list = list
        self.list_nsprefix_ = None
        if table is None:
            self.table = []
        else:
            self.table = table
        self.table_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Footnote)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Footnote.subclass:
            return StrucDoc_Footnote.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Footnote(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_paragraph(self):
        return self.paragraph
    def set_paragraph(self, paragraph):
        self.paragraph = paragraph
    def add_paragraph(self, value):
        self.paragraph.append(value)
    def insert_paragraph_at(self, index, value):
        self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value):
        self.paragraph[index] = value
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def add_list(self, value):
        self.list.append(value)
    def insert_list_at(self, index, value):
        self.list.insert(index, value)
    def replace_list_at(self, index, value):
        self.list[index] = value
    def get_table(self):
        return self.table
    def set_table(self, table):
        self.table = table
    def add_table(self, value):
        self.table.append(value)
    def insert_table_at(self, index, value):
        self.table.insert(index, value)
    def replace_table_at(self, index, value):
        self.table[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            self.table or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Footnote', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Footnote')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Footnote':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Footnote')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Footnote', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Footnote'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Footnote', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            namespaceprefix_ = self.paragraph_nsprefix_ + ':' if (UseCapturedNS_ and self.paragraph_nsprefix_) else ''
            paragraph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            namespaceprefix_ = self.list_nsprefix_ + ':' if (UseCapturedNS_ and self.list_nsprefix_) else ''
            list_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='list', pretty_print=pretty_print)
        for table_ in self.table:
            namespaceprefix_ = self.table_nsprefix_ + ':' if (UseCapturedNS_ and self.table_nsprefix_) else ''
            table_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='table', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        elif nodeName_ == 'table':
            obj_ = StrucDoc_Table.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Footnote


class StrucDoc_TitleFootnote(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, content=None, sub=None, sup=None, br=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_TitleFootnote)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_TitleFootnote.subclass:
            return StrucDoc_TitleFootnote.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_TitleFootnote(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.content or
            self.sub or
            self.sup or
            self.br or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.TitleFootnote', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.TitleFootnote')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.TitleFootnote':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.TitleFootnote')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.TitleFootnote', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.TitleFootnote'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.TitleFootnote', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_TitleContent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_TitleFootnote


class StrucDoc_FootnoteRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, IDREF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.IDREF = _cast(None, IDREF)
        self.IDREF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_FootnoteRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_FootnoteRef.subclass:
            return StrucDoc_FootnoteRef.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_FootnoteRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_IDREF(self):
        return self.IDREF
    def set_IDREF(self, IDREF):
        self.IDREF = IDREF
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.FootnoteRef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.FootnoteRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.FootnoteRef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.FootnoteRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.FootnoteRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.FootnoteRef'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.IDREF is not None and 'IDREF' not in already_processed:
            already_processed.add('IDREF')
            outfile.write(' IDREF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDREF), input_name='IDREF')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.FootnoteRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('IDREF', node)
        if value is not None and 'IDREF' not in already_processed:
            already_processed.add('IDREF')
            self.IDREF = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StrucDoc_FootnoteRef


class StrucDoc_Item(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, caption=None, content=None, linkHtml=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, renderMultiMedia=None, paragraph=None, list=None, table=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        self.paragraph_nsprefix_ = None
        if list is None:
            self.list = []
        else:
            self.list = list
        self.list_nsprefix_ = None
        if table is None:
            self.table = []
        else:
            self.table = table
        self.table_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Item)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Item.subclass:
            return StrucDoc_Item.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Item(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_paragraph(self):
        return self.paragraph
    def set_paragraph(self, paragraph):
        self.paragraph = paragraph
    def add_paragraph(self, value):
        self.paragraph.append(value)
    def insert_paragraph_at(self, index, value):
        self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value):
        self.paragraph[index] = value
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def add_list(self, value):
        self.list.append(value)
    def insert_list_at(self, index, value):
        self.list.insert(index, value)
    def replace_list_at(self, index, value):
        self.list[index] = value
    def get_table(self):
        return self.table
    def set_table(self, table):
        self.table = table
    def add_table(self, value):
        self.table.append(value)
    def insert_table_at(self, index, value):
        self.table.insert(index, value)
    def replace_table_at(self, index, value):
        self.table[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.caption is not None or
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            self.table or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Item', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Item')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Item':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Item')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Item', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Item'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Item', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            namespaceprefix_ = self.paragraph_nsprefix_ + ':' if (UseCapturedNS_ and self.paragraph_nsprefix_) else ''
            paragraph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            namespaceprefix_ = self.list_nsprefix_ + ':' if (UseCapturedNS_ and self.list_nsprefix_) else ''
            list_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='list', pretty_print=pretty_print)
        for table_ in self.table:
            namespaceprefix_ = self.table_nsprefix_ + ':' if (UseCapturedNS_ and self.table_nsprefix_) else ''
            table_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='table', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'caption', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_caption'):
              self.add_caption(obj_.value)
            elif hasattr(self, 'set_caption'):
              self.set_caption(obj_.value)
        elif nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        elif nodeName_ == 'table':
            obj_ = StrucDoc_Table.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Item


class StrucDoc_LinkHtml(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, href=None, rel=None, rev=None, title=None, ID=None, language=None, styleCode=None, footnote=None, footnoteRef=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.rel = _cast(None, rel)
        self.rel_nsprefix_ = None
        self.rev = _cast(None, rev)
        self.rev_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_LinkHtml)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_LinkHtml.subclass:
            return StrucDoc_LinkHtml.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_LinkHtml(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_rel(self):
        return self.rel
    def set_rel(self, rel):
        self.rel = rel
    def get_rev(self):
        return self.rev
    def set_rev(self, rev):
        self.rev = rev
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.LinkHtml', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.LinkHtml')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.LinkHtml':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.LinkHtml')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.LinkHtml', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.LinkHtml'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            outfile.write(' rel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rel), input_name='rel')), ))
        if self.rev is not None and 'rev' not in already_processed:
            already_processed.add('rev')
            outfile.write(' rev=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rev), input_name='rev')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.LinkHtml', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('rel', node)
        if value is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            self.rel = value
        value = find_attr_value_('rev', node)
        if value is not None and 'rev' not in already_processed:
            already_processed.add('rev')
            self.rev = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_LinkHtml


class StrucDoc_List(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, listType='unordered', caption=None, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.listType = _cast(None, listType)
        self.listType_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_List)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_List.subclass:
            return StrucDoc_List.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_List(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_item(self):
        return self.item
    def set_item(self, item):
        self.item = item
    def add_item(self, value):
        self.item.append(value)
    def insert_item_at(self, index, value):
        self.item.insert(index, value)
    def replace_item_at(self, index, value):
        self.item[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_listType(self):
        return self.listType
    def set_listType(self, listType):
        self.listType = listType
    def validate_listTypeType(self, value):
        # Validate type listTypeType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ordered', 'unordered']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on listTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.caption is not None or
            self.item
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.List', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.List')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.List':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.List')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.List', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.List'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.listType != "unordered" and 'listType' not in already_processed:
            already_processed.add('listType')
            outfile.write(' listType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.listType), input_name='listType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.List', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for item_ in self.item:
            namespaceprefix_ = self.item_nsprefix_ + ':' if (UseCapturedNS_ and self.item_nsprefix_) else ''
            item_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='item', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('listType', node)
        if value is not None and 'listType' not in already_processed:
            already_processed.add('listType')
            self.listType = value
            self.validate_listTypeType(self.listType)    # validate type listTypeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'
        elif nodeName_ == 'item':
            obj_ = StrucDoc_Item.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class StrucDoc_List


class StrucDoc_Paragraph(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, caption=None, content=None, linkHtml=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, renderMultiMedia=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Paragraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Paragraph.subclass:
            return StrucDoc_Paragraph.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Paragraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.caption is not None or
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Paragraph', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Paragraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Paragraph':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Paragraph')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Paragraph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Paragraph'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Paragraph', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'caption', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_caption'):
              self.add_caption(obj_.value)
            elif hasattr(self, 'set_caption'):
              self.set_caption(obj_.value)
        elif nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Paragraph


class StrucDoc_RenderMultiMedia(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, referencedObject=None, ID=None, language=None, styleCode=None, caption=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.referencedObject = _cast(None, referencedObject)
        self.referencedObject_nsprefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_RenderMultiMedia)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_RenderMultiMedia.subclass:
            return StrucDoc_RenderMultiMedia.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_RenderMultiMedia(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_referencedObject(self):
        return self.referencedObject
    def set_referencedObject(self, referencedObject):
        self.referencedObject = referencedObject
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def hasContent_(self):
        if (
            self.caption is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.RenderMultiMedia', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.RenderMultiMedia')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.RenderMultiMedia':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.RenderMultiMedia')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.RenderMultiMedia', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.RenderMultiMedia'):
        if self.referencedObject is not None and 'referencedObject' not in already_processed:
            already_processed.add('referencedObject')
            outfile.write(' referencedObject=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.referencedObject), input_name='referencedObject')), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.RenderMultiMedia', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referencedObject', node)
        if value is not None and 'referencedObject' not in already_processed:
            already_processed.add('referencedObject')
            self.referencedObject = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'
# end class StrucDoc_RenderMultiMedia


class StrucDoc_Sub(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Sub)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Sub.subclass:
            return StrucDoc_Sub.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Sub(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Sub', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Sub')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Sub':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Sub')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Sub'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Sub', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class StrucDoc_Sub


class StrucDoc_Sup(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Sup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Sup.subclass:
            return StrucDoc_Sup.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Sup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Sup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Sup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Sup':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Sup')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Sup'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StrucDoc.Sup', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class StrucDoc_Sup


class StrucDoc_Table(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, summary=None, width=None, border=None, frame=None, rules=None, cellspacing=None, cellpadding=None, caption=None, col=None, colgroup=None, thead=None, tfoot=None, tbody=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.summary = _cast(None, summary)
        self.summary_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.border = _cast(None, border)
        self.border_nsprefix_ = None
        self.frame = _cast(None, frame)
        self.frame_nsprefix_ = None
        self.rules = _cast(None, rules)
        self.rules_nsprefix_ = None
        self.cellspacing = _cast(None, cellspacing)
        self.cellspacing_nsprefix_ = None
        self.cellpadding = _cast(None, cellpadding)
        self.cellpadding_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
        if col is None:
            self.col = []
        else:
            self.col = col
        self.col_nsprefix_ = None
        if colgroup is None:
            self.colgroup = []
        else:
            self.colgroup = colgroup
        self.colgroup_nsprefix_ = None
        self.thead = thead
        self.thead_nsprefix_ = None
        self.tfoot = tfoot
        self.tfoot_nsprefix_ = None
        if tbody is None:
            self.tbody = []
        else:
            self.tbody = tbody
        self.tbody_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Table)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Table.subclass:
            return StrucDoc_Table.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Table(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_col(self):
        return self.col
    def set_col(self, col):
        self.col = col
    def add_col(self, value):
        self.col.append(value)
    def insert_col_at(self, index, value):
        self.col.insert(index, value)
    def replace_col_at(self, index, value):
        self.col[index] = value
    def get_colgroup(self):
        return self.colgroup
    def set_colgroup(self, colgroup):
        self.colgroup = colgroup
    def add_colgroup(self, value):
        self.colgroup.append(value)
    def insert_colgroup_at(self, index, value):
        self.colgroup.insert(index, value)
    def replace_colgroup_at(self, index, value):
        self.colgroup[index] = value
    def get_thead(self):
        return self.thead
    def set_thead(self, thead):
        self.thead = thead
    def get_tfoot(self):
        return self.tfoot
    def set_tfoot(self, tfoot):
        self.tfoot = tfoot
    def get_tbody(self):
        return self.tbody
    def set_tbody(self, tbody):
        self.tbody = tbody
    def add_tbody(self, value):
        self.tbody.append(value)
    def insert_tbody_at(self, index, value):
        self.tbody.insert(index, value)
    def replace_tbody_at(self, index, value):
        self.tbody[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_summary(self):
        return self.summary
    def set_summary(self, summary):
        self.summary = summary
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_border(self):
        return self.border
    def set_border(self, border):
        self.border = border
    def get_frame(self):
        return self.frame
    def set_frame(self, frame):
        self.frame = frame
    def get_rules(self):
        return self.rules
    def set_rules(self, rules):
        self.rules = rules
    def get_cellspacing(self):
        return self.cellspacing
    def set_cellspacing(self, cellspacing):
        self.cellspacing = cellspacing
    def get_cellpadding(self):
        return self.cellpadding
    def set_cellpadding(self, cellpadding):
        self.cellpadding = cellpadding
    def validate_frameType(self, value):
        # Validate type frameType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['void', 'above', 'below', 'hsides', 'lhs', 'rhs', 'vsides', 'box', 'border']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on frameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_rulesType(self, value):
        # Validate type rulesType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'groups', 'rows', 'cols', 'all']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on rulesType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.caption is not None or
            self.col or
            self.colgroup or
            self.thead is not None or
            self.tfoot is not None or
            self.tbody
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Table', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Table')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Table':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Table')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Table', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Table'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.summary is not None and 'summary' not in already_processed:
            already_processed.add('summary')
            outfile.write(' summary=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.summary), input_name='summary')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.border is not None and 'border' not in already_processed:
            already_processed.add('border')
            outfile.write(' border=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.border), input_name='border')), ))
        if self.frame is not None and 'frame' not in already_processed:
            already_processed.add('frame')
            outfile.write(' frame=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.frame), input_name='frame')), ))
        if self.rules is not None and 'rules' not in already_processed:
            already_processed.add('rules')
            outfile.write(' rules=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rules), input_name='rules')), ))
        if self.cellspacing is not None and 'cellspacing' not in already_processed:
            already_processed.add('cellspacing')
            outfile.write(' cellspacing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cellspacing), input_name='cellspacing')), ))
        if self.cellpadding is not None and 'cellpadding' not in already_processed:
            already_processed.add('cellpadding')
            outfile.write(' cellpadding=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cellpadding), input_name='cellpadding')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Table', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for col_ in self.col:
            namespaceprefix_ = self.col_nsprefix_ + ':' if (UseCapturedNS_ and self.col_nsprefix_) else ''
            col_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='col', pretty_print=pretty_print)
        for colgroup_ in self.colgroup:
            namespaceprefix_ = self.colgroup_nsprefix_ + ':' if (UseCapturedNS_ and self.colgroup_nsprefix_) else ''
            colgroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='colgroup', pretty_print=pretty_print)
        if self.thead is not None:
            namespaceprefix_ = self.thead_nsprefix_ + ':' if (UseCapturedNS_ and self.thead_nsprefix_) else ''
            self.thead.export(outfile, level, namespaceprefix_, namespacedef_='', name_='thead', pretty_print=pretty_print)
        if self.tfoot is not None:
            namespaceprefix_ = self.tfoot_nsprefix_ + ':' if (UseCapturedNS_ and self.tfoot_nsprefix_) else ''
            self.tfoot.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tfoot', pretty_print=pretty_print)
        for tbody_ in self.tbody:
            namespaceprefix_ = self.tbody_nsprefix_ + ':' if (UseCapturedNS_ and self.tbody_nsprefix_) else ''
            tbody_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tbody', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('summary', node)
        if value is not None and 'summary' not in already_processed:
            already_processed.add('summary')
            self.summary = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('border', node)
        if value is not None and 'border' not in already_processed:
            already_processed.add('border')
            self.border = value
        value = find_attr_value_('frame', node)
        if value is not None and 'frame' not in already_processed:
            already_processed.add('frame')
            self.frame = value
            self.validate_frameType(self.frame)    # validate type frameType
        value = find_attr_value_('rules', node)
        if value is not None and 'rules' not in already_processed:
            already_processed.add('rules')
            self.rules = value
            self.validate_rulesType(self.rules)    # validate type rulesType
        value = find_attr_value_('cellspacing', node)
        if value is not None and 'cellspacing' not in already_processed:
            already_processed.add('cellspacing')
            self.cellspacing = value
        value = find_attr_value_('cellpadding', node)
        if value is not None and 'cellpadding' not in already_processed:
            already_processed.add('cellpadding')
            self.cellpadding = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'
        elif nodeName_ == 'col':
            obj_ = StrucDoc_Col.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.col.append(obj_)
            obj_.original_tagname_ = 'col'
        elif nodeName_ == 'colgroup':
            obj_ = StrucDoc_Colgroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.colgroup.append(obj_)
            obj_.original_tagname_ = 'colgroup'
        elif nodeName_ == 'thead':
            obj_ = StrucDoc_Thead.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.thead = obj_
            obj_.original_tagname_ = 'thead'
        elif nodeName_ == 'tfoot':
            obj_ = StrucDoc_Tfoot.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tfoot = obj_
            obj_.original_tagname_ = 'tfoot'
        elif nodeName_ == 'tbody':
            obj_ = StrucDoc_Tbody.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tbody.append(obj_)
            obj_.original_tagname_ = 'tbody'
# end class StrucDoc_Table


class StrucDoc_Tbody(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, align=None, char=None, charoff=None, valign=None, tr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
        self.tr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Tbody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Tbody.subclass:
            return StrucDoc_Tbody.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Tbody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tr(self):
        return self.tr
    def set_tr(self, tr):
        self.tr = tr
    def add_tr(self, value):
        self.tr.append(value)
    def insert_tr_at(self, index, value):
        self.tr.insert(index, value)
    def replace_tr_at(self, index, value):
        self.tr[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType3(self, value):
        # Validate type alignType3, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType3' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType4(self, value):
        # Validate type valignType4, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType4' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Tbody', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Tbody')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Tbody':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Tbody')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Tbody', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Tbody'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Tbody', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            namespaceprefix_ = self.tr_nsprefix_ + ':' if (UseCapturedNS_ and self.tr_nsprefix_) else ''
            tr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType3(self.align)    # validate type alignType3
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType4(self.valign)    # validate type valignType4
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tr':
            obj_ = StrucDoc_Tr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'
# end class StrucDoc_Tbody


class StrucDoc_Td(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, abbr=None, axis=None, headers=None, scope=None, rowspan='1', colspan='1', align=None, char=None, charoff=None, valign=None, content=None, linkHtml=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, renderMultiMedia=None, paragraph=None, list=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.abbr = _cast(None, abbr)
        self.abbr_nsprefix_ = None
        self.axis = _cast(None, axis)
        self.axis_nsprefix_ = None
        self.headers = _cast(None, headers)
        self.headers_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.rowspan = _cast(None, rowspan)
        self.rowspan_nsprefix_ = None
        self.colspan = _cast(None, colspan)
        self.colspan_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        self.paragraph_nsprefix_ = None
        if list is None:
            self.list = []
        else:
            self.list = list
        self.list_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Td)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Td.subclass:
            return StrucDoc_Td.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Td(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_paragraph(self):
        return self.paragraph
    def set_paragraph(self, paragraph):
        self.paragraph = paragraph
    def add_paragraph(self, value):
        self.paragraph.append(value)
    def insert_paragraph_at(self, index, value):
        self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value):
        self.paragraph[index] = value
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def add_list(self, value):
        self.list.append(value)
    def insert_list_at(self, index, value):
        self.list.insert(index, value)
    def replace_list_at(self, index, value):
        self.list[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_abbr(self):
        return self.abbr
    def set_abbr(self, abbr):
        self.abbr = abbr
    def get_axis(self):
        return self.axis
    def set_axis(self, axis):
        self.axis = axis
    def get_headers(self):
        return self.headers
    def set_headers(self, headers):
        self.headers = headers
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_rowspan(self):
        return self.rowspan
    def set_rowspan(self, rowspan):
        self.rowspan = rowspan
    def get_colspan(self):
        return self.colspan
    def set_colspan(self, colspan):
        self.colspan = colspan
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_scopeType(self, value):
        # Validate type scopeType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['row', 'col', 'rowgroup', 'colgroup']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on scopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_alignType5(self, value):
        # Validate type alignType5, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType5' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType6(self, value):
        # Validate type valignType6, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType6' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Td', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Td')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Td':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Td')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Td', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Td'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.abbr is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            outfile.write(' abbr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.abbr), input_name='abbr')), ))
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            outfile.write(' axis=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.axis), input_name='axis')), ))
        if self.headers is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            outfile.write(' headers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.headers), input_name='headers')), ))
        if self.scope is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
        if self.rowspan != "1" and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            outfile.write(' rowspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rowspan), input_name='rowspan')), ))
        if self.colspan != "1" and 'colspan' not in already_processed:
            already_processed.add('colspan')
            outfile.write(' colspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.colspan), input_name='colspan')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Td', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            namespaceprefix_ = self.paragraph_nsprefix_ + ':' if (UseCapturedNS_ and self.paragraph_nsprefix_) else ''
            paragraph_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            namespaceprefix_ = self.list_nsprefix_ + ':' if (UseCapturedNS_ and self.list_nsprefix_) else ''
            list_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='list', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('abbr', node)
        if value is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            self.abbr = value
        value = find_attr_value_('axis', node)
        if value is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            self.axis = value
        value = find_attr_value_('headers', node)
        if value is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            self.headers = value
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_scopeType(self.scope)    # validate type scopeType
        value = find_attr_value_('rowspan', node)
        if value is not None and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            self.rowspan = value
        value = find_attr_value_('colspan', node)
        if value is not None and 'colspan' not in already_processed:
            already_processed.add('colspan')
            self.colspan = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType5(self.align)    # validate type alignType5
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType6(self.valign)    # validate type valignType6
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Td


class StrucDoc_Tfoot(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, align=None, char=None, charoff=None, valign=None, tr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
        self.tr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Tfoot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Tfoot.subclass:
            return StrucDoc_Tfoot.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Tfoot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tr(self):
        return self.tr
    def set_tr(self, tr):
        self.tr = tr
    def add_tr(self, value):
        self.tr.append(value)
    def insert_tr_at(self, index, value):
        self.tr.insert(index, value)
    def replace_tr_at(self, index, value):
        self.tr[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType7(self, value):
        # Validate type alignType7, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType7' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType8(self, value):
        # Validate type valignType8, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType8' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Tfoot', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Tfoot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Tfoot':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Tfoot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Tfoot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Tfoot'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Tfoot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            namespaceprefix_ = self.tr_nsprefix_ + ':' if (UseCapturedNS_ and self.tr_nsprefix_) else ''
            tr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType7(self.align)    # validate type alignType7
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType8(self.valign)    # validate type valignType8
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tr':
            obj_ = StrucDoc_Tr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'
# end class StrucDoc_Tfoot


class StrucDoc_Th(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, abbr=None, axis=None, headers=None, scope=None, rowspan='1', colspan='1', align=None, char=None, charoff=None, valign=None, content=None, linkHtml=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, renderMultiMedia=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.abbr = _cast(None, abbr)
        self.abbr_nsprefix_ = None
        self.axis = _cast(None, axis)
        self.axis_nsprefix_ = None
        self.headers = _cast(None, headers)
        self.headers_nsprefix_ = None
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        self.rowspan = _cast(None, rowspan)
        self.rowspan_nsprefix_ = None
        self.colspan = _cast(None, colspan)
        self.colspan_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if content is None:
            self.content = []
        else:
            self.content = content
        self.content_nsprefix_ = None
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        self.linkHtml_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = None
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        self.sup_nsprefix_ = None
        if br is None:
            self.br = []
        else:
            self.br = br
        self.br_nsprefix_ = None
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        self.footnote_nsprefix_ = None
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.footnoteRef_nsprefix_ = None
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.renderMultiMedia_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Th)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Th.subclass:
            return StrucDoc_Th.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Th(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    def add_content(self, value):
        self.content.append(value)
    def insert_content_at(self, index, value):
        self.content.insert(index, value)
    def replace_content_at(self, index, value):
        self.content[index] = value
    def get_linkHtml(self):
        return self.linkHtml
    def set_linkHtml(self, linkHtml):
        self.linkHtml = linkHtml
    def add_linkHtml(self, value):
        self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value):
        self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value):
        self.linkHtml[index] = value
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_sup(self):
        return self.sup
    def set_sup(self, sup):
        self.sup = sup
    def add_sup(self, value):
        self.sup.append(value)
    def insert_sup_at(self, index, value):
        self.sup.insert(index, value)
    def replace_sup_at(self, index, value):
        self.sup[index] = value
    def get_br(self):
        return self.br
    def set_br(self, br):
        self.br = br
    def add_br(self, value):
        self.br.append(value)
    def insert_br_at(self, index, value):
        self.br.insert(index, value)
    def replace_br_at(self, index, value):
        self.br[index] = value
    def get_footnote(self):
        return self.footnote
    def set_footnote(self, footnote):
        self.footnote = footnote
    def add_footnote(self, value):
        self.footnote.append(value)
    def insert_footnote_at(self, index, value):
        self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value):
        self.footnote[index] = value
    def get_footnoteRef(self):
        return self.footnoteRef
    def set_footnoteRef(self, footnoteRef):
        self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value):
        self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value):
        self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value):
        self.footnoteRef[index] = value
    def get_renderMultiMedia(self):
        return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia):
        self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value):
        self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value):
        self.renderMultiMedia[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_abbr(self):
        return self.abbr
    def set_abbr(self, abbr):
        self.abbr = abbr
    def get_axis(self):
        return self.axis
    def set_axis(self, axis):
        self.axis = axis
    def get_headers(self):
        return self.headers
    def set_headers(self, headers):
        self.headers = headers
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_rowspan(self):
        return self.rowspan
    def set_rowspan(self, rowspan):
        self.rowspan = rowspan
    def get_colspan(self):
        return self.colspan
    def set_colspan(self, colspan):
        self.colspan = colspan
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_scopeType9(self, value):
        # Validate type scopeType9, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['row', 'col', 'rowgroup', 'colgroup']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on scopeType9' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_alignType10(self, value):
        # Validate type alignType10, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType10' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType11(self, value):
        # Validate type valignType11, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType11' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Th', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Th')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Th':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Th')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Th', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Th'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.abbr is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            outfile.write(' abbr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.abbr), input_name='abbr')), ))
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            outfile.write(' axis=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.axis), input_name='axis')), ))
        if self.headers is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            outfile.write(' headers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.headers), input_name='headers')), ))
        if self.scope is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
        if self.rowspan != "1" and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            outfile.write(' rowspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rowspan), input_name='rowspan')), ))
        if self.colspan != "1" and 'colspan' not in already_processed:
            already_processed.add('colspan')
            outfile.write(' colspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.colspan), input_name='colspan')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Th', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            namespaceprefix_ = self.content_nsprefix_ + ':' if (UseCapturedNS_ and self.content_nsprefix_) else ''
            content_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            namespaceprefix_ = self.linkHtml_nsprefix_ + ':' if (UseCapturedNS_ and self.linkHtml_nsprefix_) else ''
            linkHtml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            namespaceprefix_ = self.sup_nsprefix_ + ':' if (UseCapturedNS_ and self.sup_nsprefix_) else ''
            sup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            namespaceprefix_ = self.br_nsprefix_ + ':' if (UseCapturedNS_ and self.br_nsprefix_) else ''
            br_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            namespaceprefix_ = self.footnote_nsprefix_ + ':' if (UseCapturedNS_ and self.footnote_nsprefix_) else ''
            footnote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            namespaceprefix_ = self.footnoteRef_nsprefix_ + ':' if (UseCapturedNS_ and self.footnoteRef_nsprefix_) else ''
            footnoteRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            namespaceprefix_ = self.renderMultiMedia_nsprefix_ + ':' if (UseCapturedNS_ and self.renderMultiMedia_nsprefix_) else ''
            renderMultiMedia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='renderMultiMedia', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('abbr', node)
        if value is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            self.abbr = value
        value = find_attr_value_('axis', node)
        if value is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            self.axis = value
        value = find_attr_value_('headers', node)
        if value is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            self.headers = value
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_scopeType9(self.scope)    # validate type scopeType9
        value = find_attr_value_('rowspan', node)
        if value is not None and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            self.rowspan = value
        value = find_attr_value_('colspan', node)
        if value is not None and 'colspan' not in already_processed:
            already_processed.add('colspan')
            self.colspan = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType10(self.align)    # validate type alignType10
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType11(self.valign)    # validate type valignType11
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class StrucDoc_Th


class StrucDoc_Thead(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, align=None, char=None, charoff=None, valign=None, tr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
        self.tr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Thead)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Thead.subclass:
            return StrucDoc_Thead.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Thead(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tr(self):
        return self.tr
    def set_tr(self, tr):
        self.tr = tr
    def add_tr(self, value):
        self.tr.append(value)
    def insert_tr_at(self, index, value):
        self.tr.insert(index, value)
    def replace_tr_at(self, index, value):
        self.tr[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType12(self, value):
        # Validate type alignType12, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType12' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType13(self, value):
        # Validate type valignType13, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType13' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Thead', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Thead')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Thead':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Thead')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Thead', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Thead'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Thead', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            namespaceprefix_ = self.tr_nsprefix_ + ':' if (UseCapturedNS_ and self.tr_nsprefix_) else ''
            tr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType12(self.align)    # validate type alignType12
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType13(self.valign)    # validate type valignType13
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tr':
            obj_ = StrucDoc_Tr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'
# end class StrucDoc_Thead


class StrucDoc_Tr(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, align=None, char=None, charoff=None, valign=None, th=None, td=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.styleCode = _cast(None, styleCode)
        self.styleCode_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.char = _cast(None, char)
        self.char_nsprefix_ = None
        self.charoff = _cast(None, charoff)
        self.charoff_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        if th is None:
            self.th = []
        else:
            self.th = th
        self.th_nsprefix_ = None
        if td is None:
            self.td = []
        else:
            self.td = td
        self.td_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Tr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Tr.subclass:
            return StrucDoc_Tr.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Tr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_th(self):
        return self.th
    def set_th(self, th):
        self.th = th
    def add_th(self, value):
        self.th.append(value)
    def insert_th_at(self, index, value):
        self.th.insert(index, value)
    def replace_th_at(self, index, value):
        self.th[index] = value
    def get_td(self):
        return self.td
    def set_td(self, td):
        self.td = td
    def add_td(self, value):
        self.td.append(value)
    def insert_td_at(self, index, value):
        self.td.insert(index, value)
    def replace_td_at(self, index, value):
        self.td[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_styleCode(self):
        return self.styleCode
    def set_styleCode(self, styleCode):
        self.styleCode = styleCode
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_char(self):
        return self.char
    def set_char(self, char):
        self.char = char
    def get_charoff(self):
        return self.charoff
    def set_charoff(self, charoff):
        self.charoff = charoff
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def validate_alignType14(self, value):
        # Validate type alignType14, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'center', 'right', 'justify', 'char']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on alignType14' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valignType15(self, value):
        # Validate type valignType15, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['top', 'middle', 'bottom', 'baseline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valignType15' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.th or
            self.td
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Tr', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Tr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StrucDoc.Tr':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StrucDoc.Tr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StrucDoc.Tr', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StrucDoc.Tr'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='StrucDoc.Tr', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for th_ in self.th:
            namespaceprefix_ = self.th_nsprefix_ + ':' if (UseCapturedNS_ and self.th_nsprefix_) else ''
            th_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='th', pretty_print=pretty_print)
        for td_ in self.td:
            namespaceprefix_ = self.td_nsprefix_ + ':' if (UseCapturedNS_ and self.td_nsprefix_) else ''
            td_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='td', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_alignType14(self.align)    # validate type alignType14
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_valignType15(self.valign)    # validate type valignType15
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'th':
            obj_ = StrucDoc_Th.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.th.append(obj_)
            obj_.original_tagname_ = 'th'
        elif nodeName_ == 'td':
            obj_ = StrucDoc_Td.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.td.append(obj_)
            obj_.original_tagname_ = 'td'
# end class StrucDoc_Tr


class tableOfContents(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, contentsCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if contentsCode is None:
            self.contentsCode = []
        else:
            self.contentsCode = contentsCode
        self.contentsCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tableOfContents)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tableOfContents.subclass:
            return tableOfContents.subclass(*args_, **kwargs_)
        else:
            return tableOfContents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_contentsCode(self):
        return self.contentsCode
    def set_contentsCode(self, contentsCode):
        self.contentsCode = contentsCode
    def add_contentsCode(self, value):
        self.contentsCode.append(value)
    def insert_contentsCode_at(self, index, value):
        self.contentsCode.insert(index, value)
    def replace_contentsCode_at(self, index, value):
        self.contentsCode[index] = value
    def hasContent_(self):
        if (
            self.contentsCode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='tableOfContents', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tableOfContents')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tableOfContents':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tableOfContents')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tableOfContents', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tableOfContents'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='tableOfContents', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for contentsCode_ in self.contentsCode:
            namespaceprefix_ = self.contentsCode_nsprefix_ + ':' if (UseCapturedNS_ and self.contentsCode_nsprefix_) else ''
            contentsCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='contentsCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contentsCode':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contentsCode.append(obj_)
            obj_.original_tagname_ = 'contentsCode'
# end class tableOfContents


class serviceChainLink(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, serviceChainLinkId=None, serviceChainLinkName=None, serviceChainLinkCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.serviceChainLinkId = serviceChainLinkId
        self.serviceChainLinkId_nsprefix_ = None
        self.serviceChainLinkName = serviceChainLinkName
        self.serviceChainLinkName_nsprefix_ = None
        self.serviceChainLinkCode = serviceChainLinkCode
        self.serviceChainLinkCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, serviceChainLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if serviceChainLink.subclass:
            return serviceChainLink.subclass(*args_, **kwargs_)
        else:
            return serviceChainLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_serviceChainLinkId(self):
        return self.serviceChainLinkId
    def set_serviceChainLinkId(self, serviceChainLinkId):
        self.serviceChainLinkId = serviceChainLinkId
    def get_serviceChainLinkName(self):
        return self.serviceChainLinkName
    def set_serviceChainLinkName(self, serviceChainLinkName):
        self.serviceChainLinkName = serviceChainLinkName
    def get_serviceChainLinkCode(self):
        return self.serviceChainLinkCode
    def set_serviceChainLinkCode(self, serviceChainLinkCode):
        self.serviceChainLinkCode = serviceChainLinkCode
    def hasContent_(self):
        if (
            self.serviceChainLinkId is not None or
            self.serviceChainLinkName is not None or
            self.serviceChainLinkCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='serviceChainLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('serviceChainLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'serviceChainLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='serviceChainLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='serviceChainLink', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='serviceChainLink'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='serviceChainLink', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.serviceChainLinkId is not None:
            namespaceprefix_ = self.serviceChainLinkId_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceChainLinkId_nsprefix_) else ''
            self.serviceChainLinkId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceChainLinkId', pretty_print=pretty_print)
        if self.serviceChainLinkName is not None:
            namespaceprefix_ = self.serviceChainLinkName_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceChainLinkName_nsprefix_) else ''
            self.serviceChainLinkName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceChainLinkName', pretty_print=pretty_print)
        if self.serviceChainLinkCode is not None:
            namespaceprefix_ = self.serviceChainLinkCode_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceChainLinkCode_nsprefix_) else ''
            self.serviceChainLinkCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceChainLinkCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'serviceChainLinkId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceChainLinkId = obj_
            obj_.original_tagname_ = 'serviceChainLinkId'
        elif nodeName_ == 'serviceChainLinkName':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceChainLinkName = obj_
            obj_.original_tagname_ = 'serviceChainLinkName'
        elif nodeName_ == 'serviceChainLinkCode':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceChainLinkCode = obj_
            obj_.original_tagname_ = 'serviceChainLinkCode'
# end class serviceChainLink


class episodeLink(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, episodeLinkId=None, episodeLinkName=None, episodeLinkCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.episodeLinkId = episodeLinkId
        self.episodeLinkId_nsprefix_ = None
        self.episodeLinkName = episodeLinkName
        self.episodeLinkName_nsprefix_ = None
        self.episodeLinkCode = episodeLinkCode
        self.episodeLinkCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, episodeLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if episodeLink.subclass:
            return episodeLink.subclass(*args_, **kwargs_)
        else:
            return episodeLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_episodeLinkId(self):
        return self.episodeLinkId
    def set_episodeLinkId(self, episodeLinkId):
        self.episodeLinkId = episodeLinkId
    def get_episodeLinkName(self):
        return self.episodeLinkName
    def set_episodeLinkName(self, episodeLinkName):
        self.episodeLinkName = episodeLinkName
    def get_episodeLinkCode(self):
        return self.episodeLinkCode
    def set_episodeLinkCode(self, episodeLinkCode):
        self.episodeLinkCode = episodeLinkCode
    def hasContent_(self):
        if (
            self.episodeLinkId is not None or
            self.episodeLinkName is not None or
            self.episodeLinkCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='episodeLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('episodeLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'episodeLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='episodeLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='episodeLink', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='episodeLink'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='episodeLink', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.episodeLinkId is not None:
            namespaceprefix_ = self.episodeLinkId_nsprefix_ + ':' if (UseCapturedNS_ and self.episodeLinkId_nsprefix_) else ''
            self.episodeLinkId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='episodeLinkId', pretty_print=pretty_print)
        if self.episodeLinkName is not None:
            namespaceprefix_ = self.episodeLinkName_nsprefix_ + ':' if (UseCapturedNS_ and self.episodeLinkName_nsprefix_) else ''
            self.episodeLinkName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='episodeLinkName', pretty_print=pretty_print)
        if self.episodeLinkCode is not None:
            namespaceprefix_ = self.episodeLinkCode_nsprefix_ + ':' if (UseCapturedNS_ and self.episodeLinkCode_nsprefix_) else ''
            self.episodeLinkCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='episodeLinkCode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'episodeLinkId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.episodeLinkId = obj_
            obj_.original_tagname_ = 'episodeLinkId'
        elif nodeName_ == 'episodeLinkName':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.episodeLinkName = obj_
            obj_.original_tagname_ = 'episodeLinkName'
        elif nodeName_ == 'episodeLinkCode':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.episodeLinkCode = obj_
            obj_.original_tagname_ = 'episodeLinkCode'
# end class episodeLink


class product(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, moderator=None, product_member=None, version=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.moderator = _cast(None, moderator)
        self.moderator_nsprefix_ = None
        self.product = _cast(None, product_member)
        self.product_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, product)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if product.subclass:
            return product.subclass(*args_, **kwargs_)
        else:
            return product(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_moderator(self):
        return self.moderator
    def set_moderator(self, moderator):
        self.moderator = moderator
    def get_product(self):
        return self.product
    def set_product(self, product):
        self.product = product
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='product', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('product')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'product':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='product')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='product', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='product'):
        if self.moderator is not None and 'moderator' not in already_processed:
            already_processed.add('moderator')
            outfile.write(' moderator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.moderator), input_name='moderator')), ))
        if self.product is not None and 'product' not in already_processed:
            already_processed.add('product')
            outfile.write(' product=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.product), input_name='product')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='product', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(obj_)
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('moderator', node)
        if value is not None and 'moderator' not in already_processed:
            already_processed.add('moderator')
            self.moderator = value
        value = find_attr_value_('product', node)
        if value is not None and 'product' not in already_processed:
            already_processed.add('product')
            self.product = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'product')
        self.add_anytypeobjs_(content_)
# end class product


class signatureCollection(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if signature is None:
            self.signature = []
        else:
            self.signature = signature
        self.signature_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signatureCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signatureCollection.subclass:
            return signatureCollection.subclass(*args_, **kwargs_)
        else:
            return signatureCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_signature(self):
        return self.signature
    def set_signature(self, signature):
        self.signature = signature
    def add_signature(self, value):
        self.signature.append(value)
    def insert_signature_at(self, index, value):
        self.signature.insert(index, value)
    def replace_signature_at(self, index, value):
        self.signature[index] = value
    def hasContent_(self):
        if (
            self.signature
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='signatureCollection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('signatureCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'signatureCollection':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='signatureCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='signatureCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='signatureCollection'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='signatureCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for signature_ in self.signature:
            namespaceprefix_ = self.signature_nsprefix_ + ':' if (UseCapturedNS_ and self.signature_nsprefix_) else ''
            signature_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'signature':
            obj_ = signatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signature.append(obj_)
            obj_.original_tagname_ = 'signature'
# end class signatureCollection


class secondaryCustodian(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, secondaryCustodianId=None, secondaryCustodianRegisterId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.secondaryCustodianId = secondaryCustodianId
        self.secondaryCustodianId_nsprefix_ = None
        self.secondaryCustodianRegisterId = secondaryCustodianRegisterId
        self.secondaryCustodianRegisterId_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, secondaryCustodian)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if secondaryCustodian.subclass:
            return secondaryCustodian.subclass(*args_, **kwargs_)
        else:
            return secondaryCustodian(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_secondaryCustodianId(self):
        return self.secondaryCustodianId
    def set_secondaryCustodianId(self, secondaryCustodianId):
        self.secondaryCustodianId = secondaryCustodianId
    def get_secondaryCustodianRegisterId(self):
        return self.secondaryCustodianRegisterId
    def set_secondaryCustodianRegisterId(self, secondaryCustodianRegisterId):
        self.secondaryCustodianRegisterId = secondaryCustodianRegisterId
    def hasContent_(self):
        if (
            self.secondaryCustodianId is not None or
            self.secondaryCustodianRegisterId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='secondaryCustodian', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('secondaryCustodian')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'secondaryCustodian':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='secondaryCustodian')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='secondaryCustodian', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='secondaryCustodian'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='secondaryCustodian', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.secondaryCustodianId is not None:
            namespaceprefix_ = self.secondaryCustodianId_nsprefix_ + ':' if (UseCapturedNS_ and self.secondaryCustodianId_nsprefix_) else ''
            self.secondaryCustodianId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='secondaryCustodianId', pretty_print=pretty_print)
        if self.secondaryCustodianRegisterId is not None:
            namespaceprefix_ = self.secondaryCustodianRegisterId_nsprefix_ + ':' if (UseCapturedNS_ and self.secondaryCustodianRegisterId_nsprefix_) else ''
            self.secondaryCustodianRegisterId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='secondaryCustodianRegisterId', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'secondaryCustodianId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.secondaryCustodianId = obj_
            obj_.original_tagname_ = 'secondaryCustodianId'
        elif nodeName_ == 'secondaryCustodianRegisterId':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.secondaryCustodianRegisterId = obj_
            obj_.original_tagname_ = 'secondaryCustodianRegisterId'
# end class secondaryCustodian


class KantaMetadata(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, FieldName=None, FieldNameCoded=None, FieldValue=None, FieldValueAsHL7Datatyped=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.FieldName = FieldName
        self.FieldName_nsprefix_ = None
        self.FieldNameCoded = FieldNameCoded
        self.FieldNameCoded_nsprefix_ = None
        self.FieldValue = FieldValue
        self.FieldValue_nsprefix_ = None
        self.FieldValueAsHL7Datatyped = FieldValueAsHL7Datatyped
        self.FieldValueAsHL7Datatyped_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KantaMetadata)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KantaMetadata.subclass:
            return KantaMetadata.subclass(*args_, **kwargs_)
        else:
            return KantaMetadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FieldName(self):
        return self.FieldName
    def set_FieldName(self, FieldName):
        self.FieldName = FieldName
    def get_FieldNameCoded(self):
        return self.FieldNameCoded
    def set_FieldNameCoded(self, FieldNameCoded):
        self.FieldNameCoded = FieldNameCoded
    def get_FieldValue(self):
        return self.FieldValue
    def set_FieldValue(self, FieldValue):
        self.FieldValue = FieldValue
    def get_FieldValueAsHL7Datatyped(self):
        return self.FieldValueAsHL7Datatyped
    def set_FieldValueAsHL7Datatyped(self, FieldValueAsHL7Datatyped):
        self.FieldValueAsHL7Datatyped = FieldValueAsHL7Datatyped
    def hasContent_(self):
        if (
            self.FieldName is not None or
            self.FieldNameCoded is not None or
            self.FieldValue is not None or
            self.FieldValueAsHL7Datatyped is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='KantaMetadata', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KantaMetadata')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'KantaMetadata':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KantaMetadata')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='KantaMetadata', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='KantaMetadata'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='KantaMetadata', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FieldName is not None:
            namespaceprefix_ = self.FieldName_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldName_nsprefix_) else ''
            self.FieldName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldName', pretty_print=pretty_print)
        if self.FieldNameCoded is not None:
            namespaceprefix_ = self.FieldNameCoded_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldNameCoded_nsprefix_) else ''
            self.FieldNameCoded.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldNameCoded', pretty_print=pretty_print)
        if self.FieldValue is not None:
            namespaceprefix_ = self.FieldValue_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldValue_nsprefix_) else ''
            self.FieldValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldValue', pretty_print=pretty_print)
        if self.FieldValueAsHL7Datatyped is not None:
            namespaceprefix_ = self.FieldValueAsHL7Datatyped_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldValueAsHL7Datatyped_nsprefix_) else ''
            self.FieldValueAsHL7Datatyped.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldValueAsHL7Datatyped', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FieldName':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldName = obj_
            obj_.original_tagname_ = 'FieldName'
        elif nodeName_ == 'FieldNameCoded':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldNameCoded = obj_
            obj_.original_tagname_ = 'FieldNameCoded'
        elif nodeName_ == 'FieldValue':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldValue = obj_
            obj_.original_tagname_ = 'FieldValue'
        elif nodeName_ == 'FieldValueAsHL7Datatyped':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldValueAsHL7Datatyped = obj_
            obj_.original_tagname_ = 'FieldValueAsHL7Datatyped'
# end class KantaMetadata


class auditTrail(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, auditTrailCode=None, auditTrailTime=None, auditTrailId=None, auditTrailIdEnd=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.auditTrailCode = auditTrailCode
        self.auditTrailCode_nsprefix_ = None
        self.auditTrailTime = auditTrailTime
        self.auditTrailTime_nsprefix_ = None
        self.auditTrailId = auditTrailId
        self.auditTrailId_nsprefix_ = None
        self.auditTrailIdEnd = auditTrailIdEnd
        self.auditTrailIdEnd_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, auditTrail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if auditTrail.subclass:
            return auditTrail.subclass(*args_, **kwargs_)
        else:
            return auditTrail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_auditTrailCode(self):
        return self.auditTrailCode
    def set_auditTrailCode(self, auditTrailCode):
        self.auditTrailCode = auditTrailCode
    def get_auditTrailTime(self):
        return self.auditTrailTime
    def set_auditTrailTime(self, auditTrailTime):
        self.auditTrailTime = auditTrailTime
    def get_auditTrailId(self):
        return self.auditTrailId
    def set_auditTrailId(self, auditTrailId):
        self.auditTrailId = auditTrailId
    def get_auditTrailIdEnd(self):
        return self.auditTrailIdEnd
    def set_auditTrailIdEnd(self, auditTrailIdEnd):
        self.auditTrailIdEnd = auditTrailIdEnd
    def hasContent_(self):
        if (
            self.auditTrailCode is not None or
            self.auditTrailTime is not None or
            self.auditTrailId is not None or
            self.auditTrailIdEnd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='auditTrail', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('auditTrail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'auditTrail':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='auditTrail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='auditTrail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='auditTrail'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='auditTrail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.auditTrailCode is not None:
            namespaceprefix_ = self.auditTrailCode_nsprefix_ + ':' if (UseCapturedNS_ and self.auditTrailCode_nsprefix_) else ''
            self.auditTrailCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='auditTrailCode', pretty_print=pretty_print)
        if self.auditTrailTime is not None:
            namespaceprefix_ = self.auditTrailTime_nsprefix_ + ':' if (UseCapturedNS_ and self.auditTrailTime_nsprefix_) else ''
            self.auditTrailTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='auditTrailTime', pretty_print=pretty_print)
        if self.auditTrailId is not None:
            namespaceprefix_ = self.auditTrailId_nsprefix_ + ':' if (UseCapturedNS_ and self.auditTrailId_nsprefix_) else ''
            self.auditTrailId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='auditTrailId', pretty_print=pretty_print)
        if self.auditTrailIdEnd is not None:
            namespaceprefix_ = self.auditTrailIdEnd_nsprefix_ + ':' if (UseCapturedNS_ and self.auditTrailIdEnd_nsprefix_) else ''
            self.auditTrailIdEnd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='auditTrailIdEnd', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'auditTrailCode':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.auditTrailCode = obj_
            obj_.original_tagname_ = 'auditTrailCode'
        elif nodeName_ == 'auditTrailTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.auditTrailTime = obj_
            obj_.original_tagname_ = 'auditTrailTime'
        elif nodeName_ == 'auditTrailId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.auditTrailId = obj_
            obj_.original_tagname_ = 'auditTrailId'
        elif nodeName_ == 'auditTrailIdEnd':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.auditTrailIdEnd = obj_
            obj_.original_tagname_ = 'auditTrailIdEnd'
# end class auditTrail


class sender(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, senderCode=None, senderName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.senderCode = senderCode
        self.senderCode_nsprefix_ = None
        self.senderName = senderName
        self.senderName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sender)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sender.subclass:
            return sender.subclass(*args_, **kwargs_)
        else:
            return sender(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_senderCode(self):
        return self.senderCode
    def set_senderCode(self, senderCode):
        self.senderCode = senderCode
    def get_senderName(self):
        return self.senderName
    def set_senderName(self, senderName):
        self.senderName = senderName
    def hasContent_(self):
        if (
            self.senderCode is not None or
            self.senderName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='sender', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sender')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'sender':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sender')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='sender', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sender'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3" ', name_='sender', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.senderCode is not None:
            namespaceprefix_ = self.senderCode_nsprefix_ + ':' if (UseCapturedNS_ and self.senderCode_nsprefix_) else ''
            self.senderCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='senderCode', pretty_print=pretty_print)
        if self.senderName is not None:
            namespaceprefix_ = self.senderName_nsprefix_ + ':' if (UseCapturedNS_ and self.senderName_nsprefix_) else ''
            self.senderName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='senderName', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'senderCode':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.senderCode = obj_
            obj_.original_tagname_ = 'senderCode'
        elif nodeName_ == 'senderName':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.senderName = obj_
            obj_.original_tagname_ = 'senderName'
# end class sender


class localHeader(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, description=None, tableOfContents=None, registratedTime=None, declaredTime=None, typeCode=None, fileFormat=None, softwareSupport=None, documentType=None, currentLocation=None, retentionPeriod=None, functionCode=None, recordStatus=None, auditTrail=None, serviceChainLink=None, episodeLink=None, product=None, signatureCollection=None, sender=None, password=None, patientRegistrySpecifier=None, patientRegistrySpecifierName=None, custodianTypeCode=None, encompassingEncounterCode=None, activeCustodian=None, activeCustodianName=None, encompassingEncounterMasterCode=None, secondaryEncompassingEncounterId=None, outsourcingServiceCustomer=None, outsourcingServiceCustomerName=None, retentionPeriodClass=None, extendedRetentionPeriod=None, sensitiveDocument=None, eprServiceProvider=None, eprServiceProviderName=None, releaseDateForPatientViewing=None, patientHomeMunicipality=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.tableOfContents = tableOfContents
        self.tableOfContents_nsprefix_ = None
        self.registratedTime = registratedTime
        self.registratedTime_nsprefix_ = None
        self.declaredTime = declaredTime
        self.declaredTime_nsprefix_ = None
        self.typeCode = typeCode
        self.typeCode_nsprefix_ = None
        self.fileFormat = fileFormat
        self.fileFormat_nsprefix_ = None
        self.softwareSupport = softwareSupport
        self.softwareSupport_nsprefix_ = None
        self.documentType = documentType
        self.documentType_nsprefix_ = None
        self.currentLocation = currentLocation
        self.currentLocation_nsprefix_ = None
        self.retentionPeriod = retentionPeriod
        self.retentionPeriod_nsprefix_ = None
        self.functionCode = functionCode
        self.functionCode_nsprefix_ = None
        self.recordStatus = recordStatus
        self.recordStatus_nsprefix_ = None
        if auditTrail is None:
            self.auditTrail = []
        else:
            self.auditTrail = auditTrail
        self.auditTrail_nsprefix_ = None
        if serviceChainLink is None:
            self.serviceChainLink = []
        else:
            self.serviceChainLink = serviceChainLink
        self.serviceChainLink_nsprefix_ = None
        if episodeLink is None:
            self.episodeLink = []
        else:
            self.episodeLink = episodeLink
        self.episodeLink_nsprefix_ = None
        if product is None:
            self.product = []
        else:
            self.product = product
        self.product_nsprefix_ = None
        self.signatureCollection = signatureCollection
        self.signatureCollection_nsprefix_ = None
        self.sender = sender
        self.sender_nsprefix_ = None
        self.password = password
        self.password_nsprefix_ = None
        self.patientRegistrySpecifier = patientRegistrySpecifier
        self.patientRegistrySpecifier_nsprefix_ = None
        self.patientRegistrySpecifierName = patientRegistrySpecifierName
        self.patientRegistrySpecifierName_nsprefix_ = None
        self.custodianTypeCode = custodianTypeCode
        self.custodianTypeCode_nsprefix_ = None
        self.encompassingEncounterCode = encompassingEncounterCode
        self.encompassingEncounterCode_nsprefix_ = None
        self.activeCustodian = activeCustodian
        self.activeCustodian_nsprefix_ = None
        self.activeCustodianName = activeCustodianName
        self.activeCustodianName_nsprefix_ = None
        self.encompassingEncounterMasterCode = encompassingEncounterMasterCode
        self.encompassingEncounterMasterCode_nsprefix_ = None
        self.secondaryEncompassingEncounterId = secondaryEncompassingEncounterId
        self.secondaryEncompassingEncounterId_nsprefix_ = None
        self.outsourcingServiceCustomer = outsourcingServiceCustomer
        self.outsourcingServiceCustomer_nsprefix_ = None
        self.outsourcingServiceCustomerName = outsourcingServiceCustomerName
        self.outsourcingServiceCustomerName_nsprefix_ = None
        self.retentionPeriodClass = retentionPeriodClass
        self.retentionPeriodClass_nsprefix_ = None
        self.extendedRetentionPeriod = extendedRetentionPeriod
        self.extendedRetentionPeriod_nsprefix_ = None
        self.sensitiveDocument = sensitiveDocument
        self.sensitiveDocument_nsprefix_ = None
        self.eprServiceProvider = eprServiceProvider
        self.eprServiceProvider_nsprefix_ = None
        self.eprServiceProviderName = eprServiceProviderName
        self.eprServiceProviderName_nsprefix_ = None
        self.releaseDateForPatientViewing = releaseDateForPatientViewing
        self.releaseDateForPatientViewing_nsprefix_ = None
        self.patientHomeMunicipality = patientHomeMunicipality
        self.patientHomeMunicipality_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, localHeader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if localHeader.subclass:
            return localHeader.subclass(*args_, **kwargs_)
        else:
            return localHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_tableOfContents(self):
        return self.tableOfContents
    def set_tableOfContents(self, tableOfContents):
        self.tableOfContents = tableOfContents
    def get_registratedTime(self):
        return self.registratedTime
    def set_registratedTime(self, registratedTime):
        self.registratedTime = registratedTime
    def get_declaredTime(self):
        return self.declaredTime
    def set_declaredTime(self, declaredTime):
        self.declaredTime = declaredTime
    def get_typeCode(self):
        return self.typeCode
    def set_typeCode(self, typeCode):
        self.typeCode = typeCode
    def get_fileFormat(self):
        return self.fileFormat
    def set_fileFormat(self, fileFormat):
        self.fileFormat = fileFormat
    def get_softwareSupport(self):
        return self.softwareSupport
    def set_softwareSupport(self, softwareSupport):
        self.softwareSupport = softwareSupport
    def get_documentType(self):
        return self.documentType
    def set_documentType(self, documentType):
        self.documentType = documentType
    def get_currentLocation(self):
        return self.currentLocation
    def set_currentLocation(self, currentLocation):
        self.currentLocation = currentLocation
    def get_retentionPeriod(self):
        return self.retentionPeriod
    def set_retentionPeriod(self, retentionPeriod):
        self.retentionPeriod = retentionPeriod
    def get_functionCode(self):
        return self.functionCode
    def set_functionCode(self, functionCode):
        self.functionCode = functionCode
    def get_recordStatus(self):
        return self.recordStatus
    def set_recordStatus(self, recordStatus):
        self.recordStatus = recordStatus
    def get_auditTrail(self):
        return self.auditTrail
    def set_auditTrail(self, auditTrail):
        self.auditTrail = auditTrail
    def add_auditTrail(self, value):
        self.auditTrail.append(value)
    def insert_auditTrail_at(self, index, value):
        self.auditTrail.insert(index, value)
    def replace_auditTrail_at(self, index, value):
        self.auditTrail[index] = value
    def get_serviceChainLink(self):
        return self.serviceChainLink
    def set_serviceChainLink(self, serviceChainLink):
        self.serviceChainLink = serviceChainLink
    def add_serviceChainLink(self, value):
        self.serviceChainLink.append(value)
    def insert_serviceChainLink_at(self, index, value):
        self.serviceChainLink.insert(index, value)
    def replace_serviceChainLink_at(self, index, value):
        self.serviceChainLink[index] = value
    def get_episodeLink(self):
        return self.episodeLink
    def set_episodeLink(self, episodeLink):
        self.episodeLink = episodeLink
    def add_episodeLink(self, value):
        self.episodeLink.append(value)
    def insert_episodeLink_at(self, index, value):
        self.episodeLink.insert(index, value)
    def replace_episodeLink_at(self, index, value):
        self.episodeLink[index] = value
    def get_product(self):
        return self.product
    def set_product(self, product):
        self.product = product
    def add_product(self, value):
        self.product.append(value)
    def insert_product_at(self, index, value):
        self.product.insert(index, value)
    def replace_product_at(self, index, value):
        self.product[index] = value
    def get_signatureCollection(self):
        return self.signatureCollection
    def set_signatureCollection(self, signatureCollection):
        self.signatureCollection = signatureCollection
    def get_sender(self):
        return self.sender
    def set_sender(self, sender):
        self.sender = sender
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    def get_patientRegistrySpecifier(self):
        return self.patientRegistrySpecifier
    def set_patientRegistrySpecifier(self, patientRegistrySpecifier):
        self.patientRegistrySpecifier = patientRegistrySpecifier
    def get_patientRegistrySpecifierName(self):
        return self.patientRegistrySpecifierName
    def set_patientRegistrySpecifierName(self, patientRegistrySpecifierName):
        self.patientRegistrySpecifierName = patientRegistrySpecifierName
    def get_custodianTypeCode(self):
        return self.custodianTypeCode
    def set_custodianTypeCode(self, custodianTypeCode):
        self.custodianTypeCode = custodianTypeCode
    def get_encompassingEncounterCode(self):
        return self.encompassingEncounterCode
    def set_encompassingEncounterCode(self, encompassingEncounterCode):
        self.encompassingEncounterCode = encompassingEncounterCode
    def get_activeCustodian(self):
        return self.activeCustodian
    def set_activeCustodian(self, activeCustodian):
        self.activeCustodian = activeCustodian
    def get_activeCustodianName(self):
        return self.activeCustodianName
    def set_activeCustodianName(self, activeCustodianName):
        self.activeCustodianName = activeCustodianName
    def get_encompassingEncounterMasterCode(self):
        return self.encompassingEncounterMasterCode
    def set_encompassingEncounterMasterCode(self, encompassingEncounterMasterCode):
        self.encompassingEncounterMasterCode = encompassingEncounterMasterCode
    def get_secondaryEncompassingEncounterId(self):
        return self.secondaryEncompassingEncounterId
    def set_secondaryEncompassingEncounterId(self, secondaryEncompassingEncounterId):
        self.secondaryEncompassingEncounterId = secondaryEncompassingEncounterId
    def get_outsourcingServiceCustomer(self):
        return self.outsourcingServiceCustomer
    def set_outsourcingServiceCustomer(self, outsourcingServiceCustomer):
        self.outsourcingServiceCustomer = outsourcingServiceCustomer
    def get_outsourcingServiceCustomerName(self):
        return self.outsourcingServiceCustomerName
    def set_outsourcingServiceCustomerName(self, outsourcingServiceCustomerName):
        self.outsourcingServiceCustomerName = outsourcingServiceCustomerName
    def get_retentionPeriodClass(self):
        return self.retentionPeriodClass
    def set_retentionPeriodClass(self, retentionPeriodClass):
        self.retentionPeriodClass = retentionPeriodClass
    def get_extendedRetentionPeriod(self):
        return self.extendedRetentionPeriod
    def set_extendedRetentionPeriod(self, extendedRetentionPeriod):
        self.extendedRetentionPeriod = extendedRetentionPeriod
    def get_sensitiveDocument(self):
        return self.sensitiveDocument
    def set_sensitiveDocument(self, sensitiveDocument):
        self.sensitiveDocument = sensitiveDocument
    def get_eprServiceProvider(self):
        return self.eprServiceProvider
    def set_eprServiceProvider(self, eprServiceProvider):
        self.eprServiceProvider = eprServiceProvider
    def get_eprServiceProviderName(self):
        return self.eprServiceProviderName
    def set_eprServiceProviderName(self, eprServiceProviderName):
        self.eprServiceProviderName = eprServiceProviderName
    def get_releaseDateForPatientViewing(self):
        return self.releaseDateForPatientViewing
    def set_releaseDateForPatientViewing(self, releaseDateForPatientViewing):
        self.releaseDateForPatientViewing = releaseDateForPatientViewing
    def get_patientHomeMunicipality(self):
        return self.patientHomeMunicipality
    def set_patientHomeMunicipality(self, patientHomeMunicipality):
        self.patientHomeMunicipality = patientHomeMunicipality
    def hasContent_(self):
        if (
            self.description is not None or
            self.tableOfContents is not None or
            self.registratedTime is not None or
            self.declaredTime is not None or
            self.typeCode is not None or
            self.fileFormat is not None or
            self.softwareSupport is not None or
            self.documentType is not None or
            self.currentLocation is not None or
            self.retentionPeriod is not None or
            self.functionCode is not None or
            self.recordStatus is not None or
            self.auditTrail or
            self.serviceChainLink or
            self.episodeLink or
            self.product or
            self.signatureCollection is not None or
            self.sender is not None or
            self.password is not None or
            self.patientRegistrySpecifier is not None or
            self.patientRegistrySpecifierName is not None or
            self.custodianTypeCode is not None or
            self.encompassingEncounterCode is not None or
            self.activeCustodian is not None or
            self.activeCustodianName is not None or
            self.encompassingEncounterMasterCode is not None or
            self.secondaryEncompassingEncounterId is not None or
            self.outsourcingServiceCustomer is not None or
            self.outsourcingServiceCustomerName is not None or
            self.retentionPeriodClass is not None or
            self.extendedRetentionPeriod is not None or
            self.sensitiveDocument is not None or
            self.eprServiceProvider is not None or
            self.eprServiceProviderName is not None or
            self.releaseDateForPatientViewing is not None or
            self.patientHomeMunicipality is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3"  xmlns:None="urn:hl7-org:v3" ', name_='localHeader', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('localHeader')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'localHeader':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='localHeader')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='localHeader', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='localHeader'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3"  xmlns:None="urn:hl7-org:v3" ', name_='localHeader', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            self.description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
        if self.tableOfContents is not None:
            namespaceprefix_ = self.tableOfContents_nsprefix_ + ':' if (UseCapturedNS_ and self.tableOfContents_nsprefix_) else ''
            self.tableOfContents.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tableOfContents', pretty_print=pretty_print)
        if self.registratedTime is not None:
            namespaceprefix_ = self.registratedTime_nsprefix_ + ':' if (UseCapturedNS_ and self.registratedTime_nsprefix_) else ''
            self.registratedTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='registratedTime', pretty_print=pretty_print)
        if self.declaredTime is not None:
            namespaceprefix_ = self.declaredTime_nsprefix_ + ':' if (UseCapturedNS_ and self.declaredTime_nsprefix_) else ''
            self.declaredTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='declaredTime', pretty_print=pretty_print)
        if self.typeCode is not None:
            namespaceprefix_ = self.typeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.typeCode_nsprefix_) else ''
            self.typeCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeCode', pretty_print=pretty_print)
        if self.fileFormat is not None:
            namespaceprefix_ = self.fileFormat_nsprefix_ + ':' if (UseCapturedNS_ and self.fileFormat_nsprefix_) else ''
            self.fileFormat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fileFormat', pretty_print=pretty_print)
        if self.softwareSupport is not None:
            namespaceprefix_ = self.softwareSupport_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareSupport_nsprefix_) else ''
            self.softwareSupport.export(outfile, level, namespaceprefix_, namespacedef_='', name_='softwareSupport', pretty_print=pretty_print)
        if self.documentType is not None:
            namespaceprefix_ = self.documentType_nsprefix_ + ':' if (UseCapturedNS_ and self.documentType_nsprefix_) else ''
            self.documentType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='documentType', pretty_print=pretty_print)
        if self.currentLocation is not None:
            namespaceprefix_ = self.currentLocation_nsprefix_ + ':' if (UseCapturedNS_ and self.currentLocation_nsprefix_) else ''
            self.currentLocation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='currentLocation', pretty_print=pretty_print)
        if self.retentionPeriod is not None:
            namespaceprefix_ = self.retentionPeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.retentionPeriod_nsprefix_) else ''
            self.retentionPeriod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='retentionPeriod', pretty_print=pretty_print)
        if self.functionCode is not None:
            namespaceprefix_ = self.functionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.functionCode_nsprefix_) else ''
            self.functionCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='functionCode', pretty_print=pretty_print)
        if self.recordStatus is not None:
            namespaceprefix_ = self.recordStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.recordStatus_nsprefix_) else ''
            self.recordStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recordStatus', pretty_print=pretty_print)
        for auditTrail_ in self.auditTrail:
            namespaceprefix_ = self.auditTrail_nsprefix_ + ':' if (UseCapturedNS_ and self.auditTrail_nsprefix_) else ''
            auditTrail_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='auditTrail', pretty_print=pretty_print)
        for serviceChainLink_ in self.serviceChainLink:
            namespaceprefix_ = self.serviceChainLink_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceChainLink_nsprefix_) else ''
            serviceChainLink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceChainLink', pretty_print=pretty_print)
        for episodeLink_ in self.episodeLink:
            namespaceprefix_ = self.episodeLink_nsprefix_ + ':' if (UseCapturedNS_ and self.episodeLink_nsprefix_) else ''
            episodeLink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='episodeLink', pretty_print=pretty_print)
        for product_ in self.product:
            namespaceprefix_ = self.product_nsprefix_ + ':' if (UseCapturedNS_ and self.product_nsprefix_) else ''
            product_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='product', pretty_print=pretty_print)
        if self.signatureCollection is not None:
            namespaceprefix_ = self.signatureCollection_nsprefix_ + ':' if (UseCapturedNS_ and self.signatureCollection_nsprefix_) else ''
            self.signatureCollection.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signatureCollection', pretty_print=pretty_print)
        if self.sender is not None:
            namespaceprefix_ = self.sender_nsprefix_ + ':' if (UseCapturedNS_ and self.sender_nsprefix_) else ''
            self.sender.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sender', pretty_print=pretty_print)
        if self.password is not None:
            namespaceprefix_ = self.password_nsprefix_ + ':' if (UseCapturedNS_ and self.password_nsprefix_) else ''
            self.password.export(outfile, level, namespaceprefix_, namespacedef_='', name_='password', pretty_print=pretty_print)
        if self.patientRegistrySpecifier is not None:
            namespaceprefix_ = self.patientRegistrySpecifier_nsprefix_ + ':' if (UseCapturedNS_ and self.patientRegistrySpecifier_nsprefix_) else ''
            self.patientRegistrySpecifier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='patientRegistrySpecifier', pretty_print=pretty_print)
        if self.patientRegistrySpecifierName is not None:
            namespaceprefix_ = self.patientRegistrySpecifierName_nsprefix_ + ':' if (UseCapturedNS_ and self.patientRegistrySpecifierName_nsprefix_) else ''
            self.patientRegistrySpecifierName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='patientRegistrySpecifierName', pretty_print=pretty_print)
        if self.custodianTypeCode is not None:
            namespaceprefix_ = self.custodianTypeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.custodianTypeCode_nsprefix_) else ''
            self.custodianTypeCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='custodianTypeCode', pretty_print=pretty_print)
        if self.encompassingEncounterCode is not None:
            namespaceprefix_ = self.encompassingEncounterCode_nsprefix_ + ':' if (UseCapturedNS_ and self.encompassingEncounterCode_nsprefix_) else ''
            self.encompassingEncounterCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encompassingEncounterCode', pretty_print=pretty_print)
        if self.activeCustodian is not None:
            namespaceprefix_ = self.activeCustodian_nsprefix_ + ':' if (UseCapturedNS_ and self.activeCustodian_nsprefix_) else ''
            self.activeCustodian.export(outfile, level, namespaceprefix_, namespacedef_='', name_='activeCustodian', pretty_print=pretty_print)
        if self.activeCustodianName is not None:
            namespaceprefix_ = self.activeCustodianName_nsprefix_ + ':' if (UseCapturedNS_ and self.activeCustodianName_nsprefix_) else ''
            self.activeCustodianName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='activeCustodianName', pretty_print=pretty_print)
        if self.encompassingEncounterMasterCode is not None:
            namespaceprefix_ = self.encompassingEncounterMasterCode_nsprefix_ + ':' if (UseCapturedNS_ and self.encompassingEncounterMasterCode_nsprefix_) else ''
            self.encompassingEncounterMasterCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encompassingEncounterMasterCode', pretty_print=pretty_print)
        if self.secondaryEncompassingEncounterId is not None:
            namespaceprefix_ = self.secondaryEncompassingEncounterId_nsprefix_ + ':' if (UseCapturedNS_ and self.secondaryEncompassingEncounterId_nsprefix_) else ''
            self.secondaryEncompassingEncounterId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='secondaryEncompassingEncounterId', pretty_print=pretty_print)
        if self.outsourcingServiceCustomer is not None:
            namespaceprefix_ = self.outsourcingServiceCustomer_nsprefix_ + ':' if (UseCapturedNS_ and self.outsourcingServiceCustomer_nsprefix_) else ''
            self.outsourcingServiceCustomer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='outsourcingServiceCustomer', pretty_print=pretty_print)
        if self.outsourcingServiceCustomerName is not None:
            namespaceprefix_ = self.outsourcingServiceCustomerName_nsprefix_ + ':' if (UseCapturedNS_ and self.outsourcingServiceCustomerName_nsprefix_) else ''
            self.outsourcingServiceCustomerName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='outsourcingServiceCustomerName', pretty_print=pretty_print)
        if self.retentionPeriodClass is not None:
            namespaceprefix_ = self.retentionPeriodClass_nsprefix_ + ':' if (UseCapturedNS_ and self.retentionPeriodClass_nsprefix_) else ''
            self.retentionPeriodClass.export(outfile, level, namespaceprefix_, namespacedef_='', name_='retentionPeriodClass', pretty_print=pretty_print)
        if self.extendedRetentionPeriod is not None:
            namespaceprefix_ = self.extendedRetentionPeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.extendedRetentionPeriod_nsprefix_) else ''
            self.extendedRetentionPeriod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extendedRetentionPeriod', pretty_print=pretty_print)
        if self.sensitiveDocument is not None:
            namespaceprefix_ = self.sensitiveDocument_nsprefix_ + ':' if (UseCapturedNS_ and self.sensitiveDocument_nsprefix_) else ''
            self.sensitiveDocument.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sensitiveDocument', pretty_print=pretty_print)
        if self.eprServiceProvider is not None:
            namespaceprefix_ = self.eprServiceProvider_nsprefix_ + ':' if (UseCapturedNS_ and self.eprServiceProvider_nsprefix_) else ''
            self.eprServiceProvider.export(outfile, level, namespaceprefix_, namespacedef_='', name_='eprServiceProvider', pretty_print=pretty_print)
        if self.eprServiceProviderName is not None:
            namespaceprefix_ = self.eprServiceProviderName_nsprefix_ + ':' if (UseCapturedNS_ and self.eprServiceProviderName_nsprefix_) else ''
            self.eprServiceProviderName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='eprServiceProviderName', pretty_print=pretty_print)
        if self.releaseDateForPatientViewing is not None:
            namespaceprefix_ = self.releaseDateForPatientViewing_nsprefix_ + ':' if (UseCapturedNS_ and self.releaseDateForPatientViewing_nsprefix_) else ''
            self.releaseDateForPatientViewing.export(outfile, level, namespaceprefix_, namespacedef_='', name_='releaseDateForPatientViewing', pretty_print=pretty_print)
        if self.patientHomeMunicipality is not None:
            namespaceprefix_ = self.patientHomeMunicipality_nsprefix_ + ':' if (UseCapturedNS_ and self.patientHomeMunicipality_nsprefix_) else ''
            self.patientHomeMunicipality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='patientHomeMunicipality', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'tableOfContents':
            obj_ = tableOfContents.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tableOfContents = obj_
            obj_.original_tagname_ = 'tableOfContents'
        elif nodeName_ == 'registratedTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.registratedTime = obj_
            obj_.original_tagname_ = 'registratedTime'
        elif nodeName_ == 'declaredTime':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.declaredTime = obj_
            obj_.original_tagname_ = 'declaredTime'
        elif nodeName_ == 'typeCode':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeCode = obj_
            obj_.original_tagname_ = 'typeCode'
        elif nodeName_ == 'fileFormat':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileFormat = obj_
            obj_.original_tagname_ = 'fileFormat'
        elif nodeName_ == 'softwareSupport':
            obj_ = softwareSupportType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.softwareSupport = obj_
            obj_.original_tagname_ = 'softwareSupport'
        elif nodeName_ == 'documentType':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.documentType = obj_
            obj_.original_tagname_ = 'documentType'
        elif nodeName_ == 'currentLocation':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currentLocation = obj_
            obj_.original_tagname_ = 'currentLocation'
        elif nodeName_ == 'retentionPeriod':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.retentionPeriod = obj_
            obj_.original_tagname_ = 'retentionPeriod'
        elif nodeName_ == 'functionCode':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.functionCode = obj_
            obj_.original_tagname_ = 'functionCode'
        elif nodeName_ == 'recordStatus':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recordStatus = obj_
            obj_.original_tagname_ = 'recordStatus'
        elif nodeName_ == 'auditTrail':
            obj_ = auditTrail.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.auditTrail.append(obj_)
            obj_.original_tagname_ = 'auditTrail'
        elif nodeName_ == 'serviceChainLink':
            obj_ = serviceChainLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceChainLink.append(obj_)
            obj_.original_tagname_ = 'serviceChainLink'
        elif nodeName_ == 'episodeLink':
            obj_ = episodeLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.episodeLink.append(obj_)
            obj_.original_tagname_ = 'episodeLink'
        elif nodeName_ == 'product':
            obj_ = product.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.product.append(obj_)
            obj_.original_tagname_ = 'product'
        elif nodeName_ == 'signatureCollection':
            obj_ = signatureCollection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signatureCollection = obj_
            obj_.original_tagname_ = 'signatureCollection'
        elif nodeName_ == 'sender':
            obj_ = sender.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sender = obj_
            obj_.original_tagname_ = 'sender'
        elif nodeName_ == 'password':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.password = obj_
            obj_.original_tagname_ = 'password'
        elif nodeName_ == 'patientRegistrySpecifier':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.patientRegistrySpecifier = obj_
            obj_.original_tagname_ = 'patientRegistrySpecifier'
        elif nodeName_ == 'patientRegistrySpecifierName':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.patientRegistrySpecifierName = obj_
            obj_.original_tagname_ = 'patientRegistrySpecifierName'
        elif nodeName_ == 'custodianTypeCode':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.custodianTypeCode = obj_
            obj_.original_tagname_ = 'custodianTypeCode'
        elif nodeName_ == 'encompassingEncounterCode':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encompassingEncounterCode = obj_
            obj_.original_tagname_ = 'encompassingEncounterCode'
        elif nodeName_ == 'activeCustodian':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activeCustodian = obj_
            obj_.original_tagname_ = 'activeCustodian'
        elif nodeName_ == 'activeCustodianName':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activeCustodianName = obj_
            obj_.original_tagname_ = 'activeCustodianName'
        elif nodeName_ == 'encompassingEncounterMasterCode':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.encompassingEncounterMasterCode = obj_
            obj_.original_tagname_ = 'encompassingEncounterMasterCode'
        elif nodeName_ == 'secondaryEncompassingEncounterId':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.secondaryEncompassingEncounterId = obj_
            obj_.original_tagname_ = 'secondaryEncompassingEncounterId'
        elif nodeName_ == 'outsourcingServiceCustomer':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.outsourcingServiceCustomer = obj_
            obj_.original_tagname_ = 'outsourcingServiceCustomer'
        elif nodeName_ == 'outsourcingServiceCustomerName':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.outsourcingServiceCustomerName = obj_
            obj_.original_tagname_ = 'outsourcingServiceCustomerName'
        elif nodeName_ == 'retentionPeriodClass':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.retentionPeriodClass = obj_
            obj_.original_tagname_ = 'retentionPeriodClass'
        elif nodeName_ == 'extendedRetentionPeriod':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extendedRetentionPeriod = obj_
            obj_.original_tagname_ = 'extendedRetentionPeriod'
        elif nodeName_ == 'sensitiveDocument':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sensitiveDocument = obj_
            obj_.original_tagname_ = 'sensitiveDocument'
        elif nodeName_ == 'eprServiceProvider':
            class_obj_ = self.get_class_obj_(child_, II)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.eprServiceProvider = obj_
            obj_.original_tagname_ = 'eprServiceProvider'
        elif nodeName_ == 'eprServiceProviderName':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.eprServiceProviderName = obj_
            obj_.original_tagname_ = 'eprServiceProviderName'
        elif nodeName_ == 'releaseDateForPatientViewing':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.releaseDateForPatientViewing = obj_
            obj_.original_tagname_ = 'releaseDateForPatientViewing'
        elif nodeName_ == 'patientHomeMunicipality':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.patientHomeMunicipality = obj_
            obj_.original_tagname_ = 'patientHomeMunicipality'
# end class localHeader


class signatureType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, signatureDescription=None, signatureTimestamp=None, multipleDocumentSignature=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.signatureDescription = signatureDescription
        self.signatureDescription_nsprefix_ = None
        self.signatureTimestamp = signatureTimestamp
        self.signatureTimestamp_nsprefix_ = None
        self.multipleDocumentSignature = multipleDocumentSignature
        self.multipleDocumentSignature_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signatureType.subclass:
            return signatureType.subclass(*args_, **kwargs_)
        else:
            return signatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_signatureDescription(self):
        return self.signatureDescription
    def set_signatureDescription(self, signatureDescription):
        self.signatureDescription = signatureDescription
    def get_signatureTimestamp(self):
        return self.signatureTimestamp
    def set_signatureTimestamp(self, signatureTimestamp):
        self.signatureTimestamp = signatureTimestamp
    def get_multipleDocumentSignature(self):
        return self.multipleDocumentSignature
    def set_multipleDocumentSignature(self, multipleDocumentSignature):
        self.multipleDocumentSignature = multipleDocumentSignature
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def hasContent_(self):
        if (
            self.signatureDescription is not None or
            self.signatureTimestamp is not None or
            self.multipleDocumentSignature is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3"  xmlns:None="urn:hl7-org:v3" ', name_='signatureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('signatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'signatureType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='signatureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='signatureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='signatureType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:hl7="urn:hl7-org:v3"  xmlns:None="urn:hl7-org:v3" ', name_='signatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.signatureDescription is not None:
            namespaceprefix_ = self.signatureDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.signatureDescription_nsprefix_) else ''
            self.signatureDescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signatureDescription', pretty_print=pretty_print)
        if self.signatureTimestamp is not None:
            namespaceprefix_ = self.signatureTimestamp_nsprefix_ + ':' if (UseCapturedNS_ and self.signatureTimestamp_nsprefix_) else ''
            self.signatureTimestamp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signatureTimestamp', pretty_print=pretty_print)
        if self.multipleDocumentSignature is not None:
            namespaceprefix_ = self.multipleDocumentSignature_nsprefix_ + ':' if (UseCapturedNS_ and self.multipleDocumentSignature_nsprefix_) else ''
            self.multipleDocumentSignature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multipleDocumentSignature', pretty_print=pretty_print)
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(obj_)
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'signatureDescription':
            class_obj_ = self.get_class_obj_(child_, CV)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signatureDescription = obj_
            obj_.original_tagname_ = 'signatureDescription'
        elif nodeName_ == 'signatureTimestamp':
            obj_ = signatureTimestampType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signatureTimestamp = obj_
            obj_.original_tagname_ = 'signatureTimestamp'
        elif nodeName_ == 'multipleDocumentSignature':
            obj_ = multipleDocumentSignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multipleDocumentSignature = obj_
            obj_.original_tagname_ = 'multipleDocumentSignature'
        else:
            content_ = self.gds_build_any(child_, 'signatureType')
            self.add_anytypeobjs_(content_)
# end class signatureType


class signatureTimestampType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signatureTimestampType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signatureTimestampType.subclass:
            return signatureTimestampType.subclass(*args_, **kwargs_)
        else:
            return signatureTimestampType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='signatureTimestampType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('signatureTimestampType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'signatureTimestampType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='signatureTimestampType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='signatureTimestampType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='signatureTimestampType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='signatureTimestampType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class signatureTimestampType


class multipleDocumentSignatureType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, Ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        if Ref is None:
            self.Ref = []
        else:
            self.Ref = Ref
        self.Ref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, multipleDocumentSignatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if multipleDocumentSignatureType.subclass:
            return multipleDocumentSignatureType.subclass(*args_, **kwargs_)
        else:
            return multipleDocumentSignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Ref(self):
        return self.Ref
    def set_Ref(self, Ref):
        self.Ref = Ref
    def add_Ref(self, value):
        self.Ref.append(value)
    def insert_Ref_at(self, index, value):
        self.Ref.insert(index, value)
    def replace_Ref_at(self, index, value):
        self.Ref[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def hasContent_(self):
        if (
            self.Ref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='multipleDocumentSignatureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('multipleDocumentSignatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'multipleDocumentSignatureType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='multipleDocumentSignatureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='multipleDocumentSignatureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='multipleDocumentSignatureType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:hl7-org:v3" ', name_='multipleDocumentSignatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Ref_ in self.Ref:
            namespaceprefix_ = self.Ref_nsprefix_ + ':' if (UseCapturedNS_ and self.Ref_nsprefix_) else ''
            Ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Ref', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Ref':
            obj_ = RefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Ref.append(obj_)
            obj_.original_tagname_ = 'Ref'
# end class multipleDocumentSignatureType


class RefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OID=None, hash=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OID = _cast(None, OID)
        self.OID_nsprefix_ = None
        self.hash = _cast(None, hash)
        self.hash_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefType.subclass:
            return RefType.subclass(*args_, **kwargs_)
        else:
            return RefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OID(self):
        return self.OID
    def set_OID(self, OID):
        self.OID = OID
    def get_hash(self):
        return self.hash
    def set_hash(self, hash):
        self.hash = hash
    def validate_oid(self, value):
        # Validate type hl7:oid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_oid_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_oid_patterns_, ))
    validate_oid_patterns_ = [['^([0-2](\\.(0|[1-9][0-9]*))*)$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RefType'):
        if self.OID is not None and 'OID' not in already_processed:
            already_processed.add('OID')
            outfile.write(' OID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OID), input_name='OID')), ))
        if self.hash is not None and 'hash' not in already_processed:
            already_processed.add('hash')
            outfile.write(' hash=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.hash), input_name='hash')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('OID', node)
        if value is not None and 'OID' not in already_processed:
            already_processed.add('OID')
            self.OID = value
            self.validate_oid(self.OID)    # validate type oid
        value = find_attr_value_('hash', node)
        if value is not None and 'hash' not in already_processed:
            already_processed.add('hash')
            self.hash = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RefType


class softwareSupportType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, moderator=None, product=None, version=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.moderator = _cast(None, moderator)
        self.moderator_nsprefix_ = None
        self.product = _cast(None, product)
        self.product_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, softwareSupportType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if softwareSupportType.subclass:
            return softwareSupportType.subclass(*args_, **kwargs_)
        else:
            return softwareSupportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_moderator(self):
        return self.moderator
    def set_moderator(self, moderator):
        self.moderator = moderator
    def get_product(self):
        return self.product
    def set_product(self, product):
        self.product = product
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='softwareSupportType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('softwareSupportType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'softwareSupportType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='softwareSupportType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='softwareSupportType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='softwareSupportType'):
        if self.moderator is not None and 'moderator' not in already_processed:
            already_processed.add('moderator')
            outfile.write(' moderator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.moderator), input_name='moderator')), ))
        if self.product is not None and 'product' not in already_processed:
            already_processed.add('product')
            outfile.write(' product=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.product), input_name='product')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='softwareSupportType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('moderator', node)
        if value is not None and 'moderator' not in already_processed:
            already_processed.add('moderator')
            self.moderator = value
        value = find_attr_value_('product', node)
        if value is not None and 'product' not in already_processed:
            already_processed.add('product')
            self.product = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class softwareSupportType


class RTO(RTO_QTY_QTY):
    """A quantity constructed as the quotient of a numerator
    quantity divided by a denominator quantity. Common
    factors in the numerator and denominator are not
    automatically cancelled out. RTO supports titers
    (e.g., "1:128") and other quantities produced by
    laboratories that truly represent ratios. Ratios are
    not simply "structured numerics", particularly blood
    pressure measurements (e.g. "120/60") are not ratios.
    In many cases REAL should be used instead
    of RTO."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RTO_QTY_QTY
    def __init__(self, nullFlavor=None, numerator=None, denominator=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RTO, self).__init__(nullFlavor, numerator, denominator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO.subclass:
            return RTO.subclass(*args_, **kwargs_)
        else:
            return RTO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(RTO, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RTO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RTO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RTO', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RTO'):
        super(RTO, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RTO', fromsubclass_=False, pretty_print=True):
        super(RTO, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RTO, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(RTO, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RTO


class TS(QTY):
    """A quantity specifying a point on the axis of natural time.
    A point in time is most often represented as a calendar
    expression."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, value=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TS, self).__init__(nullFlavor, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TS.subclass:
            return TS.subclass(*args_, **kwargs_)
        else:
            return TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ts(self, value):
        # Validate type ts, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_ts_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ts_patterns_, ))
    validate_ts_patterns_ = [['^([0-9]{1,8}|([0-9]{9,14}|[0-9]{14,14}\\.[0-9]+)([+\\-][0-9]{1,4})?)$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TS')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TS'):
        super(TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TS')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TS', fromsubclass_=False, pretty_print=True):
        super(TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_ts(self.value)    # validate type ts
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(TS, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TS


class UVP_TS(TS):
    """The probability assigned to the value, a decimal number
    between 0 (very uncertain) and 1 (certain)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor=None, value=None, probability=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(UVP_TS, self).__init__(nullFlavor, value,  **kwargs_)
        self.probability = _cast(float, probability)
        self.probability_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UVP_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UVP_TS.subclass:
            return UVP_TS.subclass(*args_, **kwargs_)
        else:
            return UVP_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_probability(self):
        return self.probability
    def set_probability(self, probability):
        self.probability = probability
    def validate_probability(self, value):
        # Validate type probability, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on probability' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on probability' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(UVP_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UVP_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UVP_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UVP_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UVP_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UVP_TS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UVP_TS'):
        super(UVP_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UVP_TS')
        if self.probability is not None and 'probability' not in already_processed:
            already_processed.add('probability')
            outfile.write(' probability="%s"' % self.gds_format_double(self.probability, input_name='probability'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UVP_TS', fromsubclass_=False, pretty_print=True):
        super(UVP_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('probability', node)
        if value is not None and 'probability' not in already_processed:
            already_processed.add('probability')
            value = self.gds_parse_double(value, node, 'probability')
            self.probability = value
            self.validate_probability(self.probability)    # validate type probability
        super(UVP_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(UVP_TS, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class UVP_TS


class RTO_MO_PQ(QTY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, numerator=None, denominator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RTO_MO_PQ, self).__init__(nullFlavor,  **kwargs_)
        self.numerator = numerator
        self.numerator_nsprefix_ = None
        self.denominator = denominator
        self.denominator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO_MO_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO_MO_PQ.subclass:
            return RTO_MO_PQ.subclass(*args_, **kwargs_)
        else:
            return RTO_MO_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numerator(self):
        return self.numerator
    def set_numerator(self, numerator):
        self.numerator = numerator
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def hasContent_(self):
        if (
            self.numerator is not None or
            self.denominator is not None or
            super(RTO_MO_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RTO_MO_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO_MO_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RTO_MO_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_MO_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RTO_MO_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RTO_MO_PQ'):
        super(RTO_MO_PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_MO_PQ')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RTO_MO_PQ', fromsubclass_=False, pretty_print=True):
        super(RTO_MO_PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numerator is not None:
            namespaceprefix_ = self.numerator_nsprefix_ + ':' if (UseCapturedNS_ and self.numerator_nsprefix_) else ''
            self.numerator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='numerator', pretty_print=pretty_print)
        if self.denominator is not None:
            namespaceprefix_ = self.denominator_nsprefix_ + ':' if (UseCapturedNS_ and self.denominator_nsprefix_) else ''
            self.denominator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='denominator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RTO_MO_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'numerator':
            class_obj_ = self.get_class_obj_(child_, MO)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.numerator = obj_
            obj_.original_tagname_ = 'numerator'
        elif nodeName_ == 'denominator':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.denominator = obj_
            obj_.original_tagname_ = 'denominator'
        super(RTO_MO_PQ, self).buildChildren(child_, node, nodeName_, True)
# end class RTO_MO_PQ


class RTO_PQ_PQ(QTY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, numerator=None, denominator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RTO_PQ_PQ, self).__init__(nullFlavor,  **kwargs_)
        self.numerator = numerator
        self.numerator_nsprefix_ = None
        self.denominator = denominator
        self.denominator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO_PQ_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO_PQ_PQ.subclass:
            return RTO_PQ_PQ.subclass(*args_, **kwargs_)
        else:
            return RTO_PQ_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_numerator(self):
        return self.numerator
    def set_numerator(self, numerator):
        self.numerator = numerator
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def hasContent_(self):
        if (
            self.numerator is not None or
            self.denominator is not None or
            super(RTO_PQ_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RTO_PQ_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO_PQ_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RTO_PQ_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_PQ_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RTO_PQ_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RTO_PQ_PQ'):
        super(RTO_PQ_PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTO_PQ_PQ')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RTO_PQ_PQ', fromsubclass_=False, pretty_print=True):
        super(RTO_PQ_PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numerator is not None:
            namespaceprefix_ = self.numerator_nsprefix_ + ':' if (UseCapturedNS_ and self.numerator_nsprefix_) else ''
            self.numerator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='numerator', pretty_print=pretty_print)
        if self.denominator is not None:
            namespaceprefix_ = self.denominator_nsprefix_ + ':' if (UseCapturedNS_ and self.denominator_nsprefix_) else ''
            self.denominator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='denominator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RTO_PQ_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'numerator':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.numerator = obj_
            obj_.original_tagname_ = 'numerator'
        elif nodeName_ == 'denominator':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.denominator = obj_
            obj_.original_tagname_ = 'denominator'
        super(RTO_PQ_PQ, self).buildChildren(child_, node, nodeName_, True)
# end class RTO_PQ_PQ


class GLIST_PQ(ANY):
    """If non-NULL, specifies that the sequence alternates,
    i.e., after this many increments, the sequence item
    values roll over to start from the initial sequence
    item value. For example, the sequence (1; 2; 3; 1; 2;
    3; 1; 2; 3; ...) has period 3; also the sequence
    (1; 1; 2; 2; 3; 3; 1; 1; 2; 2; 3; 3; ...) has period
    3 too.
    The integer by which the index for the sequence is
    divided, effectively the number of times the sequence
    generates the same sequence item value before
    incrementing to the next sequence item value. For
    example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
    3; ...) the denominator is 3."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, period=None, denominator=None, head=None, increment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GLIST_PQ, self).__init__(nullFlavor,  **kwargs_)
        self.period = _cast(int, period)
        self.period_nsprefix_ = None
        self.denominator = _cast(int, denominator)
        self.denominator_nsprefix_ = None
        self.head = head
        self.head_nsprefix_ = None
        self.increment = increment
        self.increment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GLIST_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GLIST_PQ.subclass:
            return GLIST_PQ.subclass(*args_, **kwargs_)
        else:
            return GLIST_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_head(self):
        return self.head
    def set_head(self, head):
        self.head = head
    def get_increment(self):
        return self.increment
    def set_increment(self, increment):
        self.increment = increment
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.head is not None or
            self.increment is not None or
            super(GLIST_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GLIST_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GLIST_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GLIST_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GLIST_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GLIST_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GLIST_PQ'):
        super(GLIST_PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GLIST_PQ')
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period="%s"' % self.gds_format_integer(self.period, input_name='period'))
        if self.denominator is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            outfile.write(' denominator="%s"' % self.gds_format_integer(self.denominator, input_name='denominator'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GLIST_PQ', fromsubclass_=False, pretty_print=True):
        super(GLIST_PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.head is not None:
            namespaceprefix_ = self.head_nsprefix_ + ':' if (UseCapturedNS_ and self.head_nsprefix_) else ''
            self.head.export(outfile, level, namespaceprefix_, namespacedef_='', name_='head', pretty_print=pretty_print)
        if self.increment is not None:
            namespaceprefix_ = self.increment_nsprefix_ + ':' if (UseCapturedNS_ and self.increment_nsprefix_) else ''
            self.increment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='increment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = self.gds_parse_integer(value, node, 'period')
            self.validate_int(self.period)    # validate type int
        value = find_attr_value_('denominator', node)
        if value is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            self.denominator = self.gds_parse_integer(value, node, 'denominator')
            self.validate_int(self.denominator)    # validate type int
        super(GLIST_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'head':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.head = obj_
            obj_.original_tagname_ = 'head'
        elif nodeName_ == 'increment':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.increment = obj_
            obj_.original_tagname_ = 'increment'
        super(GLIST_PQ, self).buildChildren(child_, node, nodeName_, True)
# end class GLIST_PQ


class GLIST_TS(ANY):
    """If non-NULL, specifies that the sequence alternates,
    i.e., after this many increments, the sequence item
    values roll over to start from the initial sequence
    item value. For example, the sequence (1; 2; 3; 1; 2;
    3; 1; 2; 3; ...) has period 3; also the sequence
    (1; 1; 2; 2; 3; 3; 1; 1; 2; 2; 3; 3; ...) has period
    3 too.
    The integer by which the index for the sequence is
    divided, effectively the number of times the sequence
    generates the same sequence item value before
    incrementing to the next sequence item value. For
    example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
    3; ...) the denominator is 3."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, period=None, denominator=None, head=None, increment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GLIST_TS, self).__init__(nullFlavor,  **kwargs_)
        self.period = _cast(int, period)
        self.period_nsprefix_ = None
        self.denominator = _cast(int, denominator)
        self.denominator_nsprefix_ = None
        self.head = head
        self.head_nsprefix_ = None
        self.increment = increment
        self.increment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GLIST_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GLIST_TS.subclass:
            return GLIST_TS.subclass(*args_, **kwargs_)
        else:
            return GLIST_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_head(self):
        return self.head
    def set_head(self, head):
        self.head = head
    def get_increment(self):
        return self.increment
    def set_increment(self, increment):
        self.increment = increment
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_denominator(self):
        return self.denominator
    def set_denominator(self, denominator):
        self.denominator = denominator
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.head is not None or
            self.increment is not None or
            super(GLIST_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GLIST_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GLIST_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GLIST_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GLIST_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GLIST_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GLIST_TS'):
        super(GLIST_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GLIST_TS')
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period="%s"' % self.gds_format_integer(self.period, input_name='period'))
        if self.denominator is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            outfile.write(' denominator="%s"' % self.gds_format_integer(self.denominator, input_name='denominator'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GLIST_TS', fromsubclass_=False, pretty_print=True):
        super(GLIST_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.head is not None:
            namespaceprefix_ = self.head_nsprefix_ + ':' if (UseCapturedNS_ and self.head_nsprefix_) else ''
            self.head.export(outfile, level, namespaceprefix_, namespacedef_='', name_='head', pretty_print=pretty_print)
        if self.increment is not None:
            namespaceprefix_ = self.increment_nsprefix_ + ':' if (UseCapturedNS_ and self.increment_nsprefix_) else ''
            self.increment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='increment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = self.gds_parse_integer(value, node, 'period')
            self.validate_int(self.period)    # validate type int
        value = find_attr_value_('denominator', node)
        if value is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            self.denominator = self.gds_parse_integer(value, node, 'denominator')
            self.validate_int(self.denominator)    # validate type int
        super(GLIST_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'head':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.head = obj_
            obj_.original_tagname_ = 'head'
        elif nodeName_ == 'increment':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.increment = obj_
            obj_.original_tagname_ = 'increment'
        super(GLIST_TS, self).buildChildren(child_, node, nodeName_, True)
# end class GLIST_TS


class SLIST_TS(ANY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, origin=None, scale=None, digits=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SLIST_TS, self).__init__(nullFlavor,  **kwargs_)
        self.origin = origin
        self.origin_nsprefix_ = None
        self.scale = scale
        self.scale_nsprefix_ = None
        self.digits = digits
        self.validate_list_int(self.digits)
        self.digits_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SLIST_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SLIST_TS.subclass:
            return SLIST_TS.subclass(*args_, **kwargs_)
        else:
            return SLIST_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_origin(self):
        return self.origin
    def set_origin(self, origin):
        self.origin = origin
    def get_scale(self):
        return self.scale
    def set_scale(self, scale):
        self.scale = scale
    def get_digits(self):
        return self.digits
    def set_digits(self, digits):
        self.digits = digits
    def validate_list_int(self, value):
        result = True
        # Validate type list_int, a restriction on int.
        pass
        return result
    def hasContent_(self):
        if (
            self.origin is not None or
            self.scale is not None or
            self.digits is not None or
            super(SLIST_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SLIST_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SLIST_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SLIST_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SLIST_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SLIST_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SLIST_TS'):
        super(SLIST_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SLIST_TS')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SLIST_TS', fromsubclass_=False, pretty_print=True):
        super(SLIST_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            namespaceprefix_ = self.origin_nsprefix_ + ':' if (UseCapturedNS_ and self.origin_nsprefix_) else ''
            self.origin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='origin', pretty_print=pretty_print)
        if self.scale is not None:
            namespaceprefix_ = self.scale_nsprefix_ + ':' if (UseCapturedNS_ and self.scale_nsprefix_) else ''
            self.scale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scale', pretty_print=pretty_print)
        if self.digits is not None:
            namespaceprefix_ = self.digits_nsprefix_ + ':' if (UseCapturedNS_ and self.digits_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdigits>%s</%sdigits>%s' % (namespaceprefix_ , self.gds_format_integer_list(self.digits, input_name='digits'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SLIST_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'origin':
            class_obj_ = self.get_class_obj_(child_, TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.origin = obj_
            obj_.original_tagname_ = 'origin'
        elif nodeName_ == 'scale':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scale = obj_
            obj_.original_tagname_ = 'scale'
        elif nodeName_ == 'digits':
            value_ = child_.text
            value_ = self.gds_validate_integer_list(value_, node, 'digits')
            self.digits = value_
            self.digits_nsprefix_ = child_.prefix
            # validate type list_int
            self.validate_list_int(self.digits)
        super(SLIST_TS, self).buildChildren(child_, node, nodeName_, True)
# end class SLIST_TS


class SLIST_PQ(ANY):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, origin=None, scale=None, digits=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SLIST_PQ, self).__init__(nullFlavor,  **kwargs_)
        self.origin = origin
        self.origin_nsprefix_ = None
        self.scale = scale
        self.scale_nsprefix_ = None
        self.digits = digits
        self.validate_list_int(self.digits)
        self.digits_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SLIST_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SLIST_PQ.subclass:
            return SLIST_PQ.subclass(*args_, **kwargs_)
        else:
            return SLIST_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_origin(self):
        return self.origin
    def set_origin(self, origin):
        self.origin = origin
    def get_scale(self):
        return self.scale
    def set_scale(self, scale):
        self.scale = scale
    def get_digits(self):
        return self.digits
    def set_digits(self, digits):
        self.digits = digits
    def validate_list_int(self, value):
        result = True
        # Validate type list_int, a restriction on int.
        pass
        return result
    def hasContent_(self):
        if (
            self.origin is not None or
            self.scale is not None or
            self.digits is not None or
            super(SLIST_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SLIST_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SLIST_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SLIST_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SLIST_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SLIST_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SLIST_PQ'):
        super(SLIST_PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SLIST_PQ')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SLIST_PQ', fromsubclass_=False, pretty_print=True):
        super(SLIST_PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            namespaceprefix_ = self.origin_nsprefix_ + ':' if (UseCapturedNS_ and self.origin_nsprefix_) else ''
            self.origin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='origin', pretty_print=pretty_print)
        if self.scale is not None:
            namespaceprefix_ = self.scale_nsprefix_ + ':' if (UseCapturedNS_ and self.scale_nsprefix_) else ''
            self.scale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scale', pretty_print=pretty_print)
        if self.digits is not None:
            namespaceprefix_ = self.digits_nsprefix_ + ':' if (UseCapturedNS_ and self.digits_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdigits>%s</%sdigits>%s' % (namespaceprefix_ , self.gds_format_integer_list(self.digits, input_name='digits'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SLIST_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'origin':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.origin = obj_
            obj_.original_tagname_ = 'origin'
        elif nodeName_ == 'scale':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scale = obj_
            obj_.original_tagname_ = 'scale'
        elif nodeName_ == 'digits':
            value_ = child_.text
            value_ = self.gds_validate_integer_list(value_, node, 'digits')
            self.digits = value_
            self.digits_nsprefix_ = child_.prefix
            # validate type list_int
            self.validate_list_int(self.digits)
        super(SLIST_PQ, self).buildChildren(child_, node, nodeName_, True)
# end class SLIST_PQ


class BXIT_CD(CD):
    """The quantity in which the bag item occurs in its containing bag."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CD
    def __init__(self, nullFlavor=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, translation=None, qty='1', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BXIT_CD, self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation,  **kwargs_)
        self.qty = _cast(int, qty)
        self.qty_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BXIT_CD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BXIT_CD.subclass:
            return BXIT_CD.subclass(*args_, **kwargs_)
        else:
            return BXIT_CD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_qty(self):
        return self.qty
    def set_qty(self, qty):
        self.qty = qty
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            super(BXIT_CD, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BXIT_CD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BXIT_CD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BXIT_CD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BXIT_CD')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BXIT_CD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BXIT_CD'):
        super(BXIT_CD, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BXIT_CD')
        if self.qty != 1 and 'qty' not in already_processed:
            already_processed.add('qty')
            outfile.write(' qty="%s"' % self.gds_format_integer(self.qty, input_name='qty'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BXIT_CD', fromsubclass_=False, pretty_print=True):
        super(BXIT_CD, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qty', node)
        if value is not None and 'qty' not in already_processed:
            already_processed.add('qty')
            self.qty = self.gds_parse_integer(value, node, 'qty')
            self.validate_int(self.qty)    # validate type int
        super(BXIT_CD, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BXIT_CD, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BXIT_CD


class HXIT_CE(CE):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CE
    def __init__(self, nullFlavor=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, translation=None, validTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(HXIT_CE, self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation,  **kwargs_)
        self.validTime = validTime
        self.validTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HXIT_CE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HXIT_CE.subclass:
            return HXIT_CE.subclass(*args_, **kwargs_)
        else:
            return HXIT_CE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def hasContent_(self):
        if (
            self.validTime is not None or
            super(HXIT_CE, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HXIT_CE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HXIT_CE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HXIT_CE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HXIT_CE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HXIT_CE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HXIT_CE'):
        super(HXIT_CE, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HXIT_CE')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HXIT_CE', fromsubclass_=False, pretty_print=True):
        super(HXIT_CE, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HXIT_CE, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validTime = obj_
            obj_.original_tagname_ = 'validTime'
        super(HXIT_CE, self).buildChildren(child_, node, nodeName_, True)
# end class HXIT_CE


class HXIT_PQ(PQ):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PQ
    def __init__(self, nullFlavor=None, value=None, unit='1', translation=None, validTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(HXIT_PQ, self).__init__(nullFlavor, value, unit, translation,  **kwargs_)
        self.validTime = validTime
        self.validTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HXIT_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HXIT_PQ.subclass:
            return HXIT_PQ.subclass(*args_, **kwargs_)
        else:
            return HXIT_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validTime(self):
        return self.validTime
    def set_validTime(self, validTime):
        self.validTime = validTime
    def hasContent_(self):
        if (
            self.validTime is not None or
            super(HXIT_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HXIT_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HXIT_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HXIT_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HXIT_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HXIT_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HXIT_PQ'):
        super(HXIT_PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HXIT_PQ')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HXIT_PQ', fromsubclass_=False, pretty_print=True):
        super(HXIT_PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.validTime is not None:
            namespaceprefix_ = self.validTime_nsprefix_ + ':' if (UseCapturedNS_ and self.validTime_nsprefix_) else ''
            self.validTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HXIT_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validTime':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validTime = obj_
            obj_.original_tagname_ = 'validTime'
        super(HXIT_PQ, self).buildChildren(child_, node, nodeName_, True)
# end class HXIT_PQ


class IVXB_MO(MO):
    """Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MO
    def __init__(self, nullFlavor=None, value=None, currency=None, inclusive='true', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVXB_MO, self).__init__(nullFlavor, value, currency,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_MO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_MO.subclass:
            return IVXB_MO.subclass(*args_, **kwargs_)
        else:
            return IVXB_MO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            super(IVXB_MO, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_MO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_MO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_MO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_MO')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVXB_MO', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_MO'):
        super(IVXB_MO, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_MO')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_MO', fromsubclass_=False, pretty_print=True):
        super(IVXB_MO, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_MO, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IVXB_MO, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_MO


class IVXB_REAL(REAL):
    """Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = REAL
    def __init__(self, nullFlavor=None, value=None, inclusive='true', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVXB_REAL, self).__init__(nullFlavor, value,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_REAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_REAL.subclass:
            return IVXB_REAL.subclass(*args_, **kwargs_)
        else:
            return IVXB_REAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            super(IVXB_REAL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_REAL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_REAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_REAL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_REAL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVXB_REAL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_REAL'):
        super(IVXB_REAL, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_REAL')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_REAL', fromsubclass_=False, pretty_print=True):
        super(IVXB_REAL, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_REAL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IVXB_REAL, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_REAL


class IVXB_INT(INT):
    """Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = INT
    def __init__(self, nullFlavor=None, value=None, inclusive='true', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVXB_INT, self).__init__(nullFlavor, value,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_INT.subclass:
            return IVXB_INT.subclass(*args_, **kwargs_)
        else:
            return IVXB_INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            super(IVXB_INT, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_INT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_INT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_INT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVXB_INT', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_INT'):
        super(IVXB_INT, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_INT')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_INT', fromsubclass_=False, pretty_print=True):
        super(IVXB_INT, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_INT, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IVXB_INT, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_INT


class SXCM_REAL(REAL):
    """A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = REAL
    def __init__(self, nullFlavor=None, value=None, operator='I', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SXCM_REAL, self).__init__(nullFlavor, value, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_REAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_REAL.subclass:
            return SXCM_REAL.subclass(*args_, **kwargs_)
        else:
            return SXCM_REAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            super(SXCM_REAL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_REAL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_REAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_REAL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_REAL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_REAL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_REAL'):
        super(SXCM_REAL, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_REAL')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_REAL', fromsubclass_=False, pretty_print=True):
        super(SXCM_REAL, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_REAL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_REAL, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_REAL


class SXCM_INT(INT):
    """A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = INT
    def __init__(self, nullFlavor=None, value=None, operator='I', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SXCM_INT, self).__init__(nullFlavor, value, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_INT.subclass:
            return SXCM_INT.subclass(*args_, **kwargs_)
        else:
            return SXCM_INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            super(SXCM_INT, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_INT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_INT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_INT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_INT', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_INT'):
        super(SXCM_INT, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_INT')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_INT', fromsubclass_=False, pretty_print=True):
        super(SXCM_INT, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_INT, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_INT, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_INT


class SXCM_MO(MO):
    """A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MO
    def __init__(self, nullFlavor=None, value=None, currency=None, operator='I', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SXCM_MO, self).__init__(nullFlavor, value, currency, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_MO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_MO.subclass:
            return SXCM_MO.subclass(*args_, **kwargs_)
        else:
            return SXCM_MO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            super(SXCM_MO, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_MO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_MO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_MO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_MO')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_MO', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_MO'):
        super(SXCM_MO, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_MO')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_MO', fromsubclass_=False, pretty_print=True):
        super(SXCM_MO, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_MO, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_MO, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_MO


class SXCM_CD(CD):
    """A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CD
    def __init__(self, nullFlavor=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, translation=None, operator='I', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SXCM_CD, self).__init__(nullFlavor, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, translation,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_CD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_CD.subclass:
            return SXCM_CD.subclass(*args_, **kwargs_)
        else:
            return SXCM_CD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            super(SXCM_CD, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_CD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_CD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_CD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_CD')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_CD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_CD'):
        super(SXCM_CD, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_CD')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_CD', fromsubclass_=False, pretty_print=True):
        super(SXCM_CD, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        super(SXCM_CD, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_CD, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_CD


class PPD_PQ(PQ):
    """A code specifying the type of probability distribution.
    Possible values are as shown in the attached table.
    The NULL value (unknown) for the type code indicates
    that the probability distribution type is unknown. In
    that case, the standard deviation has the meaning of an
    informal guess."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PQ
    def __init__(self, nullFlavor=None, value=None, unit='1', translation=None, distributionType=None, standardDeviation=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PPD_PQ, self).__init__(nullFlavor, value, unit, translation, extensiontype_,  **kwargs_)
        self.distributionType = _cast(None, distributionType)
        self.distributionType_nsprefix_ = None
        self.standardDeviation = standardDeviation
        self.standardDeviation_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PPD_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PPD_PQ.subclass:
            return PPD_PQ.subclass(*args_, **kwargs_)
        else:
            return PPD_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_standardDeviation(self):
        return self.standardDeviation
    def set_standardDeviation(self, standardDeviation):
        self.standardDeviation = standardDeviation
    def get_distributionType(self):
        return self.distributionType
    def set_distributionType(self, distributionType):
        self.distributionType = distributionType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ProbabilityDistributionType(self, value):
        # Validate type ProbabilityDistributionType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B', 'E', 'F', 'G', 'LN', 'N', 'T', 'U', 'X2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ProbabilityDistributionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ProbabilityDistributionType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ProbabilityDistributionType_patterns_, ))
    validate_ProbabilityDistributionType_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.standardDeviation is not None or
            super(PPD_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PPD_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PPD_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PPD_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPD_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PPD_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PPD_PQ'):
        super(PPD_PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPD_PQ')
        if self.distributionType is not None and 'distributionType' not in already_processed:
            already_processed.add('distributionType')
            outfile.write(' distributionType=%s' % (quote_attrib(self.distributionType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PPD_PQ', fromsubclass_=False, pretty_print=True):
        super(PPD_PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardDeviation is not None:
            namespaceprefix_ = self.standardDeviation_nsprefix_ + ':' if (UseCapturedNS_ and self.standardDeviation_nsprefix_) else ''
            self.standardDeviation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='standardDeviation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distributionType', node)
        if value is not None and 'distributionType' not in already_processed:
            already_processed.add('distributionType')
            self.distributionType = value
            self.distributionType = ' '.join(self.distributionType.split())
            self.validate_ProbabilityDistributionType(self.distributionType)    # validate type ProbabilityDistributionType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PPD_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'standardDeviation':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.standardDeviation = obj_
            obj_.original_tagname_ = 'standardDeviation'
        super(PPD_PQ, self).buildChildren(child_, node, nodeName_, True)
# end class PPD_PQ


class PPD_TS(TS):
    """A code specifying the type of probability distribution.
    Possible values are as shown in the attached table.
    The NULL value (unknown) for the type code indicates
    that the probability distribution type is unknown. In
    that case, the standard deviation has the meaning of an
    informal guess."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor=None, value=None, distributionType=None, standardDeviation=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PPD_TS, self).__init__(nullFlavor, value, extensiontype_,  **kwargs_)
        self.distributionType = _cast(None, distributionType)
        self.distributionType_nsprefix_ = None
        self.standardDeviation = standardDeviation
        self.standardDeviation_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PPD_TS.subclass:
            return PPD_TS.subclass(*args_, **kwargs_)
        else:
            return PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_standardDeviation(self):
        return self.standardDeviation
    def set_standardDeviation(self, standardDeviation):
        self.standardDeviation = standardDeviation
    def get_distributionType(self):
        return self.distributionType
    def set_distributionType(self, distributionType):
        self.distributionType = distributionType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ProbabilityDistributionType(self, value):
        # Validate type ProbabilityDistributionType, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B', 'E', 'F', 'G', 'LN', 'N', 'T', 'U', 'X2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ProbabilityDistributionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ProbabilityDistributionType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ProbabilityDistributionType_patterns_, ))
    validate_ProbabilityDistributionType_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            self.standardDeviation is not None or
            super(PPD_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPD_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PPD_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PPD_TS'):
        super(PPD_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPD_TS')
        if self.distributionType is not None and 'distributionType' not in already_processed:
            already_processed.add('distributionType')
            outfile.write(' distributionType=%s' % (quote_attrib(self.distributionType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PPD_TS', fromsubclass_=False, pretty_print=True):
        super(PPD_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standardDeviation is not None:
            namespaceprefix_ = self.standardDeviation_nsprefix_ + ':' if (UseCapturedNS_ and self.standardDeviation_nsprefix_) else ''
            self.standardDeviation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='standardDeviation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distributionType', node)
        if value is not None and 'distributionType' not in already_processed:
            already_processed.add('distributionType')
            self.distributionType = value
            self.distributionType = ' '.join(self.distributionType.split())
            self.validate_ProbabilityDistributionType(self.distributionType)    # validate type ProbabilityDistributionType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PPD_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'standardDeviation':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.standardDeviation = obj_
            obj_.original_tagname_ = 'standardDeviation'
        super(PPD_TS, self).buildChildren(child_, node, nodeName_, True)
# end class PPD_TS


class IVXB_PQ(PQ):
    """Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PQ
    def __init__(self, nullFlavor=None, value=None, unit='1', translation=None, inclusive='true', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVXB_PQ, self).__init__(nullFlavor, value, unit, translation,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_PQ.subclass:
            return IVXB_PQ.subclass(*args_, **kwargs_)
        else:
            return IVXB_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            super(IVXB_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVXB_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_PQ'):
        super(IVXB_PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PQ')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PQ', fromsubclass_=False, pretty_print=True):
        super(IVXB_PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IVXB_PQ, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_PQ


class SXCM_PQ(PQ):
    """A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PQ
    def __init__(self, nullFlavor=None, value=None, unit='1', translation=None, operator='I', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SXCM_PQ, self).__init__(nullFlavor, value, unit, translation, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_PQ.subclass:
            return SXCM_PQ.subclass(*args_, **kwargs_)
        else:
            return SXCM_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            super(SXCM_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_PQ'):
        super(SXCM_PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PQ')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PQ', fromsubclass_=False, pretty_print=True):
        super(SXCM_PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_PQ, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_PQ


class IVL_PQ(SXCM_PQ):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PQ
    def __init__(self, nullFlavor=None, value=None, unit='1', translation=None, operator='I', low=None, high=None, width=None, center=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVL_PQ, self).__init__(nullFlavor, value, unit, translation, operator, extensiontype_,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_PQ.subclass:
            return IVL_PQ.subclass(*args_, **kwargs_)
        else:
            return IVL_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            super(IVL_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVL_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_PQ'):
        super(IVL_PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PQ')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_PQ', fromsubclass_=False, pretty_print=True):
        super(IVL_PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IVL_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = IVXB_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'high':
            obj_ = IVXB_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        super(IVL_PQ, self).buildChildren(child_, node, nodeName_, True)
# end class IVL_PQ


class POCD_MT000040_RegionOfInterest_value(INT):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = INT
    def __init__(self, nullFlavor=None, value=None, unsorted=False, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(POCD_MT000040_RegionOfInterest_value, self).__init__(nullFlavor, value,  **kwargs_)
        self.unsorted = _cast(bool, unsorted)
        self.unsorted_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_RegionOfInterest_value)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_RegionOfInterest_value.subclass:
            return POCD_MT000040_RegionOfInterest_value.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_RegionOfInterest_value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unsorted(self):
        return self.unsorted
    def set_unsorted(self, unsorted):
        self.unsorted = unsorted
    def hasContent_(self):
        if (
            super(POCD_MT000040_RegionOfInterest_value, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040.RegionOfInterest.value', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.RegionOfInterest.value')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.RegionOfInterest.value':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RegionOfInterest.value')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.RegionOfInterest.value', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.RegionOfInterest.value'):
        super(POCD_MT000040_RegionOfInterest_value, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.RegionOfInterest.value')
        if self.unsorted and 'unsorted' not in already_processed:
            already_processed.add('unsorted')
            outfile.write(' unsorted="%s"' % self.gds_format_boolean(self.unsorted, input_name='unsorted'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040.RegionOfInterest.value', fromsubclass_=False, pretty_print=True):
        super(POCD_MT000040_RegionOfInterest_value, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unsorted', node)
        if value is not None and 'unsorted' not in already_processed:
            already_processed.add('unsorted')
            if value in ('true', '1'):
                self.unsorted = True
            elif value in ('false', '0'):
                self.unsorted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(POCD_MT000040_RegionOfInterest_value, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(POCD_MT000040_RegionOfInterest_value, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class POCD_MT000040_RegionOfInterest_value


class POCD_MT000040_InfrastructureRoot_templateId(II):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = II
    def __init__(self, nullFlavor=None, root=None, extension=None, assigningAuthorityName=None, displayable=None, unsorted=False, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(POCD_MT000040_InfrastructureRoot_templateId, self).__init__(nullFlavor, root, extension, assigningAuthorityName, displayable,  **kwargs_)
        self.unsorted = _cast(bool, unsorted)
        self.unsorted_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_InfrastructureRoot_templateId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_InfrastructureRoot_templateId.subclass:
            return POCD_MT000040_InfrastructureRoot_templateId.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_InfrastructureRoot_templateId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unsorted(self):
        return self.unsorted
    def set_unsorted(self, unsorted):
        self.unsorted = unsorted
    def hasContent_(self):
        if (
            super(POCD_MT000040_InfrastructureRoot_templateId, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040.InfrastructureRoot.templateId', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.InfrastructureRoot.templateId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.InfrastructureRoot.templateId':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.InfrastructureRoot.templateId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.InfrastructureRoot.templateId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.InfrastructureRoot.templateId'):
        super(POCD_MT000040_InfrastructureRoot_templateId, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.InfrastructureRoot.templateId')
        if self.unsorted and 'unsorted' not in already_processed:
            already_processed.add('unsorted')
            outfile.write(' unsorted="%s"' % self.gds_format_boolean(self.unsorted, input_name='unsorted'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040.InfrastructureRoot.templateId', fromsubclass_=False, pretty_print=True):
        super(POCD_MT000040_InfrastructureRoot_templateId, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unsorted', node)
        if value is not None and 'unsorted' not in already_processed:
            already_processed.add('unsorted')
            if value in ('true', '1'):
                self.unsorted = True
            elif value in ('false', '0'):
                self.unsorted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(POCD_MT000040_InfrastructureRoot_templateId, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(POCD_MT000040_InfrastructureRoot_templateId, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class POCD_MT000040_InfrastructureRoot_templateId


class POCD_MT000040_InfrastructureRoot_typeId(II):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = II
    def __init__(self, nullFlavor=None, root=None, extension=None, assigningAuthorityName=None, displayable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(POCD_MT000040_InfrastructureRoot_typeId, self).__init__(nullFlavor, root, extension, assigningAuthorityName, displayable,  **kwargs_)
        self.root = _cast(None, root)
        self.root_nsprefix_ = None
        self.extension = _cast(None, extension)
        self.extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POCD_MT000040_InfrastructureRoot_typeId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POCD_MT000040_InfrastructureRoot_typeId.subclass:
            return POCD_MT000040_InfrastructureRoot_typeId.subclass(*args_, **kwargs_)
        else:
            return POCD_MT000040_InfrastructureRoot_typeId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_root(self):
        return self.root
    def set_root(self, root):
        self.root = root
    def get_extension(self):
        return self.extension
    def set_extension(self, extension):
        self.extension = extension
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on st' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(POCD_MT000040_InfrastructureRoot_typeId, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040.InfrastructureRoot.typeId', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POCD_MT000040.InfrastructureRoot.typeId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POCD_MT000040.InfrastructureRoot.typeId':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.InfrastructureRoot.typeId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POCD_MT000040.InfrastructureRoot.typeId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POCD_MT000040.InfrastructureRoot.typeId'):
        super(POCD_MT000040_InfrastructureRoot_typeId, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POCD_MT000040.InfrastructureRoot.typeId')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.extension), input_name='extension')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POCD_MT000040.InfrastructureRoot.typeId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_uid(self.root)    # validate type uid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        super(POCD_MT000040_InfrastructureRoot_typeId, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class POCD_MT000040_InfrastructureRoot_typeId


class IVXB_TS(TS):
    """Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor=None, value=None, inclusive='true', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVXB_TS, self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_TS.subclass:
            return IVXB_TS.subclass(*args_, **kwargs_)
        else:
            return IVXB_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVXB_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_TS')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_TS'):
        super(IVXB_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_TS')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_TS', fromsubclass_=False, pretty_print=True):
        super(IVXB_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVXB_TS, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_TS


class SXCM_TS(TS):
    """A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor=None, value=None, operator='I', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SXCM_TS, self).__init__(nullFlavor, value, valueOf_, mixedclass_, content_, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_TS.subclass:
            return SXCM_TS.subclass(*args_, **kwargs_)
        else:
            return SXCM_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(SXCM_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_TS')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_TS'):
        super(SXCM_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_TS')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_TS', fromsubclass_=False, pretty_print=True):
        super(SXCM_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SXCM_TS, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_TS


class BXIT_IVL_PQ(IVL_PQ):
    """The quantity in which the bag item occurs in its containing bag."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IVL_PQ
    def __init__(self, nullFlavor=None, value=None, unit='1', translation=None, operator='I', low=None, high=None, width=None, center=None, qty='1', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BXIT_IVL_PQ, self).__init__(nullFlavor, value, unit, translation, operator, low, high, width, center,  **kwargs_)
        self.qty = _cast(int, qty)
        self.qty_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BXIT_IVL_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BXIT_IVL_PQ.subclass:
            return BXIT_IVL_PQ.subclass(*args_, **kwargs_)
        else:
            return BXIT_IVL_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_qty(self):
        return self.qty
    def set_qty(self, qty):
        self.qty = qty
    def validate_int(self, value):
        # Validate type int, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            super(BXIT_IVL_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BXIT_IVL_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BXIT_IVL_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BXIT_IVL_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BXIT_IVL_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BXIT_IVL_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BXIT_IVL_PQ'):
        super(BXIT_IVL_PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BXIT_IVL_PQ')
        if self.qty != 1 and 'qty' not in already_processed:
            already_processed.add('qty')
            outfile.write(' qty="%s"' % self.gds_format_integer(self.qty, input_name='qty'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BXIT_IVL_PQ', fromsubclass_=False, pretty_print=True):
        super(BXIT_IVL_PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qty', node)
        if value is not None and 'qty' not in already_processed:
            already_processed.add('qty')
            self.qty = self.gds_parse_integer(value, node, 'qty')
            self.validate_int(self.qty)    # validate type int
        super(BXIT_IVL_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BXIT_IVL_PQ, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BXIT_IVL_PQ


class IVL_MO(SXCM_MO):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_MO
    def __init__(self, nullFlavor=None, value=None, currency=None, operator='I', low=None, high=None, width=None, center=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVL_MO, self).__init__(nullFlavor, value, currency, operator,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_MO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_MO.subclass:
            return IVL_MO.subclass(*args_, **kwargs_)
        else:
            return IVL_MO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def hasContent_(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            super(IVL_MO, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_MO', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_MO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_MO':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_MO')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVL_MO', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_MO'):
        super(IVL_MO, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_MO')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_MO', fromsubclass_=False, pretty_print=True):
        super(IVL_MO, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IVL_MO, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_MO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = IVXB_MO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, MO)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'high':
            obj_ = IVXB_MO.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, MO)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, MO)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        super(IVL_MO, self).buildChildren(child_, node, nodeName_, True)
# end class IVL_MO


class IVL_REAL(SXCM_REAL):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_REAL
    def __init__(self, nullFlavor=None, value=None, operator='I', low=None, high=None, width=None, center=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVL_REAL, self).__init__(nullFlavor, value, operator,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_REAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_REAL.subclass:
            return IVL_REAL.subclass(*args_, **kwargs_)
        else:
            return IVL_REAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def hasContent_(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            super(IVL_REAL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_REAL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_REAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_REAL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_REAL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVL_REAL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_REAL'):
        super(IVL_REAL, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_REAL')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_REAL', fromsubclass_=False, pretty_print=True):
        super(IVL_REAL, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IVL_REAL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_REAL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = IVXB_REAL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, REAL)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'high':
            obj_ = IVXB_REAL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, REAL)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, REAL)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        super(IVL_REAL, self).buildChildren(child_, node, nodeName_, True)
# end class IVL_REAL


class IVL_INT(SXCM_INT):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_INT
    def __init__(self, nullFlavor=None, value=None, operator='I', low=None, high=None, width=None, center=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVL_INT, self).__init__(nullFlavor, value, operator,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_INT.subclass:
            return IVL_INT.subclass(*args_, **kwargs_)
        else:
            return IVL_INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def hasContent_(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            super(IVL_INT, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_INT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_INT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_INT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVL_INT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_INT'):
        super(IVL_INT, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_INT')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_INT', fromsubclass_=False, pretty_print=True):
        super(IVL_INT, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IVL_INT, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = IVXB_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'high':
            obj_ = IVXB_INT.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, INT)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        super(IVL_INT, self).buildChildren(child_, node, nodeName_, True)
# end class IVL_INT


class SXPR_TS(SXCM_TS):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor=None, value=None, operator='I', comp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SXPR_TS, self).__init__(nullFlavor, value, operator,  **kwargs_)
        if comp is None:
            self.comp = []
        else:
            self.comp = comp
        self.comp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXPR_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXPR_TS.subclass:
            return SXPR_TS.subclass(*args_, **kwargs_)
        else:
            return SXPR_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_comp(self):
        return self.comp
    def set_comp(self, comp):
        self.comp = comp
    def add_comp(self, value):
        self.comp.append(value)
    def insert_comp_at(self, index, value):
        self.comp.insert(index, value)
    def replace_comp_at(self, index, value):
        self.comp[index] = value
    def hasContent_(self):
        if (
            self.comp or
            super(SXPR_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXPR_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXPR_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXPR_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXPR_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXPR_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXPR_TS'):
        super(SXPR_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXPR_TS')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXPR_TS', fromsubclass_=False, pretty_print=True):
        super(SXPR_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for comp_ in self.comp:
            namespaceprefix_ = self.comp_nsprefix_ + ':' if (UseCapturedNS_ and self.comp_nsprefix_) else ''
            comp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='comp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SXPR_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'comp':
            class_obj_ = self.get_class_obj_(child_, SXCM_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.comp.append(obj_)
            obj_.original_tagname_ = 'comp'
        super(SXPR_TS, self).buildChildren(child_, node, nodeName_, True)
# end class SXPR_TS


class IVXB_PPD_PQ(PPD_PQ):
    """Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PPD_PQ
    def __init__(self, nullFlavor=None, value=None, unit='1', translation=None, distributionType=None, standardDeviation=None, inclusive='true', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVXB_PPD_PQ, self).__init__(nullFlavor, value, unit, translation, distributionType, standardDeviation,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_PPD_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_PPD_PQ.subclass:
            return IVXB_PPD_PQ.subclass(*args_, **kwargs_)
        else:
            return IVXB_PPD_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            super(IVXB_PPD_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PPD_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_PPD_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_PPD_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PPD_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVXB_PPD_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_PPD_PQ'):
        super(IVXB_PPD_PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PPD_PQ')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PPD_PQ', fromsubclass_=False, pretty_print=True):
        super(IVXB_PPD_PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_PPD_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IVXB_PPD_PQ, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_PPD_PQ


class SXCM_PPD_PQ(PPD_PQ):
    """A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PPD_PQ
    def __init__(self, nullFlavor=None, value=None, unit='1', translation=None, distributionType=None, standardDeviation=None, operator='I', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SXCM_PPD_PQ, self).__init__(nullFlavor, value, unit, translation, distributionType, standardDeviation, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_PPD_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_PPD_PQ.subclass:
            return SXCM_PPD_PQ.subclass(*args_, **kwargs_)
        else:
            return SXCM_PPD_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            super(SXCM_PPD_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PPD_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_PPD_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_PPD_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PPD_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_PPD_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_PPD_PQ'):
        super(SXCM_PPD_PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PPD_PQ')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PPD_PQ', fromsubclass_=False, pretty_print=True):
        super(SXCM_PPD_PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_PPD_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_PPD_PQ, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_PPD_PQ


class IVL_PPD_PQ(SXCM_PPD_PQ):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PPD_PQ
    def __init__(self, nullFlavor=None, value=None, unit='1', translation=None, distributionType=None, standardDeviation=None, operator='I', low=None, high=None, width=None, center=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVL_PPD_PQ, self).__init__(nullFlavor, value, unit, translation, distributionType, standardDeviation, operator,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_PPD_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_PPD_PQ.subclass:
            return IVL_PPD_PQ.subclass(*args_, **kwargs_)
        else:
            return IVL_PPD_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def hasContent_(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            super(IVL_PPD_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_PPD_PQ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_PPD_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_PPD_PQ':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PPD_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVL_PPD_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_PPD_PQ'):
        super(IVL_PPD_PQ, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PPD_PQ')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_PPD_PQ', fromsubclass_=False, pretty_print=True):
        super(IVL_PPD_PQ, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IVL_PPD_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = IVXB_PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'high':
            obj_ = IVXB_PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        super(IVL_PPD_PQ, self).buildChildren(child_, node, nodeName_, True)
# end class IVL_PPD_PQ


class IVXB_PPD_TS(PPD_TS):
    """Specifies whether the limit is included in the
    interval (interval is closed) or excluded from the
    interval (interval is open)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PPD_TS
    def __init__(self, nullFlavor=None, value=None, distributionType=None, standardDeviation=None, inclusive='true', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVXB_PPD_TS, self).__init__(nullFlavor, value, distributionType, standardDeviation,  **kwargs_)
        self.inclusive = _cast(bool, inclusive)
        self.inclusive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_PPD_TS.subclass:
            return IVXB_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return IVXB_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            super(IVXB_PPD_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVXB_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PPD_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVXB_PPD_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVXB_PPD_TS'):
        super(IVXB_PPD_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVXB_PPD_TS')
        if not self.inclusive and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive="%s"' % self.gds_format_boolean(self.inclusive, input_name='inclusive'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVXB_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(IVXB_PPD_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            if value in ('true', '1'):
                self.inclusive = True
            elif value in ('false', '0'):
                self.inclusive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_PPD_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IVXB_PPD_TS, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IVXB_PPD_TS


class SXCM_PPD_TS(PPD_TS):
    """A code specifying whether the set component is included
    (union) or excluded (set-difference) from the set, or
    other set operations with the current set component and
    the set as constructed from the representation stream
    up to the current point."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PPD_TS
    def __init__(self, nullFlavor=None, value=None, distributionType=None, standardDeviation=None, operator='I', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SXCM_PPD_TS, self).__init__(nullFlavor, value, distributionType, standardDeviation, extensiontype_,  **kwargs_)
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_PPD_TS.subclass:
            return SXCM_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return SXCM_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SetOperator(self, value):
        # Validate type SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['A', 'E', 'H', 'I', 'P']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperator' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SetOperator_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SetOperator_patterns_, ))
    validate_SetOperator_patterns_ = [['^([^\\s]+)$']]
    def hasContent_(self):
        if (
            super(SXCM_PPD_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SXCM_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PPD_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SXCM_PPD_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SXCM_PPD_TS'):
        super(SXCM_PPD_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SXCM_PPD_TS')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SXCM_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(SXCM_PPD_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.operator = ' '.join(self.operator.split())
            self.validate_SetOperator(self.operator)    # validate type SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_PPD_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SXCM_PPD_TS, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SXCM_PPD_TS


class PIVL_PPD_TS(SXCM_PPD_TS):
    """Note: because this type is defined as an extension of SXCM_T,
    all of the attributes and elements accepted for T are also
    accepted by this definition. However, they are NOT allowed
    by the normative description of this type. Unfortunately,
    we cannot write a general purpose schematron contraints to
    provide that extra validation, thus applications must be
    aware that instance (fragments) that pass validation with
    this might might still not be legal.
    Specifies if and how the repetitions are aligned to
    the cycles of the underlying calendar (e.g., to
    distinguish every 30 days from "the 5th of every
    month".) A non-aligned periodic interval recurs
    independently from the calendar. An aligned periodic
    interval is synchronized with the calendar.
    Indicates whether the exact timing is up to the party
    executing the schedule (e.g., to distinguish "every 8
    hours" from "3 times a day".)"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PPD_TS
    def __init__(self, nullFlavor=None, value=None, distributionType=None, standardDeviation=None, operator='I', alignment=None, institutionSpecified='false', phase=None, period=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PIVL_PPD_TS, self).__init__(nullFlavor, value, distributionType, standardDeviation, operator,  **kwargs_)
        self.alignment = _cast(None, alignment)
        self.alignment_nsprefix_ = None
        self.institutionSpecified = _cast(bool, institutionSpecified)
        self.institutionSpecified_nsprefix_ = None
        self.phase = phase
        self.phase_nsprefix_ = None
        self.period = period
        self.period_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PIVL_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PIVL_PPD_TS.subclass:
            return PIVL_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return PIVL_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_phase(self):
        return self.phase
    def set_phase(self, phase):
        self.phase = phase
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_alignment(self):
        return self.alignment
    def set_alignment(self, alignment):
        self.alignment = alignment
    def get_institutionSpecified(self):
        return self.institutionSpecified
    def set_institutionSpecified(self, institutionSpecified):
        self.institutionSpecified = institutionSpecified
    def validate_CalendarCycle(self, value):
        # Validate type CalendarCycle, a restriction on None.
        pass
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.phase is not None or
            self.period is not None or
            super(PIVL_PPD_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PIVL_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PIVL_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PIVL_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PIVL_PPD_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PIVL_PPD_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PIVL_PPD_TS'):
        super(PIVL_PPD_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PIVL_PPD_TS')
        if self.alignment is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            outfile.write(' alignment=%s' % (quote_attrib(self.alignment), ))
        if self.institutionSpecified and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            outfile.write(' institutionSpecified="%s"' % self.gds_format_boolean(self.institutionSpecified, input_name='institutionSpecified'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PIVL_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(PIVL_PPD_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.phase is not None:
            namespaceprefix_ = self.phase_nsprefix_ + ':' if (UseCapturedNS_ and self.phase_nsprefix_) else ''
            self.phase.export(outfile, level, namespaceprefix_, namespacedef_='', name_='phase', pretty_print=pretty_print)
        if self.period is not None:
            namespaceprefix_ = self.period_nsprefix_ + ':' if (UseCapturedNS_ and self.period_nsprefix_) else ''
            self.period.export(outfile, level, namespaceprefix_, namespacedef_='', name_='period', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alignment', node)
        if value is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            self.alignment = value
            self.validate_CalendarCycle(self.alignment)    # validate type CalendarCycle
        value = find_attr_value_('institutionSpecified', node)
        if value is not None and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            if value in ('true', '1'):
                self.institutionSpecified = True
            elif value in ('false', '0'):
                self.institutionSpecified = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.institutionSpecified)    # validate type bl
        super(PIVL_PPD_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'phase':
            obj_ = IVL_PPD_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.phase = obj_
            obj_.original_tagname_ = 'phase'
        elif nodeName_ == 'period':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.period = obj_
            obj_.original_tagname_ = 'period'
        super(PIVL_PPD_TS, self).buildChildren(child_, node, nodeName_, True)
# end class PIVL_PPD_TS


class EIVL_TS(SXCM_TS):
    """Note: because this type is defined as an extension of SXCM_T,
    all of the attributes and elements accepted for T are also
    accepted by this definition. However, they are NOT allowed
    by the normative description of this type. Unfortunately,
    we cannot write a general purpose schematron contraints to
    provide that extra validation, thus applications must be
    aware that instance (fragments) that pass validation with
    this might might still not be legal."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor=None, value=None, operator='I', event=None, offset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EIVL_TS, self).__init__(nullFlavor, value, operator,  **kwargs_)
        self.event = event
        self.event_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EIVL_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EIVL_TS.subclass:
            return EIVL_TS.subclass(*args_, **kwargs_)
        else:
            return EIVL_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def hasContent_(self):
        if (
            self.event is not None or
            self.offset is not None or
            super(EIVL_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIVL_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EIVL_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EIVL_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EIVL_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EIVL_TS'):
        super(EIVL_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL_TS')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIVL_TS', fromsubclass_=False, pretty_print=True):
        super(EIVL_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.event is not None:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            self.event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='event', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EIVL_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'event':
            obj_ = EIVL_event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event = obj_
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'offset':
            class_obj_ = self.get_class_obj_(child_, IVL_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
        super(EIVL_TS, self).buildChildren(child_, node, nodeName_, True)
# end class EIVL_TS


class PIVL_TS(SXCM_TS):
    """Note: because this type is defined as an extension of SXCM_T,
    all of the attributes and elements accepted for T are also
    accepted by this definition. However, they are NOT allowed
    by the normative description of this type. Unfortunately,
    we cannot write a general purpose schematron contraints to
    provide that extra validation, thus applications must be
    aware that instance (fragments) that pass validation with
    this might might still not be legal.
    Specifies if and how the repetitions are aligned to
    the cycles of the underlying calendar (e.g., to
    distinguish every 30 days from "the 5th of every
    month".) A non-aligned periodic interval recurs
    independently from the calendar. An aligned periodic
    interval is synchronized with the calendar.
    Indicates whether the exact timing is up to the party
    executing the schedule (e.g., to distinguish "every 8
    hours" from "3 times a day".)"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor=None, value=None, operator='I', alignment=None, institutionSpecified='false', phase=None, period=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PIVL_TS, self).__init__(nullFlavor, value, operator,  **kwargs_)
        self.alignment = _cast(None, alignment)
        self.alignment_nsprefix_ = None
        self.institutionSpecified = _cast(bool, institutionSpecified)
        self.institutionSpecified_nsprefix_ = None
        self.phase = phase
        self.phase_nsprefix_ = None
        self.period = period
        self.period_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PIVL_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PIVL_TS.subclass:
            return PIVL_TS.subclass(*args_, **kwargs_)
        else:
            return PIVL_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_phase(self):
        return self.phase
    def set_phase(self, phase):
        self.phase = phase
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_alignment(self):
        return self.alignment
    def set_alignment(self, alignment):
        self.alignment = alignment
    def get_institutionSpecified(self):
        return self.institutionSpecified
    def set_institutionSpecified(self, institutionSpecified):
        self.institutionSpecified = institutionSpecified
    def validate_CalendarCycle(self, value):
        # Validate type CalendarCycle, a restriction on None.
        pass
    def validate_bl(self, value):
        # Validate type bl, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^(true|false)$']]
    def hasContent_(self):
        if (
            self.phase is not None or
            self.period is not None or
            super(PIVL_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PIVL_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PIVL_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PIVL_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PIVL_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PIVL_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PIVL_TS'):
        super(PIVL_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PIVL_TS')
        if self.alignment is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            outfile.write(' alignment=%s' % (quote_attrib(self.alignment), ))
        if self.institutionSpecified and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            outfile.write(' institutionSpecified="%s"' % self.gds_format_boolean(self.institutionSpecified, input_name='institutionSpecified'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PIVL_TS', fromsubclass_=False, pretty_print=True):
        super(PIVL_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.phase is not None:
            namespaceprefix_ = self.phase_nsprefix_ + ':' if (UseCapturedNS_ and self.phase_nsprefix_) else ''
            self.phase.export(outfile, level, namespaceprefix_, namespacedef_='', name_='phase', pretty_print=pretty_print)
        if self.period is not None:
            namespaceprefix_ = self.period_nsprefix_ + ':' if (UseCapturedNS_ and self.period_nsprefix_) else ''
            self.period.export(outfile, level, namespaceprefix_, namespacedef_='', name_='period', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alignment', node)
        if value is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            self.alignment = value
            self.validate_CalendarCycle(self.alignment)    # validate type CalendarCycle
        value = find_attr_value_('institutionSpecified', node)
        if value is not None and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            if value in ('true', '1'):
                self.institutionSpecified = True
            elif value in ('false', '0'):
                self.institutionSpecified = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_bl(self.institutionSpecified)    # validate type bl
        super(PIVL_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'phase':
            obj_ = IVL_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.phase = obj_
            obj_.original_tagname_ = 'phase'
        elif nodeName_ == 'period':
            class_obj_ = self.get_class_obj_(child_, PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.period = obj_
            obj_.original_tagname_ = 'period'
        super(PIVL_TS, self).buildChildren(child_, node, nodeName_, True)
# end class PIVL_TS


class IVL_TS(SXCM_TS):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor=None, value=None, operator='I', low=None, high=None, width=None, center=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVL_TS, self).__init__(nullFlavor, value, operator, valueOf_, mixedclass_, content_,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_TS.subclass:
            return IVL_TS.subclass(*args_, **kwargs_)
        else:
            return IVL_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(IVL_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVL_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_TS'):
        super(IVL_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_TS')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_TS', fromsubclass_=False, pretty_print=True):
        super(IVL_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IVL_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'low', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_low'):
              self.add_low(obj_.value)
            elif hasattr(self, 'set_low'):
              self.set_low(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, TS)
            class_obj_ = TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
              self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
              self.set_center(obj_.value)
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PQ)
            class_obj_ = PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVL_TS, self).buildChildren(child_, node, nodeName_, True)
# end class IVL_TS


class EIVL_PPD_TS(SXCM_PPD_TS):
    """Note: because this type is defined as an extension of SXCM_T,
    all of the attributes and elements accepted for T are also
    accepted by this definition. However, they are NOT allowed
    by the normative description of this type. Unfortunately,
    we cannot write a general purpose schematron contraints to
    provide that extra validation, thus applications must be
    aware that instance (fragments) that pass validation with
    this might might still not be legal."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PPD_TS
    def __init__(self, nullFlavor=None, value=None, distributionType=None, standardDeviation=None, operator='I', event=None, offset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EIVL_PPD_TS, self).__init__(nullFlavor, value, distributionType, standardDeviation, operator,  **kwargs_)
        self.event = event
        self.event_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EIVL_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EIVL_PPD_TS.subclass:
            return EIVL_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return EIVL_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def hasContent_(self):
        if (
            self.event is not None or
            self.offset is not None or
            super(EIVL_PPD_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIVL_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EIVL_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EIVL_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL_PPD_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EIVL_PPD_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EIVL_PPD_TS'):
        super(EIVL_PPD_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIVL_PPD_TS')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIVL_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(EIVL_PPD_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.event is not None:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            self.event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='event', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EIVL_PPD_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'event':
            obj_ = EIVL_event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event = obj_
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'offset':
            obj_ = IVL_PPD_PQ.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
        super(EIVL_PPD_TS, self).buildChildren(child_, node, nodeName_, True)
# end class EIVL_PPD_TS


class IVL_PPD_TS(SXCM_PPD_TS):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SXCM_PPD_TS
    def __init__(self, nullFlavor=None, value=None, distributionType=None, standardDeviation=None, operator='I', low=None, high=None, width=None, center=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IVL_PPD_TS, self).__init__(nullFlavor, value, distributionType, standardDeviation, operator,  **kwargs_)
        self.low = low
        self.low_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.high = high
        self.high_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_PPD_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_PPD_TS.subclass:
            return IVL_PPD_TS.subclass(*args_, **kwargs_)
        else:
            return IVL_PPD_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def hasContent_(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            super(IVL_PPD_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_PPD_TS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_PPD_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IVL_PPD_TS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PPD_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IVL_PPD_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IVL_PPD_TS'):
        super(IVL_PPD_TS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IVL_PPD_TS')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IVL_PPD_TS', fromsubclass_=False, pretty_print=True):
        super(IVL_PPD_TS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            namespaceprefix_ = self.low_nsprefix_ + ':' if (UseCapturedNS_ and self.low_nsprefix_) else ''
            self.low.export(outfile, level, namespaceprefix_, namespacedef_='', name_='low', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.high is not None:
            namespaceprefix_ = self.high_nsprefix_ + ':' if (UseCapturedNS_ and self.high_nsprefix_) else ''
            self.high.export(outfile, level, namespaceprefix_, namespacedef_='', name_='high', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IVL_PPD_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'low':
            obj_ = IVXB_PPD_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = IVXB_PPD_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'high':
            obj_ = IVXB_PPD_TS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, PPD_TS)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, PPD_PQ)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        super(IVL_PPD_TS, self).buildChildren(child_, node, nodeName_, True)
# end class IVL_PPD_TS


GDSClassesMapping = {
    'ClinicalDocument': POCD_MT000040_ClinicalDocument,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in list(node.nsmap.items())
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in list(nsmap.items())
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'POCD_MT000040_ClinicalDocument'
        rootClass = POCD_MT000040_ClinicalDocument
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'POCD_MT000040_ClinicalDocument'
        rootClass = POCD_MT000040_ClinicalDocument
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'POCD_MT000040_ClinicalDocument'
        rootClass = POCD_MT000040_ClinicalDocument
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'POCD_MT000040_ClinicalDocument'
        rootClass = POCD_MT000040_ClinicalDocument
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from cda_parser import *\n\n')
        sys.stdout.write('import cda_parser as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'urn:hl7-org:v3': [('StrucDoc_Text', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Title', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Br', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Caption', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Col', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Colgroup', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Content', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_TitleContent', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Footnote', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_TitleFootnote', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_FootnoteRef', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Item', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_LinkHtml', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_List', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Paragraph', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_RenderMultiMedia', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Sub', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Sup', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Table', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Tbody', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Td', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Tfoot', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Th', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Thead', 'NarrativeBlock.xsd', 'CT'),
                    ('StrucDoc_Tr', 'NarrativeBlock.xsd', 'CT'),
                    ('POCD_MT000040_InfrastructureRoot_typeId',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_InfrastructureRoot_templateId',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Act', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_AssignedAuthor',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedCustodian',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_AssignedEntity',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_AssociatedEntity',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Authenticator',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Author', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_AuthoringDevice',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Authorization',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Birthplace', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_ClinicalDocument',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Component1', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Component2', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Component3', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Component4', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Component5', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Consent', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Consumable', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Criterion', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Custodian', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_CustodianOrganization',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_DataEnterer', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Device', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_DocumentationOf',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_EncompassingEncounter',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Encounter', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_EncounterParticipant',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Entity', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Entry', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_EntryRelationship',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalAct', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_ExternalDocument',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalObservation',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_ExternalProcedure',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Guardian', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_HealthCareFacility',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Informant12', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_InformationRecipient',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_InFulfillmentOf',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_IntendedRecipient',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_LabeledDrug', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_LanguageCommunication',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_LegalAuthenticator',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Location', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_MaintainedEntity',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_ManufacturedProduct',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Material', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_NonXMLBody', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Observation', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_ObservationMedia',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_ObservationRange',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Order', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Organization',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_OrganizationPartOf',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Organizer', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_ParentDocument',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Participant1',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Participant2',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_ParticipantRole',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Patient', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_PatientRole', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Performer1', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Performer2', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Person', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Place', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_PlayingEntity',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Precondition',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Procedure', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_Product', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_RecordTarget',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Reference', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_ReferenceRange',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_RegionOfInterest_value',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_RegionOfInterest',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedDocument',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedEntity',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_RelatedSubject',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_ResponsibleParty',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Section', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_ServiceEvent',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Specimen', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_SpecimenRole',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_StructuredBody',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Subject', 'POCD_MT000040_Fi.xsd', 'CT'),
                    ('POCD_MT000040_SubjectPerson',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_SubstanceAdministration',
                     'POCD_MT000040_Fi.xsd',
                     'CT'),
                    ('POCD_MT000040_Supply', 'POCD_MT000040_Fi.xsd', 'CT')],
 'urn:hl7finland': [('tableOfContents',
                     'hl7fi_extensions_cdar2header.xsd',
                     'CT'),
                    ('serviceChainLink',
                     'hl7fi_extensions_cdar2header.xsd',
                     'CT'),
                    ('episodeLink', 'hl7fi_extensions_cdar2header.xsd', 'CT'),
                    ('product', 'hl7fi_extensions_cdar2header.xsd', 'CT'),
                    ('signatureCollection',
                     'hl7fi_extensions_cdar2header.xsd',
                     'CT'),
                    ('secondaryCustodian',
                     'hl7fi_extensions_cdar2header.xsd',
                     'CT'),
                    ('KantaMetadata', 'hl7fi_extensions_cdar2header.xsd', 'CT'),
                    ('auditTrail', 'hl7fi_extensions_cdar2header.xsd', 'CT'),
                    ('sender', 'hl7fi_extensions_cdar2header.xsd', 'CT')]}

__all__ = [
    "AD",
    "ADXP",
    "ANY",
    "ANYNonNull",
    "BIN",
    "BL",
    "BN",
    "BXIT_CD",
    "BXIT_IVL_PQ",
    "CD",
    "CE",
    "CO",
    "CR",
    "CS",
    "CV",
    "ED",
    "EIVL_PPD_TS",
    "EIVL_TS",
    "EIVL_event",
    "EN",
    "ENXP",
    "GLIST_PQ",
    "GLIST_TS",
    "HXIT_CE",
    "HXIT_PQ",
    "II",
    "INT",
    "IVL_INT",
    "IVL_MO",
    "IVL_PPD_PQ",
    "IVL_PPD_TS",
    "IVL_PQ",
    "IVL_REAL",
    "IVL_TS",
    "IVXB_INT",
    "IVXB_MO",
    "IVXB_PPD_PQ",
    "IVXB_PPD_TS",
    "IVXB_PQ",
    "IVXB_REAL",
    "IVXB_TS",
    "KantaMetadata",
    "MO",
    "ON",
    "PIVL_PPD_TS",
    "PIVL_TS",
    "PN",
    "POCD_MT000040_Act",
    "POCD_MT000040_AssignedAuthor",
    "POCD_MT000040_AssignedCustodian",
    "POCD_MT000040_AssignedEntity",
    "POCD_MT000040_AssociatedEntity",
    "POCD_MT000040_Authenticator",
    "POCD_MT000040_Author",
    "POCD_MT000040_AuthoringDevice",
    "POCD_MT000040_Authorization",
    "POCD_MT000040_Birthplace",
    "POCD_MT000040_ClinicalDocument",
    "POCD_MT000040_Component1",
    "POCD_MT000040_Component2",
    "POCD_MT000040_Component3",
    "POCD_MT000040_Component4",
    "POCD_MT000040_Component5",
    "POCD_MT000040_Consent",
    "POCD_MT000040_Consumable",
    "POCD_MT000040_Criterion",
    "POCD_MT000040_Custodian",
    "POCD_MT000040_CustodianOrganization",
    "POCD_MT000040_DataEnterer",
    "POCD_MT000040_Device",
    "POCD_MT000040_DocumentationOf",
    "POCD_MT000040_EncompassingEncounter",
    "POCD_MT000040_Encounter",
    "POCD_MT000040_EncounterParticipant",
    "POCD_MT000040_Entity",
    "POCD_MT000040_Entry",
    "POCD_MT000040_EntryRelationship",
    "POCD_MT000040_ExternalAct",
    "POCD_MT000040_ExternalDocument",
    "POCD_MT000040_ExternalObservation",
    "POCD_MT000040_ExternalProcedure",
    "POCD_MT000040_Guardian",
    "POCD_MT000040_HealthCareFacility",
    "POCD_MT000040_InFulfillmentOf",
    "POCD_MT000040_Informant12",
    "POCD_MT000040_InformationRecipient",
    "POCD_MT000040_InfrastructureRoot_templateId",
    "POCD_MT000040_InfrastructureRoot_typeId",
    "POCD_MT000040_IntendedRecipient",
    "POCD_MT000040_LabeledDrug",
    "POCD_MT000040_LanguageCommunication",
    "POCD_MT000040_LegalAuthenticator",
    "POCD_MT000040_Location",
    "POCD_MT000040_MaintainedEntity",
    "POCD_MT000040_ManufacturedProduct",
    "POCD_MT000040_Material",
    "POCD_MT000040_NonXMLBody",
    "POCD_MT000040_Observation",
    "POCD_MT000040_ObservationMedia",
    "POCD_MT000040_ObservationRange",
    "POCD_MT000040_Order",
    "POCD_MT000040_Organization",
    "POCD_MT000040_OrganizationPartOf",
    "POCD_MT000040_Organizer",
    "POCD_MT000040_ParentDocument",
    "POCD_MT000040_Participant1",
    "POCD_MT000040_Participant2",
    "POCD_MT000040_ParticipantRole",
    "POCD_MT000040_Patient",
    "POCD_MT000040_PatientRole",
    "POCD_MT000040_Performer1",
    "POCD_MT000040_Performer2",
    "POCD_MT000040_Person",
    "POCD_MT000040_Place",
    "POCD_MT000040_PlayingEntity",
    "POCD_MT000040_Precondition",
    "POCD_MT000040_Procedure",
    "POCD_MT000040_Product",
    "POCD_MT000040_RecordTarget",
    "POCD_MT000040_Reference",
    "POCD_MT000040_ReferenceRange",
    "POCD_MT000040_RegionOfInterest",
    "POCD_MT000040_RegionOfInterest_value",
    "POCD_MT000040_RelatedDocument",
    "POCD_MT000040_RelatedEntity",
    "POCD_MT000040_RelatedSubject",
    "POCD_MT000040_ResponsibleParty",
    "POCD_MT000040_Section",
    "POCD_MT000040_ServiceEvent",
    "POCD_MT000040_Specimen",
    "POCD_MT000040_SpecimenRole",
    "POCD_MT000040_StructuredBody",
    "POCD_MT000040_Subject",
    "POCD_MT000040_SubjectPerson",
    "POCD_MT000040_SubstanceAdministration",
    "POCD_MT000040_Supply",
    "PPD_PQ",
    "PPD_TS",
    "PQ",
    "PQR",
    "QTY",
    "REAL",
    "RTO",
    "RTO_MO_PQ",
    "RTO_PQ_PQ",
    "RTO_QTY_QTY",
    "RefType",
    "SC",
    "SLIST_PQ",
    "SLIST_TS",
    "ST",
    "SXCM_CD",
    "SXCM_INT",
    "SXCM_MO",
    "SXCM_PPD_PQ",
    "SXCM_PPD_TS",
    "SXCM_PQ",
    "SXCM_REAL",
    "SXCM_TS",
    "SXPR_TS",
    "StrucDoc_Br",
    "StrucDoc_Caption",
    "StrucDoc_Col",
    "StrucDoc_Colgroup",
    "StrucDoc_Content",
    "StrucDoc_Footnote",
    "StrucDoc_FootnoteRef",
    "StrucDoc_Item",
    "StrucDoc_LinkHtml",
    "StrucDoc_List",
    "StrucDoc_Paragraph",
    "StrucDoc_RenderMultiMedia",
    "StrucDoc_Sub",
    "StrucDoc_Sup",
    "StrucDoc_Table",
    "StrucDoc_Tbody",
    "StrucDoc_Td",
    "StrucDoc_Text",
    "StrucDoc_Tfoot",
    "StrucDoc_Th",
    "StrucDoc_Thead",
    "StrucDoc_Title",
    "StrucDoc_TitleContent",
    "StrucDoc_TitleFootnote",
    "StrucDoc_Tr",
    "TEL",
    "TN",
    "TS",
    "URL",
    "UVP_TS",
    "adxp_additionalLocator",
    "adxp_buildingNumberSuffix",
    "adxp_careOf",
    "adxp_censusTract",
    "adxp_city",
    "adxp_country",
    "adxp_county",
    "adxp_delimiter",
    "adxp_deliveryAddressLine",
    "adxp_deliveryInstallationArea",
    "adxp_deliveryInstallationQualifier",
    "adxp_deliveryInstallationType",
    "adxp_deliveryMode",
    "adxp_deliveryModeIdentifier",
    "adxp_direction",
    "adxp_houseNumber",
    "adxp_houseNumberNumeric",
    "adxp_postBox",
    "adxp_postalCode",
    "adxp_precinct",
    "adxp_state",
    "adxp_streetAddressLine",
    "adxp_streetName",
    "adxp_streetNameBase",
    "adxp_streetNameType",
    "adxp_unitID",
    "adxp_unitType",
    "auditTrail",
    "en_delimiter",
    "en_family",
    "en_given",
    "en_prefix",
    "en_suffix",
    "episodeLink",
    "localHeader",
    "multipleDocumentSignatureType",
    "product",
    "secondaryCustodian",
    "sender",
    "serviceChainLink",
    "signatureCollection",
    "signatureTimestampType",
    "signatureType",
    "softwareSupportType",
    "tableOfContents",
    "thumbnail"
]
